<!DOCTYPE html>
<html lang="en" dir="rtl">
<head>
    <script src="https://cdn.lgrckt-in.com/LogRocket.min.js" crossorigin="anonymous"></script>
    <script>
       window.LogRocket && window.LogRocket.init('hitfhq/dcref-emt');
    </script>
    <script src="https://www.unpkg.com/@hyperdx/browser@0.21.0/build/index.js"></script>
    <script>
    window.HyperDX.init({
        apiKey: '3377443f-ce49-449d-8ec3-4db172e5ddd2',
        service: 'DCRef',  
        consoleCapture: true, 
        advancedNetworkCapture: false
    });
    </script>
    <script>
        !function(t,e){var o,n,p,r;e.__SV||(window.posthog && window.posthog.__loaded)||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="init Xr es pi Zr rs Kr Qr capture Ni calculateEventProperties os register register_once register_for_session unregister unregister_for_session ds getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey displaySurvey cancelPendingSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException startExceptionAutocapture stopExceptionAutocapture loadToolbar get_property getSessionProperty us ns createPersonProfile hs Vr vs opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing get_explicit_consent_status is_capturing clear_opt_in_out_capturing ss debug O ls getPageViewId captureTraceFeedback captureTraceMetric qr".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
        posthog.init('phc_3uotKG0DwlxtUuIhhhX9bw1J4SXIBXz1uHfcXzPdxQS', {
            api_host: 'https://us.i.posthog.com',
            defaults: '2025-11-30',
            person_profiles: 'identified_only',
        })
        posthog.startExceptionAutocapture()
    </script>
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "tzsxusebyo");
    </script>
    <script defer src="https://cloud.umami.is/script.js" data-website-id="4d04a0ff-950d-42aa-b123-ce9984e37559"></script>
    <!-- <script>
        // Immediate cleanup function
        (function() {
            // Clear localStorage and sessionStorage
            localStorage.clear();
            sessionStorage.clear();
        
            // Delete all accessible cookies
            document.cookie.split("; ").forEach(cookie => {
                const [name] = cookie.split('=');
                document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=${location.hostname}`;
            });
        
            // Clear cache storage
            if ('caches' in window) {
                caches.keys().then(cacheNames => {
                    cacheNames.forEach(cacheName => caches.delete(cacheName))
                });
            }
        
            // Unregister service workers
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations()
                    .then(registrations => {
                        registrations.forEach(registration => registration.unregister())
                    });
            }
        
            // Clear IndexedDB databases (if needed)
            if (window.indexedDB) {
                indexedDB.databases().then(dbs => {
                    dbs.forEach(db => indexedDB.deleteDatabase(db.name));
                });
            }
        })();
    </script>  -->
    
    <script type="module">
        import { init, id, lookup } from 'https://cdn.jsdelivr.net/npm/@instantdb/core@0.22.90/+esm';
        window.InstantDB = { init, id, lookup };
    </script>
    <script src="https://telegram.org/js/telegram-web-app.js?56"></script>    
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
        <title>ÿØŸÑŸäŸÑ ÿßŸÑŸÖÿ≠ŸÇŸÇ ŸÉŸàŸÜÿßŸÜ</title>
        <style>
            /* Hide elements with v-cloak until Vue is ready */
            [v-cloak] {
                display: none !important;
            }
            
            /* Loading spinner animation */
            .coin-spin {
                animation: spin-y 3s infinite linear; 
                transform-style: preserve-3d;
                -webkit-animation: spin-y 3s infinite linear;
                -webkit-transform-style: preserve-3d;
            }

            @keyframes spin-y {
                0% { transform: rotateY(0deg); }
                100% { transform: rotateY(360deg); }
            }
            @-webkit-keyframes spin-y {
                0% { -webkit-transform: rotateY(0deg); transform: rotateY(0deg); }
                100% { -webkit-transform: rotateY(360deg); transform: rotateY(360deg); }
            }
            
            /* Hide loading spinner when Vue is ready */
            body.vue-ready #vue-loading {
                display: none !important;
            }
            
            .fade-slide-enter-active,
            .fade-slide-leave-active {
            transition: all 0.25s ease;
            }
            .fade-slide-enter-from {
            opacity: 0;
            transform: translateY(-10px);
            }
            .fade-slide-leave-to {
            opacity: 0;
            transform: translateY(-10px);
            }
        </style>
        <style>
            .tippy-box[data-theme~='retro'] {
                background-color: #000000;
                color: #ffffff;
                border: 2px solid #FF6448;
                border-radius: 8px;
                font-weight: bold;
                font-size: 15px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            }
            .tippy-box[data-theme~='retro'][data-placement^='top'] > .tippy-arrow::before {
                border-top-color: #FF6448;
            }
        </style>
        <style>
            .always-visible-scrollbar {
                overflow-y: scroll !important; /* Always show scrollbar */
                scrollbar-width: thin; /* For Firefox */
                scrollbar-color: rgba(255, 255, 255, 0.7) transparent; /* Custom color */
            }
        
            /* For Webkit Browsers (Chrome, Edge, Safari) */
            .always-visible-scrollbar::-webkit-scrollbar {
                width: 8px; /* Width of scrollbar */
            }
        
            .always-visible-scrollbar::-webkit-scrollbar-track {
                background: transparent; /* Track background */
            }
        
            .always-visible-scrollbar::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.7); /* Scrollbar color */
                border-radius: 4px;
            }
        </style>
        <style>
            .zikr-box {
                display: block;
                text-align: center;
                font-weight: bold;
                color: #3dff94;
                margin: 4vh auto;
                transition: opacity 0.8s ease-in-out;
            }
            
            @media (min-width: 320px) {
                .zikr-box {
                    font-size: 15px;
                }
            }
            
            @media (min-width: 360px) {
                .zikr-box {
                    font-size: 18px;
                }
            }
            
            @media (min-width: 400px) {
                .zikr-box {
                    font-size: 20px;
                }
            }
            
            @media (min-width: 440px) and (max-width: 1023px) {
                .zikr-box {
                    font-size: 23px;
                }
            }
            
            @media (min-width: 1024px) {
                .zikr-box {
                    font-size: 25px;
                }
            }
            
            .fade-enter-active,
            .fade-leave-active {
                transition: opacity 0.8s;
            }
            .fade-enter-from,
            .fade-leave-to {
                opacity: 0;
            }
        </style>
        <style>
            /* Custom responsive positioning for modal navigation buttons */
            .modal-nav-btn {
                right: -40px;
            }
            
            @media (min-width: 360px) {
                .modal-nav-btn {
                    right: -42px;
                }
            }
            
            @media (min-width: 400px) {
                .modal-nav-btn {
                    right: -44px;
                }
            }
            
            @media (min-width: 440px) {
                .modal-nav-btn {
                    right: -46px;
                }
            }
            
            @media (min-width: 480px) {
                .modal-nav-btn {
                    right: -48px;
                }
            }
            
            @media (min-width: 520px) {
                .modal-nav-btn {
                    right: -50px;
                }
            }
            
            @media (min-width: 560px) {
                .modal-nav-btn {
                    right: -52px;
                }
            }
            
            @media (min-width: 600px) {
                .modal-nav-btn {
                    right: -54px;
                }
            }
            
            @media (min-width: 640px) {
                .modal-nav-btn {
                    right: -56px;
                }
            }
            
            @media (min-width: 680px) {
                .modal-nav-btn {
                    right: -58px;
                }
            }
            
            @media (min-width: 720px) {
                .modal-nav-btn {
                    right: -60px;
                }
            }
            
            @media (min-width: 760px) {
                .modal-nav-btn {
                    right: -62px;
                }
            }
            
            @media (min-width: 768px) {
                .modal-nav-btn {
                    right: -62px;
                }
            }
            
            @media (min-width: 1024px) {
                .modal-nav-btn {
                    right: -62px;
                }
            }
        </style>    
        <script>
            function isInput(event) {
                return event.target.tagName === 'INPUT' ||
                    event.target.tagName === 'TEXTAREA' ||
                    event.target.isContentEditable;
            }

            document.addEventListener('contextmenu', (event) => {
                if (!isInput(event)) {
                    event.preventDefault();
                }
            });

            document.addEventListener('keydown', (event) => {
                if (!isInput(event) && (event.ctrlKey || event.metaKey) && ['c', 'x', 'v', 'a', 's', 'p'].includes(event.key.toLowerCase())) {
                    event.preventDefault();
                }
            });

            document.addEventListener('selectstart', (event) => {
                if (!isInput(event)) {
                    event.preventDefault();
                }
            });
        
                // Disable Ctrl+U (View Source), Ctrl+Shift+I (DevTools)
                // if (event.ctrlKey && 
                //     (event.key.toLowerCase() === 'u' || 
                //     (event.shiftKey && event.key.toLowerCase() === 'i'))) {
                //     event.preventDefault();
                // }
        </script>    
        <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.13/dist/html-to-image.min.js"></script>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            /* Disable text selection */

            /* html{
                touch-action: none; Prevent touch gestures like pinch-to-zoom
            } */

            /* body {
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                /* touch-action: none;
            } */

            * {
                -webkit-user-drag: none; /* Disable dragging */
                -webkit-touch-callout: none; /* Disable callouts on iOS */
                user-select: none; /* Disable text selection */
                -webkit-user-select: none; /* For WebKit browsers */
                -moz-user-select: none; /* For Firefox */
                -ms-user-select: none; /* For IE */
            }

            /* Allow text selection specifically in the search input */
            input[type="text"], input[type="search"], textarea, [contenteditable="true"], input.v-model {
                user-select: text; /* Enable text selection for input fields */
                -webkit-user-select: text; /* For WebKit browsers (Safari, Chrome) */
                -moz-user-select: text; /* For Firefox */
                -ms-user-select: text; /* For Internet Explorer */
                pointer-events: auto;
            }
        
            /* Disable drag functionality */
            img {
                -webkit-user-drag: none; /* Disable dragging of images and links */
                pointer-events: none;
            }

            /* Enable pointer-events for specific icons */
            .icon-pointer {
                pointer-events: auto;
            }
        </style>    
        <style>
            @font-face {
                font-family: 'Expo Arabic Light';
                src: url('https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/EAL.woff2') format('woff2'),
                    url('https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/EAL.woff') format('woff'),
                    url('https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/EAL.ttf') format('truetype'),
                    url('https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/EAL.otf') format('opentype'),
                    url('https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/EAL.eot') format('embedded-opentype'),
                    url('https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/EAL.svg#EAL') format('svg');
            }
            * {
                font-family: 'Expo Arabic Light' !important;
            }

            body {
                background-color: #333333; /* Black background */
                color: #ffffff; /* White text */
            }

            table {
                background-color: #333333; /* Slightly lighter black for table background */
                color: #ffffff; /* White text for table */
            }

            input, select {
                background-color: #333333; /* Dark gray input fields */
                color: #ffffff; /* White text for inputs */
            }

            #pagination-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            }

            #pagination-buttons button {
                padding: 10px 20px;
                font-size: 16px;
                border-radius: 4px;
                transition: background-color 0.3s;
            }

            th, td {
                background-color: #2a2a2a; /* Slightly lighter black for table cells */
                color: #ffffff; /* White text for cells */
            }

            .modal {
                display: none; /* Hidden by default */
                position: fixed; /* Stay in place */
                z-index: 1; /* Sit on top */
                left: 0;
                top: 0;
                width: 100%; /* Full width */
                height: 100%; /* Full height */
                overflow: auto; /* Enable scroll if needed */
                background-color: rgb(0,0,0); /* Fallback color */
                background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            }

            .modal-content {
                background-color: black;
                margin: 15% auto; /* 15% from the top and centered */
                padding: 20px;
                border: 1px solid #888;
                width: 80%; /* Could be more or less, depending on screen size */
                max-height: 80%;
                overflow-y: auto;
            }

            .close {
                color: #aaa;
                float: left;
                font-size: 28px;
                font-weight: bold;
            }

            .close:hover,
            .close:focus {
                color: black;
                text-decoration: none;
                cursor: pointer;
            }

            /* Media Queries */
            @media (max-width: 768px) {

            #pagination-buttons {
                align-items: center;
                gap: 10px;
            }

            #pagination-buttons button {
                /* width: 100%; */
                font-size: 14px;
                padding: 8px 16px;
            }

            .fixKeyboardLayout{
                margin-bottom: 100px;
            }

                body {
                    font-size: 14px;
                }

                table {
                    font-size: 12px;
                }

                input, select {
                    font-size: 12px;
                    padding: 8px;
                }

                h1 {
                    font-size: 24px;
                }

                th, td {
                    padding: 4px;
                }
            }

            @media (min-width: 768px) and (max-width: 1024px) {
                body {
                    font-size: 16px;
                }

                table {
                    font-size: 14px;
                }

                #pagination-buttons {
                align-items: center;
                gap: 10px;
                }

                #pagination-buttons button {
                    /* width: 100%; */
                    font-size: 14px;
                    padding: 8px 16px;
                }

                input, select {
                    font-size: 14px;
                    padding: 10px;
                }

                h1 {
                    font-size: 28px;
                }

                th, td {
                    padding: 8px;
                }
            }

            @media (min-width: 1024px) {
                body {
                    font-size: 18px;
                }

                table {
                    font-size: 16px;
                }

                input, select, button {
                    font-size: 16px;
                    padding: 12px;
                }

                h1 {
                    font-size: 32px;
                }

                th, td {
                    padding: 10px;
                }
            }
        </style>

    <style>
        /* Ticker Animation */
        @keyframes ticker {
            0% {
                transform: translateX(-100%);
            }
            20% {
                transform: translateX(-3%); /* Adjust to match faster speed */
            }
            100% {
                transform: translateX(100%);
            }
        }

        .animate-ticker {
            animation: ticker 15s linear infinite;
        }

        @keyframes successHintIn {
            from { opacity: 0; transform: translateX(48px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes successHintOut {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(48px); }
        }

        .success-hint-in {
            animation: successHintIn 220ms ease-out both;
        }

        .success-hint-out {
            animation: successHintOut 220ms ease-in both;
        }
    </style>
    <style>
        .no-scroll {
            overflow: hidden !important;
            touch-action: none;
        }
    </style>
    <style>
        /* Apple Notch Style */
        .search-notch {
            position: absolute;
            top: -40px;
            left: 50%;
            width: 100px;
            height: 40px;
            background-color: #1f2937;
            border-radius: 28px 28px 0 0;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ef4444;
            font-size: 1.125rem;
            font-weight: bold;
            border: 2px solid #10b981;
            border-bottom: none;
            padding-top: 8px;
        }

        .search-notch::before,
        .search-notch::after {
            position: absolute;
            bottom: 0;
            left: -14px;
            width: 14px;
            height: 7px;
            background-size: 50% 100%;
            background-repeat: no-repeat;
            background-image: radial-gradient(
                circle at 0 0,
                transparent 6px,
                #1f2937 7px
            );
        }

        .search-notch::after {
            left: 100%;
            background-image: radial-gradient(
                circle at 100% 0,
                transparent 6px,
                #1f2937 7px
            );
        }
    </style>
    <meta name='probely-verification' content='d1a5235e-0470-4602-aae0-84688966eb19' />
    <style>
        .tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}
    </style>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.umd.min.js"></script>
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@loadingio/loading-bar@0.1.1/dist/loading-bar.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@loadingio/loading-bar@0.1.1/dist/loading-bar.min.js"></script> -->
    <style>
        @keyframes gradient-x {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes stripes {
            from { background-position: 0 0; }
            to { background-position: 40px 0; }
        }
        .animate-gradient-x {
            background-size: 200% 200%;
            animation: gradient-x 3s ease infinite;
        }
        .animate-stripes {
            animation: stripes 1s linear infinite;
        }
    </style>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,100..1000&display=swap');
        :root {
            --glass-bg: rgba(255, 255, 255, 0.06);
            --glass-text: rgba(255, 255, 255, 0.92);
        }
        .liquid-glass {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: var(--glass-bg);
            color: var(--glass-text);
            backdrop-filter: blur(10px) saturate(140%);
            -webkit-backdrop-filter: blur(10px) saturate(140%);
            box-shadow:
                inset 1px 1px 0 rgba(255, 255, 255, 0.35),
                inset -2px -2px 2px rgba(255, 255, 255, 0.25),
                0 4px 12px rgba(0, 0, 0, 0.35),
                0 12px 24px rgba(0, 0, 0, 0.25);
            transition: transform 200ms cubic-bezier(0.2, 0.9, 0.3, 1.2), box-shadow 300ms ease;
            border-radius: 20px;
            border: 0;
        }
        .liquid-glass:hover {
            transform: scale(1.04);
            box-shadow:
                inset 1px 1px 0 rgba(255, 255, 255, 0.4),
                inset -2px -2px 2px rgba(255, 255, 255, 0.3),
                0 6px 16px rgba(0, 0, 0, 0.4),
                0 16px 28px rgba(0, 0, 0, 0.3);
        }
        .liquid-glass:active {
            transform: scale(0.96);
        }
        .liquid-glass:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .liquid-glass::before {
            position: absolute;
            inset: 0;
            border-radius: inherit;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.18);
            pointer-events: none;
        }
        .liquid-glass::after {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            height: 55%;
            border-radius: inherit;
            background:
                radial-gradient(80% 120% at 10% 5%, rgba(255, 255, 255, 0.25), transparent 60%),
                radial-gradient(60% 80% at 90% 0%, rgba(255, 255, 255, 0.15), transparent 60%);
            pointer-events: none;
        }
        .liquid-glass-round {
            width: 44px;
            height: 44px;
            padding: 0;
            border-radius: 9999px;
        }
        .liquid-glass-hamburger {
            width: 56px;
            height: 44px;
            padding: 8px 10px;
            border-radius: 9999px;
        }
        .liquid-glass .bar {
            display: block;
            width: 24px;
            height: 2px;
            margin: 3px 0;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.95);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.25),
                0 -1px 0 rgba(0, 0, 0, 0.2);
        }
        .liquid-glass svg {
            color: var(--glass-text);
        }
        .liquid-glass-white {
            background: rgba(255, 255, 255, 0.9);
            color: rgba(0, 0, 0, 0.9);
            box-shadow:
                inset 1px 1px 0 rgba(255, 255, 255, 0.6),
                inset -2px -2px 2px rgba(255, 255, 255, 0.4),
                0 6px 18px rgba(0, 0, 0, 0.25),
                0 14px 28px rgba(0, 0, 0, 0.18);
        }
        .lg-switcher {
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            width: 244px;
            max-width: 244px;
            height: 70px;
            box-sizing: border-box;
            padding: 8px 12px 10px;
            margin: 0 auto;
            border-radius: 99em;
            font-family: 'DM Sans', sans-serif;
            background-color: color-mix(in srgb, #bbbbbc 12%, transparent);
            backdrop-filter: blur(8px) saturate(150%);
            -webkit-backdrop-filter: blur(8px) saturate(150%);
            box-shadow:
                inset 0 0 0 1px color-mix(in srgb, #fff 10%, transparent),
                inset 1.8px 3px 0px -2px color-mix(in srgb, #fff 90%, transparent),
                inset -2px -2px 0px -2px color-mix(in srgb, #fff 80%, transparent),
                inset -3px -8px 1px -6px color-mix(in srgb, #fff 60%, transparent),
                inset -0.3px -1px 4px 0px color-mix(in srgb, #000 12%, transparent),
                inset -1.5px 2.5px 0px -2px color-mix(in srgb, #000 20%, transparent),
                inset 0px 3px 4px -2px color-mix(in srgb, #000 20%, transparent),
                inset 2px -6.5px 1px -4px color-mix(in srgb, #000 10%, transparent),
                0px 1px 5px 0px color-mix(in srgb, #000 10%, transparent),
                0px 6px 16px 0px color-mix(in srgb, #000 8%, transparent);
            transition: background-color 400ms cubic-bezier(1, 0, 0.4, 1), box-shadow 400ms cubic-bezier(1, 0, 0.4, 1);
        }
        .lg-switcher::after {
            content: "";
            position: absolute;
            left: 4px;
            top: 4px;
            display: block;
            width: 84px;
            height: calc(100% - 10px);
            border-radius: 99em;
            background-color: color-mix(in srgb, #bbbbbc 36%, transparent);
            z-index: -1;
            box-shadow:
                inset 0 0 0 1px color-mix(in srgb, #fff 10%, transparent),
                inset 2px 1px 0px -1px color-mix(in srgb, #fff 90%, transparent),
                inset -1.5px -1px 0px -1px color-mix(in srgb, #fff 80%, transparent),
                inset -2px -6px 1px -5px color-mix(in srgb, #fff 60%, transparent),
                inset -1px 2px 3px -1px color-mix(in srgb, #000 20%, transparent),
                inset 0px -4px 1px -2px color-mix(in srgb, #000 10%, transparent),
                0px 3px 6px 0px color-mix(in srgb, #000 8%, transparent);
            transition: translate 400ms cubic-bezier(1, 0, 0.4, 1), background-color 400ms cubic-bezier(1, 0, 0.4, 1), box-shadow 400ms cubic-bezier(1, 0, 0.4, 1);
        }
        .lg-switcher:has(input[c-option="1"]:checked)::after { translate: 0 0; }
        .lg-switcher:has(input[c-option="2"]:checked)::after { translate: 80px 0; }
        .lg-switcher:has(input[c-option="3"]:checked)::after { translate: 160px 0; }
        .switcher__legend {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            border: 0;
            padding: 0;
            white-space: nowrap;
            clip-path: inset(100%);
            clip: rect(0 0 0 0);
            overflow: hidden;
        }
        .switcher__input {
            clip: rect(0 0 0 0);
            clip-path: inset(100%);
            height: 1px;
            width: 1px;
            overflow: hidden;
            position: absolute;
            white-space: nowrap;
        }
        .switcher__icon {
            display: block;
            width: 100%;
            transition: scale 200ms cubic-bezier(0.5, 0, 0, 1);
        }
        .switcher__option {
            --c: #224;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 16px;
            width: 68px;
            height: 100%;
            box-sizing: border-box;
            border-radius: 99em;
            color: var(--c);
            opacity: 1;
            transition: all 160ms;
            font-weight: 700;
        }
        .switcher__option:hover { --c: #0052f5; cursor: pointer; }
        .switcher__option:hover .switcher__icon { scale: 1.2; }
        .lg-switcher .switcher__option:has(input:checked) { --c: #224; cursor: auto; }
        .lg-switcher .switcher__option:has(input:checked) .switcher__icon { scale: 1; }
    </style>
</head>
<body class="bg-gray-800 py-4 relative">
    <!-- Loading spinner - shows before Vue initializes -->
    <div id="vue-loading" class="fixed inset-0 z-[9999] bg-black flex flex-col items-center justify-center">
        <div>
            <img 
                src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/loading.png" 
                alt="" 
                class="w-36 h-36 object-cover coin-spin rounded-full border-4 border-yellow-300/50 bg-yellow-300/10 drop-shadow-[0_0_20px_rgba(255,255,255,0.4)]"
            >
        </div>
    </div>
    
    <div id="app" v-cloak class="container mx-auto p-4 rounded"> <!-- Removed .bg-slate-700 -->

        <!-- Inactivity session modal -->
        <div 
            v-if="inactivityModal" 
            class="fixed inset-0 z-[120] bg-black/80 backdrop-blur-sm flex items-center justify-center"
        >
            <div class="bg-gray-900 text-yellow-200 rounded-lg p-6 shadow-2xl w-11/12 max-w-md text-center space-y-4">
                <div class="text-xl -m-3 font-bold">
                    ŸÑŸÇÿØ ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
                </div>
            
                <div class="text-xl font-bold text-yellow-200">
                    ÿ®ÿ≥ÿ®ÿ® ÿπÿØŸÖ ÿßŸÑŸÜÿ¥ÿßÿ∑
                </div>
            
                <button 
                    @click="refreshSession"
                    :disabled="isRefreshingSession"
                    class="px-4 py-2 bg-yellow-500 text-black font-bold rounded hover:bg-yellow-400 transition-all duration-100 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed inline-flex items-center justify-center gap-2"
                >
                    <span
                        v-if="isRefreshingSession"
                        class="animate-spin inline-block h-5 w-5 rounded-full border-2 border-black/30 border-t-black"
                    ></span>
                    <span>ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ¨ŸÑÿ≥ÿ©</span>
                </button>
            </div>        
        </div>

        <!-- Inactivity countdown badge -->
        <div 
            v-if="!inactivityModal && inactivityCountdown <= 30" 
            class="fixed bottom-4 right-1 z-[110] bg-red-900 text-yellow-300 px-2 py-2 rounded shadow-lg text-sm"
        >
            ‚ö†Ô∏è ÿ™ŸÜÿ™ŸáŸä ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿÆŸÑÿßŸÑ {{ formattedInactivityCountdown }} ÿ®ÿ≥ÿ®ÿ® ÿπÿØŸÖ ÿßŸÑŸÜÿ¥ÿßÿ∑
        </div>

        <div 
            v-if="successHintVisible"
            @click="goToBot()"
            :class="['fixed bottom-4 right-1 z-[111] bg-emerald-900 text-yellow-100 px-3 py-2 cursor-pointer rounded shadow-lg text-sm max-w-[90vw] sm:max-w-[420px]', successHintAnimatingOut ? 'success-hint-out' : 'success-hint-in']"
        >
            <div class="flex items-center gap-4">
                <!-- <button @click="dismissSuccessHint" class="text-red-600 hover:text-yellow-300 transition-all duration-100 active:scale-90">
                    <img src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/close.png" alt="Close" class="h-8 w-8" />
                </button> -->
                <img src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/true.png" alt="Success" class="h-7 w-7 -mx-2" />
                <div class="flex-1 font-bold">
                    {{ successHintMessage }}
                    <!-- <span class="opacity-80">({{ successHintCountdown }})</span> -->
                </div>
                <!-- <img src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/true.png" alt="Success" class="h-7 w-7" /> -->
            </div>
        </div>

        <div
            v-if="showErrorOverlay"
            class="fixed z-[105] inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center"
        >
            <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-4/5 md:w-1/2 lg:w-1/3 max-h-[95vh] overflow-hidden flex flex-col">
                <div class="sticky top-0 z-10">
                    <div :class="['mx-4 mt-4 rounded-xl shadow-lg ring-1 backdrop-blur bg-gradient-to-r', isFailedToFetch ? 'from-yellow-500/20 to-orange-500/20 ring-yellow-400/40' : 'from-red-600/20 to-pink-600/20 ring-red-400/40']">
                        <div class="px-4 py-3 flex items-center gap-3">
                            <div class="flex-1 text-center">
                                <span :class="['block', isFailedToFetch ? 'text-yellow-300' : 'text-red-500', 'font-bold', 'text-base md:text-lg']">{{ displayErrorPrimary }}</span>
                                <span :class="['block', 'text-gray-200', 'text-sm', 'mt-1']">{{ displayErrorSecondary }}</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div v-if="!isFailedToFetch" class="overflow-y-auto p-4 flex-1">
                    <p class="text-lg text-white text-center font-bold mb-4">
                        ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ®Ÿàÿ™ ŸÑÿØŸäŸá ÿµŸÑÿßÿ≠Ÿäÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÑŸÉ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿßÿ¥ÿ™ÿ±ÿßŸÉŸÉ ŸÅŸäŸáÿå Ÿàÿ∞ŸÑŸÉ ÿ®ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿ≤ÿ± 'Start' ÿ£Ÿà 'Restart' ÿ£Ÿà 'ÿ®ÿØÿ°' ŸÉŸÖÿß ŸáŸà ŸÖŸàÿ∂ÿ≠ ŸÅŸä ÿßŸÑÿµŸàÿ±ÿ© üëá
                    </p>
                    <img
                        src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/error_hint.png"
                        alt="Error Hint"
                        class="mb-4 w-full rounded"
                    />
                    <p class="text-lg text-white font-bold text-center mt-4">
                        ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ∏Ÿáÿ± ŸÑŸÉ ÿßŸÑÿ≤ÿ±ÿå ŸÅŸáÿ∞ÿß ŸäÿπŸÜŸä ÿ£ŸÜŸÉ ŸÖÿ¥ÿ™ÿ±ŸÉ ÿ®ÿßŸÑŸÅÿπŸÑ ŸÅŸä ÿßŸÑÿ®Ÿàÿ™.
                    </p>
                </div>

                <div :class="['p-4', 'bg-cyan-900', 'flex', isFailedToFetch ? 'justify-center' : 'justify-between']">
                    <a
                        v-if="!isFailedToFetch"
                        href="https://t.me/DCRef_bot"
                        class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-700 transition-all duration-100 active:scale-90"
                    >
                        ÿ£ÿ∂ÿ∫ÿ∑ ŸáŸÜÿß ŸÑŸÑÿ∞Ÿáÿßÿ® ÿ•ŸÑŸâ ÿßŸÑÿ®Ÿàÿ™
                    </a>
                    <button
                        @click="clearError()"
                        class="bg-gray-300 text-gray-700 px-4 py-2 rounded hover:bg-gray-400 transition-all duration-100 active:scale-90"
                    >
                        ÿ•ÿ∫ŸÑÿßŸÇ
                    </button>
                </div>
            </div>
        </div>
            <!-- Updated Menu Button -->
            <div v-if="loadingModeResolved && !loadingFromCache" class="fixed top-4 right-4 z-50 menu-container">
                <button @click.stop="toggleMenu" :disabled="loading" :class="isApplePlatform ? 'liquid-glass liquid-glass-hamburger flex flex-col items-center transition-transform duration-200 disabled:opacity-50 disabled:cursor-not-allowed' : 'bg-yellow-600 text-white p-2 rounded flex flex-col items-center transition-all duration-100 active:scale-90 disabled:opacity-50 disabled:cursor-not-allowed'">
                    <span :class="isApplePlatform ? 'bar' : 'block w-6 h-1 bg-white mb-1'"></span>
                    <span :class="isApplePlatform ? 'bar' : 'block w-6 h-1 bg-white mb-1'"></span>
                    <span :class="isApplePlatform ? 'bar' : 'block w-6 h-1 bg-white'"></span>
                </button>

                <div v-if="menuOpen" class="absolute right-0 mt-2 bg-sky-900 shadow-lg rounded py-2 w-32">
                    <button @click="openDirectWindow('episodes')" class="block w-full px-4 py-2 text-base font-bold text-white hover:bg-teal-600 transition-all duration-100 active:scale-90">ÿ≠ŸÑŸÇÿßÿ™</button>
                    <button @click="openDirectWindow('movies')" class="block w-full px-4 py-2 text-base font-bold text-white hover:bg-teal-600 transition-all duration-100 active:scale-90">ÿ£ŸÅŸÑÿßŸÖ</button>
                    <button @click="openDirectWindow('mangas')" class="block w-full px-4 py-2 text-base font-bold text-white hover:bg-teal-600 transition-all duration-100 active:scale-90">ŸÖÿßŸÜÿ∫ÿß</button>
                    <hr class="my-1 border-gray-500">
                    <!-- <button @click="openFastingWindow('episodes')" class="block w-full px-4 py-2 text-base font-bold text-white hover:bg-teal-600 transition-all duration-100 active:scale-90 disabled:opacity-50 disabled:cursor-not-allowed" disabled>(ŸÇÿ±Ÿäÿ®Ÿãÿß)</button> -->
                    <button @click="openFastingWindow('mangas')" class="block w-full px-4 py-2 text-base font-bold text-white hover:bg-teal-600 transition-all duration-100 active:scale-90">ŸÖÿßŸÜÿ∫ÿß üöÄ</button>
                    <!-- <button @click="openFastingWindow('movies')" class="block w-full px-4 py-2 text-base font-bold text-white hover:bg-teal-600 transition-all duration-100 active:scale-90 disabled:opacity-50 disabled:cursor-not-allowed" disabled>(ŸÇÿ±Ÿäÿ®Ÿãÿß)</button> -->
                </div>
            </div>

            <!-- üîç Search Button + Popup -->
            <div v-if="loadingModeResolved && !loadingFromCache" class="fixed top-4 left-4 z-50">
                <button
                    @click.stop="toggleSearch" :disabled="loading"
                    :class="isApplePlatform ? 'liquid-glass liquid-glass-round transition-transform duration-200 disabled:opacity-50 disabled:cursor-not-allowed' : 'bg-yellow-600 text-white p-2 rounded-full shadow-md transition-all duration-100 active:scale-90 disabled:opacity-50 disabled:cursor-not-allowed'"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none"
                    viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M21 21l-4.35-4.35m1.85-5.65A7 7 0 1110 4a7 7 0 018.5 7z" />
                    </svg>
                </button>

                <transition name="fade-slide">
                    <div
                    v-if="searchOpen"
                    class="relative"
                    >
                        <div
                        :class="['absolute top-2 left-0 bg-gray-800 border-2 rounded-xl shadow-2xl p-4 w-80 sm:w-96 text-gray-100', searchQuery ? 'border-orange-500' : 'border-green-600']"
                        @click.stop
                        >
                            <div class="search-notch">
                                {{ episodeCountText }}
                            </div>
                            
                            <div class="relative">
                                <textarea
                                v-model.trim="searchQuery"
                                @focus="clearJumpHighlight"
                                @keydown.enter.prevent
                                :rows="(searchFilters.title || searchFilters.story || searchFilters.summary) ? 2 : 1"
                                placeholder="ÿßÿ®ÿ≠ÿ´..."
                                class="w-full p-2 text-lg bg-gray-700 rounded focus:outline-none focus:ring-2 focus:ring-teal-400 resize-none overflow-y-auto whitespace-pre-wrap break-words"
                                ></textarea>
                                <button
                                @click="clearSearch"
                                :class="['absolute left-3 text-xl text-red-600 font-black transition-all duration-100 active:scale-90', (searchFilters.title || searchFilters.story || searchFilters.summary) ? 'top-5' : 'top-2']"
                                >
                                ‚úï
                                </button>
                            </div>

                            <fieldset class="mt-4">
                                <div class="flex justify-center mt-2 text-lg">
                                    <div class="grid grid-cols-2 gap-y-4 gap-x-4">
                                        <label class="flex items-center transition-all duration-100 active:scale-90">
                                            <input
                                                type="checkbox"
                                                v-model="searchFilters.number"
                                                class="scale-100"
                                                @change="ensureOneChecked('number')"
                                            />
                                            <span class="px-2 font-bold">ÿßŸÑÿ±ŸÇŸÖ</span>
                                        </label>

                                        <label class="flex items-center transition-all duration-100 active:scale-90">
                                            <input
                                                type="checkbox"
                                                v-model="searchFilters.title"
                                                class="scale-100"
                                                @change="ensureOneChecked('title')"
                                            />
                                            <span class="px-2 font-bold">ÿßŸÑÿπŸÜŸàÿßŸÜ</span>
                                        </label>

                                        <label class="flex items-center transition-all duration-100 active:scale-90">
                                            <input
                                                type="checkbox"
                                                v-model="searchFilters.story"
                                                class="scale-100"
                                                @change="ensureOneChecked('story')"
                                            />
                                            <span class="px-2 font-bold">ÿßŸÑŸÇÿµÿ©</span>
                                        </label>

                                        <label class="flex items-center transition-all duration-100 active:scale-90">
                                            <input
                                                type="checkbox"
                                                v-model="searchFilters.summary"
                                                class="scale-100"
                                                @change="ensureOneChecked('summary')"
                                            />
                                            <span class="px-2 font-bold">ÿßŸÑŸÖŸÑÿÆÿµ</span>
                                        </label>
                                    </div>
                                </div>
                            </fieldset>
                        </div>
                    </div>
                </transition>
            </div>

            <!-- Updated Direct Window Modal -->
            <div v-if="showDirectWindow" class="fixed z-50 inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-[100%] sm:w-[80%] md:w-[70%] lg:w-[50%] max-h-[100vh] overflow-hidden flex flex-col">
                    <div class="sticky top-0 bg-cyan-900 pt-4 pl-4 pr-4 pb-2">
                        <div class="flex justify-between items-center">
                            <h2 class="text-xl font-bold">ÿßŸÑŸÜÿßŸÅÿ∞ÿ© ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±ÿ©</h2>
                            <button @click="closeDirectWindow" class="text-red-600 hover:text-yellow-300 transition-all duration-100 active:scale-90">
                                <img :src="imageBaseUrl + 'res/close.png'" alt="Close" class="h-8 w-8" />
                            </button>                              
                        </div>
                        
                        <fieldset class="border p-2 rounded mt-2">
                            <legend class="px-2">ÿßÿÆÿ™ÿ± ŸÜŸàÿπ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ:</legend>
                            <div class="flex justify-around">
                                <label v-for="category in directWindowCategories" :key="category.key" class="flex items-center transition-all duration-100 active:scale-90">
                                    <input type="radio" v-model="selectedCategory" :value="category.key" class="ml-2" :disabled="isGlobalBusy" @change="category.handlers.resetView">
                                    {{ category.label }}
                                </label>
                            </div>
                        </fieldset>
                    </div>

                    <!-- Refactored Direct Window Content -->
                    <template v-for="category in directWindowCategories" :key="category.key">
                        <div v-if="selectedCategory === category.key" class="overflow-y-auto p-4 flex-1 always-visible-scrollbar">
                            <div v-if="category.items.length" class="mb-4">
                            <!-- Group Buttons -->
                            <div class="flex flex-wrap gap-2 mb-4 justify-center" dir="ltr">
                                <button
                                    v-for="(group, index) in category.items"
                                    :key="index"
                                    :disabled="isGlobalBusy"
                                    @click="category.handlers.groupChange(index)"
                                    :class="['px-3 py-1 rounded disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90', category.activeTabIndex === index ? 'bg-blue-500 text-white' : 'bg-gray-700']">
                                    {{ group.range }}
                                </button>
                            </div>

                            <fieldset class="border p-2 rounded">
                                <legend class="flex items-center gap-2">
                                    <span>{{ category.label }} ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©</span>
                                    <button v-if="category.selectedItem" :disabled="isGlobalBusy" @click="category.handlers.resetView" class="p-1 hover:bg-gray-700 rounded disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90">
                                        <img :src="imageBaseUrl + 'res/previous.png'" alt="ÿ±ÿ¨Ÿàÿπ" class="h-6 w-6" />
                                    </button>
                                </legend>

                                <!-- GRID VIEW -->
                                <div v-if="!category.selectedItem" class="grid grid-cols-3 gap-2" dir="ltr">
                                    <button
                                        v-for="item in category.items[category.activeTabIndex]?.items"
                                        :key="category.getGridLabel(item)"
                                        :disabled="isGlobalBusy"
                                        @click="category.handlers.selectItem(item)"
                                        :class="[category.gridButtonClass, 'disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90']">
                                        {{ category.getGridLabel(item) }}
                                    </button>
                                </div>

                                <!-- LIST VIEW -->
                                <div v-else class="flex flex-col justify-center gap-4">
                                    <!-- Navigation Controls -->
                                    <div class="flex items-center px-4">
                                        <div class="w-8 flex justify-start">
                                            <button v-if="category.navigation.showNextGroup" :disabled="isGlobalBusy" @click="category.handlers.nextGroup" class="transition-opacity disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90">
                                                <img :src="imageBaseUrl + 'res/next-tb.png'" alt="ÿßŸÑÿ™ÿßŸÑŸä" class="h-8 w-8" />
                                            </button>
                                            <button v-if="!category.navigation.showNextGroup" :disabled="!category.navigation.hasNext || isGlobalBusy" @click="category.handlers.nextItem" class="transition-opacity disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90">
                                                <img :src="imageBaseUrl + 'res/next.png'" alt="ÿßŸÑÿ™ÿßŸÑŸä" class="h-8 w-8" />
                                            </button>
                                        </div>
                                        <div class="flex-grow text-center">
                                            <button
                                                v-if="category.key !== 'mangas'"
                                                :disabled="isGlobalBusy"
                                                @click="category.handlers.openModal"
                                                class="text-lg font-bold underline text-yellow-300 bg-transparent border-0 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90">
                                                {{ category.getListTitle() }}
                                            </button>
                                            <span v-else class="text-lg font-bold">{{ category.getListTitle() }}</span>
                                        </div>
                                        <div class="w-8 flex justify-end">
                                            <button v-if="category.navigation.showPrevGroup" :disabled="isGlobalBusy" @click="category.handlers.prevGroup" class="transition-opacity disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90">
                                                <img :src="imageBaseUrl + 'res/previous-tb.png'" alt="ÿßŸÑÿ≥ÿßÿ®ŸÇ" class="h-8 w-8" />
                                            </button>
                                            <button v-if="!category.navigation.showPrevGroup" :disabled="!category.navigation.hasPrev || isGlobalBusy" @click="category.handlers.prevItem" class="transition-opacity disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90">
                                                <img :src="imageBaseUrl + 'res/previous.png'" alt="ÿßŸÑÿ≥ÿßÿ®ŸÇ" class="h-8 w-8" />
                                            </button>
                                        </div>
                                    </div>

                                    <!-- CONTENT LIST -->
                                    <div v-if="category.key !== 'mangas'" class="flex flex-col gap-4">
                                        <div v-for="group in category.listData" :key="group.key" class="relative">
                                            <!-- Condition for flat list (no metadata) -->
                                            <template v-if="!group.EpisodeCategory && !group.EpisodeTranslator && !group.EpisodeRemastered && !group.hasMetadata">
                                                <div v-for="video in group.videos" :key="video.VideoID" class="relative mb-2">
                                                    <div class="relative w-full">
                                                        <button
                                                            :disabled="['success', 'ratelimiting', 'sending'].includes(video.status)"
                                                            @click="sendEpisodeToBot(video.VideoID, video.Resolution, video.Size, video.originalIndex, video.IntroductionTime, video.StartStoryTime, video.EpisodeSuspenseTime, video.StartSongTime, video.ChapterOneTime, video.ChapterTwoTime, video.EndSongTime, video.ChapterThreeTime, video.NextEpisodeTeaserTime, video.NextEpisodeHintTime)"
                                                            :class="[category.actionButtonClass, 'w-full flex items-center justify-center shadow-md disabled:opacity-50 transition-all duration-100 active:scale-90 disabled:cursor-not-allowed relative overflow-hidden']">
                                                            <span v-if="video.status === 'ratelimiting'">{{ video.Resolution }} ({{ formatFileSize(video.Size) }})</span>
                                                            <span v-else-if="video.countdown !== undefined">{{ video.countdown }}</span>
                                                            <span v-else>{{ video.Resolution }} ({{ formatFileSize(video.Size) }})</span>
                                                        </button>
                                                        <img v-if="video.status === 'success'" :src="imageBaseUrl + 'res/true.png'" class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none" />
                                                        <img v-else-if="video.status === 'error'" :src="imageBaseUrl + 'res/close.png'" class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none" />
                                                        <div v-if="video.status === 'sending'" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded z-20">
                                                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </template>
                                            <!-- Condition for grouped list (metadata) -->
                                            <fieldset v-else class="rounded relative border p-2 mb-4">
                                                <legend class="px-1 text-sm">
                                                    <span v-if="group.EpisodeCategory">
                                                        {{ group.EpisodeCategory === 'S' ? 'ŸÖÿ™ÿ±ÿ¨ŸÖ' : (group.EpisodeCategory === 'D' ? 'ŸÖÿØÿ®ŸÑÿ¨' : group.EpisodeCategory) }}
                                                    </span>
                                                    <span v-if="group.EpisodeTranslator">
                                                        <span v-if="group.EpisodeCategory"> - </span>{{ group.EpisodeTranslator }}<span v-if="isProfessionalTranslator(group.EpisodeTranslator)" v-tippy="'ÿ™ÿ±ÿ¨ŸÖÿ© ÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ©'"> ‚≠ê</span>
                                                    </span>
                                                    <span v-if="group.EpisodeRemastered">
                                                        <span v-if="group.EpisodeCategory || group.EpisodeTranslator"> - </span>
                                                        {{ group.EpisodeRemastered === 'TP' ? 'ŸÖÿ≠ÿ≥ŸÜÿ© ŸàÿÆÿßÿµÿ©' : (group.EpisodeRemastered === 'FP' ? 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿ≥ŸÜÿ© ŸàÿÆÿßÿµÿ©' : (group.EpisodeRemastered === 'P' ? 'ÿ≠ŸÑŸÇÿ© ÿÆÿßÿµÿ©' : (group.EpisodeRemastered === 'T' ? 'ŸÖÿ≠ÿ≥ŸÜÿ©' : (group.EpisodeRemastered === 'F' ? 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿ≥ŸÜÿ©' : group.EpisodeRemastered)))) }}
                                                    </span>
                                                </legend>
                                                <div class="grid grid-cols-1 gap-2 mt-2">
                                                    <div v-for="video in group.videos" :key="video.VideoID" class="relative">
                                                        <div class="relative w-full">
                                                            <button
                                                                :disabled="['success', 'ratelimiting', 'sending'].includes(video.status)"
                                                                @click="sendEpisodeToBot(video.VideoID, video.Resolution, video.Size, video.originalIndex, video.IntroductionTime, video.StartStoryTime, video.EpisodeSuspenseTime, video.StartSongTime, video.ChapterOneTime, video.ChapterTwoTime, video.EndSongTime, video.ChapterThreeTime, video.NextEpisodeTeaserTime, video.NextEpisodeHintTime)"
                                                                :class="[category.actionButtonClass, 'w-full flex items-center justify-center shadow-md disabled:opacity-50 transition-all duration-100 active:scale-90 disabled:cursor-not-allowed relative overflow-hidden']">
                                                                <span v-if="video.status === 'ratelimiting'">{{ video.Resolution }} ({{ formatFileSize(video.Size) }})</span>
                                                                <span v-else-if="video.countdown !== undefined">{{ video.countdown }}</span>
                                                                <span v-else>{{ video.Resolution }} ({{ formatFileSize(video.Size) }})</span>
                                                            </button>
                                                            <img v-if="video.status === 'success'" :src="imageBaseUrl + 'res/true.png'" class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none" />
                                                            <img v-else-if="video.status === 'error'" :src="imageBaseUrl + 'res/close.png'" class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none" />
                                                            <div v-if="video.status === 'sending'" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded z-20">
                                                                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </fieldset>
                                        </div>
                                    </div>

                                    <!-- MANGAS -->
                                    <div v-else class="relative flex flex-col gap-4">
                                        <div class="relative w-full">
                                            <button
                                                :disabled="['success', 'ratelimiting', 'sending'].includes(category.selectedItem.status)"
                                                @click="sendMangaWrapper(category.selectedItem.MangaFileID, category.selectedItem.MangaNumber, 0, true)"
                                                :class="[category.actionButtonClass, 'w-full flex items-center justify-center shadow-md disabled:opacity-50 transition-all duration-100 active:scale-90 disabled:cursor-not-allowed']" dir="ltr">
                                                <span v-if="category.selectedItem.status === 'ratelimiting'">{{ formatFileSize(category.selectedItem.MangaFileSize) }}</span>
                                                <span v-else-if="category.selectedItem.countdown !== undefined">{{ category.selectedItem.countdown }}</span>
                                                <span v-else>{{ formatFileSize(category.selectedItem.MangaFileSize) }}</span>
                                            </button>
                                            <img v-if="category.selectedItem.status === 'success'" :src="imageBaseUrl + 'res/true.png'" class="absolute right-0 top-0 w-6 h-6 ml-2" />
                                            <img v-else-if="category.selectedItem.status === 'error'" :src="imageBaseUrl + 'res/close.png'" class="absolute right-0 top-0 w-6 h-6 ml-2" />
                                            <div v-if="category.selectedItem.status === 'sending'" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded">
                                                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </fieldset>
                        </div>
                    </div>
                    </template>
                </div>    
            </div>

            <!-- ÿßŸÑŸÜÿßŸÅÿ∞ÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ© Modal -->
            <div v-if="showFastingWindow" class="fixed z-50 inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-[100%] sm:w-[80%] md:w-[70%] lg:w-[50%] max-h-[100vh] overflow-hidden flex flex-col">
                    <div class="sticky top-0 bg-cyan-900 pt-4 pl-4 pr-4 pb-2">
                        <div class="flex justify-between items-center">
                            <h2 class="text-xl font-bold">ÿßŸÑŸÜÿßŸÅÿ∞ÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ© <span class="text-xs text-yellow-300 font-normal">(ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä)</span></h2>
                            <button 
                                v-if="!isMangaQueueRunning" 
                                @click="closeFastingWindow" 
                                class="text-red-600 hover:text-yellow-300 transition-all duration-100 active:scale-90">
                                <img src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/close.png" alt="Close" class="h-8 w-8" />
                            </button>                              
                        </div>
                        
                        <fieldset class="border p-2 rounded mt-2">
                            <legend class="px-2">ÿßÿÆÿ™ÿ± ŸÜŸàÿπ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ:</legend>
                            <div class="flex justify-around">
                                <!-- <label class="flex items-center transition-all duration-100 active:scale-90">
                                    <input type="radio" v-model="selectedCategory" value="episodes" class="ml-2" disabled>
                                    ÿ≠ŸÑŸÇÿßÿ™
                                </label> -->
                                <!-- <label class="flex items-center transition-all duration-100 active:scale-90">
                                    <input type="radio" v-model="selectedCategory" value="movies" class="ml-2" disabled>
                                    ÿ£ŸÅŸÑÿßŸÖ
                                </label> -->
                                <label class="flex items-center transition-all duration-100 active:scale-90">
                                    <input type="radio" v-model="selectedCategory" value="mangas" class="ml-2" :disabled="isMangaQueueRunning">
                                    ŸÖÿßŸÜÿ∫ÿß
                                </label>
                            </div>
                        </fieldset>
                    </div>

                    <!-- Manga Bulk Send Content -->
                    <div v-if="selectedCategory === 'mangas'" class="overflow-y-auto p-4 flex-1 always-visible-scrollbar">
                        <!-- Daily Limit Status -->
                        <div class="pt-2 mb-4">
                            <div class="bg-slate-800 rounded p-2 text-sm flex flex-col gap-1 border border-cyan-700">
                                <div class="flex justify-between items-center">
                                    <span>ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑÿßÿ™ ÿßŸÑŸäŸàŸÖŸäÿ©:</span>
                                    <span v-if="dailyReady" :class="{'text-green-400': effectiveRemainingDownloads > 20, 'text-yellow-400': effectiveRemainingDownloads <= 20 && effectiveRemainingDownloads > 0, 'text-red-500': effectiveRemainingDownloads === 0}">
                                        <span v-if="pendingDailyIncrements > 0" class="text-cyan-300 text-xs inline-flex items-center gap-1">{{ pendingDailyIncrements }}+</span>
                                        {{ dailyDownloads }} / {{ safeMaxDailyDownloads }}
                                    </span>
                                    <span v-else class="text-slate-300 text-xs">ÿ¨ÿßÿ±Ÿç ÿßŸÑŸÖÿ≤ÿßŸÖŸÜÿ©...</span>
                                </div>
                                <div class="w-full bg-slate-700 rounded-full h-2.5 dark:bg-slate-700 mt-1">
                                    <div class="bg-cyan-600 h-2.5 rounded-full transition-all duration-500" :style="{ width: (effectiveDailyDownloads / safeMaxDailyDownloads * 100) + '%' }"></div>
                                </div>
                                <div class="flex justify-between items-center mt-1 text-xs text-slate-400">
                                    <span>
                                        ÿßŸÑŸÖÿ™ÿ®ŸÇŸä:
                                        <span v-if="!dailyReady" class="text-slate-300 text-xs">ÿ¨ÿßÿ±Ÿç ÿßŸÑŸÖÿ≤ÿßŸÖŸÜÿ©...</span>
                                        <span v-else>
                                            {{ effectiveRemainingDownloads }}
                                            <span v-if="pendingDailyIncrements > 0 && (safeMaxDailyDownloads - dailyDownloads) > 0" class="text-cyan-300 text-xs inline-flex items-center gap-1">{{ Math.min(pendingDailyIncrements, (safeMaxDailyDownloads - dailyDownloads)) }}-</span>
                                        </span>
                                    </span>
                                    <span>üîÑÔ∏è {{ timeUntilReset }}</span>
                                </div>
                            </div>
                        </div>

                        <div v-if="!isMangaQueueRunning && mangaQueueStats.total === 0" class="space-y-4">
                            <div class="flex gap-4 items-center">
                                <div class="flex-1">
                                    <label class="block mb-2 text-sm">ŸÖŸÜ ÿßŸÑŸÅÿµŸÑ:</label>
                                    <input
                                        v-model="mangaStartNumberModel"
                                        type="text"
                                        inputmode="numeric"
                                        pattern="[0-9Ÿ†-Ÿ©€∞-€π]*"
                                        class="w-full p-2 bg-gray-700 rounded text-white"
                                        :placeholder="`${minMangaNumber}`"
                                        dir="ltr"
                                    />
                                </div>
                                <div class="flex-1">
                                    <label class="block mb-2 text-sm">ÿ•ŸÑŸâ ÿßŸÑŸÅÿµŸÑ:</label>
                                    <input
                                        v-model="mangaEndNumberModel"
                                        type="text"
                                        inputmode="numeric"
                                        pattern="[0-9Ÿ†-Ÿ©€∞-€π]*"
                                        class="w-full p-2 bg-gray-700 rounded text-white"
                                        :placeholder="`${maxMangaNumber}`"
                                        dir="ltr"
                                    />
                                </div>
                            </div>
                            <button 
                                @click="startMangaQueue" 
                                :disabled="mangaStartNumber === null || mangaStartNumber === undefined || mangaEndNumber === null || mangaEndNumber === undefined || mangaStartNumber > mangaEndNumber || mangaStartNumber < minMangaNumber || mangaEndNumber > maxMangaNumber || isRetryAllFailedRunning"
                                class="w-full bg-green-500 text-white px-6 py-3 rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90 font-bold">
                                ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿßŸÜÿ∫ÿß ({{ (mangaStartNumber !== null && mangaStartNumber !== undefined && mangaEndNumber !== null && mangaEndNumber !== undefined && mangaStartNumber <= mangaEndNumber && mangaStartNumber >= minMangaNumber && mangaEndNumber <= maxMangaNumber) ? (mangaEndNumber - mangaStartNumber + 1) : 0 }})
                            </button>
                        </div>

                        <!-- Queue Progress Display -->
                        <div v-if="isMangaQueueRunning || mangaQueueStats.total > 0" class="space-y-4 mt-4">
                            <!-- Current Chapter Status (only current, not full list) -->
                            <div v-if="mangaQueueCurrent && mangaQueueCurrent.chapter !== null" class="bg-gray-800 p-3 rounded flex items-center justify-center">
                                <div class="flex items-center gap-3" dir="ltr">
                                    <span class="text-lg font-bold text-yellow-300">{{ mangaQueueCurrent.chapter }}</span>
                                    <span v-if="mangaQueueCurrent.status === 'sending'" class="inline-flex items-center">
                                        <span class="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></span>
                                    </span>
                                    <span v-else-if="mangaQueueCurrent.status === 'success'" class="text-green-400 text-lg">‚úÖ</span>
                                    <span v-else-if="mangaQueueCurrent.status === 'failed'" class="text-red-400 text-lg">‚ùå</span>
                                </div>
                            </div>

                            <!-- Progress Bar -->
                            <div class="w-full">
                                <div class="flex justify-between mb-2 text-sm">
                                    <span>ÿßŸÑÿ™ŸÇÿØŸÖ</span>
                                    <span>{{ mangaQueueProgress }}%</span>
                                </div>
                                <div class="w-full bg-gray-700 rounded-full h-6 overflow-hidden">
                                    <div 
                                        class="h-6 transition-all duration-300 rounded-full"
                                        :class="{
                                            'bg-green-500': mangaQueueProgress >= 100,
                                            'bg-blue-500': mangaQueueProgress >= 50 && mangaQueueProgress < 100,
                                            'bg-yellow-500': mangaQueueProgress >= 25 && mangaQueueProgress < 50,
                                            'bg-red-500': mangaQueueProgress < 25
                                        }"
                                        :style="{ width: mangaQueueProgress + '%' }"
                                    ></div>
                                </div>
                            </div>

                            <!-- Statistics -->
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div class="bg-gray-800 p-3 rounded">
                                    <div class="text-gray-400">ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖÿßŸÜÿ∫ÿß</div>
                                    <div class="text-xl font-bold">{{ mangaQueueStats.total }}</div>
                                </div>
                                <div class="bg-gray-800 p-3 rounded">
                                    <div class="text-gray-400">ÿ™ŸÖ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ</div>
                                    <div class="text-xl font-bold text-green-400">
                                        <button
                                            v-if="mangaQueueStats.sent > 0"
                                            @click="showMangaSentLogModal = true"
                                            class="underline underline-offset-4 hover:text-green-300 transition-all duration-100 active:scale-90"
                                        >
                                            {{ mangaQueueStats.sent }}
                                        </button>
                                        <span v-else>{{ mangaQueueStats.sent }}</span>
                                    </div>
                                </div>
                                <div class="bg-gray-800 p-3 rounded">
                                    <div class="text-gray-400">ŸÅŸä ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±</div>
                                    <div class="text-xl font-bold text-yellow-400">{{ mangaQueueStats.waiting }}</div>
                                </div>
                                <div class="bg-gray-800 p-3 rounded">
                                    <div class="text-gray-400">ŸÅÿ¥ŸÑ</div>
                                    <div class="text-xl font-bold text-red-400">
                                        <button
                                            v-if="mangaQueueStats.failed > 0"
                                            @click="showMangaFailedLogModal = true"
                                            class="underline underline-offset-4 hover:text-red-300 transition-all duration-100 active:scale-90"
                                        >
                                            {{ mangaQueueStats.failed }}
                                        </button>
                                        <span v-else>{{ mangaQueueStats.failed }}</span>
                                    </div>
                                </div>
                                <div class="bg-gray-800 p-3 rounded">
                                    <div class="text-gray-400">ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ∫ÿ±ŸÇ</div>
                                    <div class="text-xl font-bold">{{ formatTime(mangaQueueStats.elapsedTime) }}</div>
                                </div>
                                <div class="bg-gray-800 p-3 rounded">
                                    <div class="text-gray-400">ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä</div>
                                    <div class="text-xl font-bold">{{ formatTime(mangaQueueStats.remainingTime) }}</div>
                                </div>
                            </div>

                            <!-- Control Buttons -->
                            <div v-if="isMangaQueueRunning" class="flex gap-4">
                                <button 
                                    @click="toggleMangaQueuePause" 
                                    :disabled="isMangaQueuePauseRequested"
                                    class="flex-1 bg-yellow-500 text-black px-6 py-3 rounded hover:bg-yellow-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90 font-bold">
                                    {{ isMangaQueuePauseRequested ? 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ•ŸäŸÇÿßŸÅ...' : (isMangaQueuePaused ? 'ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ' : 'ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™') }}
                                </button>
                                <button 
                                    @click="showStopConfirmation = true" 
                                    class="flex-1 bg-red-500 text-white px-6 py-3 rounded hover:bg-red-600 transition-all duration-100 active:scale-90 font-bold">
                                    ÿ•ŸäŸÇÿßŸÅ
                                </button>
                            </div>

                            <!-- Finished Button -->
                            <div v-if="!isMangaQueueRunning && mangaQueueStats.total > 0" class="flex gap-4 mt-4">
                                <button 
                                    @click="resetMangaQueue" 
                                    :disabled="isAnyMangaQueueRunning"
                                    class="w-full bg-green-500 text-white px-6 py-3 rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90 font-bold">
                                    ÿ•ÿ±ÿ≥ÿßŸÑ ÿ¨ÿØŸäÿØ
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Stop Confirmation Modal -->
            <div v-if="showStopConfirmation" class="fixed z-[75] inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-4/5 md:w-2/3 lg:w-1/2 max-h-[95vh] overflow-hidden flex flex-col text-center p-6">
                    <h3 class="text-xl mb-4">ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ•ŸäŸÇÿßŸÅ</h3>
                    <p class="mb-6">ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ŸäŸÇÿßŸÅ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑÿü</p>
                    <div class="flex gap-4">
                        <button 
                            @click="stopMangaQueue" 
                            class="flex-1 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 transition-all duration-100 active:scale-90">
                            ŸÜÿπŸÖ
                        </button>
                        <button 
                            @click="showStopConfirmation = false" 
                            class="flex-1 bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 transition-all duration-100 active:scale-90">
                            ŸÑÿß
                        </button>
                    </div>
                </div>
            </div>

            <!-- Retry Stop Confirmation Modal -->
            <div v-if="showRetryStopConfirmation" class="fixed z-[75] inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-4/5 md:w-2/3 lg:w-1/2 max-h-[95vh] overflow-hidden flex flex-col text-center p-6">
                    <h3 class="text-xl mb-4">ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ•ÿ∫ŸÑÿßŸÇ</h3>
                    <p class="mb-6">ŸáŸÜÿßŸÉ ÿπŸÖŸÑŸäÿßÿ™ ÿ¨ÿßÿ±Ÿäÿ©. ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ•ŸäŸÇÿßŸÅŸáÿß Ÿàÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑŸÜÿßŸÅÿ∞ÿ©ÿü</p>
                    <div class="flex gap-4">
                        <button 
                            @click="confirmStopAndCloseFailedModal" 
                            class="flex-1 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 transition-all duration-100 active:scale-90">
                            ŸÜÿπŸÖ
                        </button>
                        <button 
                            @click="showRetryStopConfirmation = false" 
                            class="flex-1 bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 transition-all duration-100 active:scale-90">
                            ŸÑÿß
                        </button>
                    </div>
                </div>
            </div>

            <div v-if="showSendInProgressConfirmation" class="fixed z-[95] inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-4/5 md:w-2/3 lg:w-1/2 max-h-[95vh] overflow-hidden flex flex-col text-center p-6">
                    <h3 class="text-xl mb-4">ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ•ŸäŸÇÿßŸÅ</h3>
                    <p class="mb-6">ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ŸÇŸäÿØ ÿßŸÑÿ™ŸÜŸÅŸäÿ∞ÿå ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ•ŸäŸÇÿßŸÅŸáÿß</p>
                    <div class="flex gap-4">
                        <button @click="confirmCancelSend" class="flex-1 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 transition-all duration-100 active:scale-90">
                            ŸÜÿπŸÖ
                        </button>
                        <button @click="cancelSendInProgressClose" class="flex-1 bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 transition-all duration-100 active:scale-90">
                            ŸÑÿß
                        </button>
                    </div>
                </div>
            </div>

            <div v-if="showCaptureInProgressConfirmation" data-capture-allow="1" class="fixed z-[95] inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-4/5 md:w-2/3 lg:w-1/2 max-h-[95vh] overflow-hidden flex flex-col text-center p-6">
                    <h3 class="text-xl mb-4">ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ•ŸäŸÇÿßŸÅ</h3>
                    <p class="mb-6">ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ™ÿµŸàŸäÿ± ŸÇŸäÿØ ÿßŸÑÿ™ŸÜŸÅŸäÿ∞ÿå ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ•ŸäŸÇÿßŸÅŸáÿß</p>
                    <div class="flex gap-4">
                        <button @click="confirmCancelCapture" class="flex-1 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 transition-all duration-100 active:scale-90">
                            ŸÜÿπŸÖ
                        </button>
                        <button @click="cancelCaptureInProgressClose" class="flex-1 bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 transition-all duration-100 active:scale-90">
                            ŸÑÿß
                        </button>
                    </div>
                </div>
            </div>

            <!-- Limit Reached Modal -->
            <div v-if="showLimitModal" class="fixed z-[80] inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-4/5 md:w-2/3 lg:w-1/2 max-h-[95vh] overflow-hidden flex flex-col text-center p-6">
                    <h3 class="text-xl mb-4 text-red-400">ÿπÿ∞ÿ±Ÿãÿß</h3>
                    <p v-if="remainingDownloads === 0" class="mb-6 text-lg">
                        ÿ™ŸÖ ÿßÿ≥ÿ™ŸáŸÑÿßŸÉ ÿßŸÑÿ≠ÿØŸë ÿßŸÑŸäŸàŸÖŸäÿå Ÿàÿ≥ŸäŸèÿπÿßÿØ ÿßŸÑÿ™ÿπŸäŸäŸÜ ÿÆŸÑÿßŸÑ
                        <span class="text-yellow-300 font-bold text-xl">{{ timeUntilReset }}</span>
                    </p>
                    <p v-else class="mb-6 text-lg">
                        ŸÖÿ™ÿ®ŸÇŸä ŸÑÿØŸäŸÉ 
                        <span v-if="remainingDownloads > 2" class="text-yellow-300 font-bold text-xl">{{ remainingDownloads }}</span>
                        {{ remainingDownloadsLabel }} ŸÑŸáÿ∞ÿß ÿßŸÑŸäŸàŸÖ.
                    </p>
                    <button
                        @click="showLimitModal = false" 
                        class="bg-gray-500 text-white px-6 py-2 rounded hover:bg-gray-600 transition-all duration-100 active:scale-90">
                        ÿ≠ÿ≥ŸÜŸãÿß
                    </button>
                </div>
            </div>

            <!-- Manga Sent Log Modal -->
            <div v-if="showMangaSentLogModal" class="fixed z-[70] inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-11/12 md:w-2/3 lg:w-1/2 max-h-[85vh] overflow-hidden flex flex-col">
                    <div class="sticky top-0 bg-cyan-900 p-4 flex justify-between items-center border-b border-cyan-700">
                        <div class="text-lg">ÿ≥ÿ¨ŸÑ ÿßŸÑŸÖŸèÿ±ÿ≥ŸÑ ({{ mangaSentLog.length }})</div>
                        <button @click="showMangaSentLogModal = false" class="text-red-600 hover:text-yellow-300 transition-all duration-100 active:scale-90">
                            <span class="text-2xl font-black">‚úï</span>
                        </button>
                    </div>
                    <div class="p-4 overflow-y-auto flex-1 always-visible-scrollbar">
                        <div v-if="!mangaSentLog.length" class="text-center text-gray-200">
                            ŸÑÿß ŸäŸàÿ¨ÿØ ŸÅÿµŸàŸÑ ŸÖÿ±ÿ≥ŸÑÿ© ÿ®ÿπÿØ.
                        </div>
                        <div v-else class="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2" dir="ltr">
                            <button
                                v-for="entry in sortedMangaSentLog"
                                :key="entry.chapter"
                                class="bg-gray-800 text-yellow-300 px-2 py-1 rounded underline underline-offset-4 hover:bg-gray-700 transition-all duration-100 active:scale-90"
                            >
                                {{ entry.chapter }}
                            </button>
                        </div>
                    </div>    
                </div>
            </div>

            <!-- Tab Lock Modal -->
            <div 
                v-if="tabLockModal" 
                class="fixed inset-0 z-[130] bg-black/80 backdrop-blur-sm flex items-center justify-center"
            >
                <div class="bg-gray-900 text-yellow-200 rounded-lg p-6 shadow-2xl w-11/12 max-w-md text-center space-y-4">
                    <div class="text-xl text-red-500 -m-3 font-bold">
                        ÿπÿ∞ÿ±Ÿãÿßÿå ÿßŸÑÿØŸÑŸäŸÑ ŸÖŸÅÿ™Ÿàÿ≠ ŸÅŸä ÿ™ÿ®ŸàŸäÿ® ÿ¢ÿÆÿ±
                    </div>
                    <div class="text-base">
                        Ÿäÿ≥ŸÖÿ≠ ÿßŸÑÿØŸÑŸäŸÑ ÿ®ÿ™ÿ®ŸàŸäÿ® Ÿàÿßÿ≠ÿØ ŸÅŸÇÿ∑ ŸÑÿ™ÿ¨ŸÜÿ® ÿ™ÿπÿßÿ±ÿ∂ ÿßŸÑŸÖÿ≤ÿßŸÖŸÜÿ©.
                    </div>
                </div>        
            </div>

            <!-- Manga Failed Log Modal -->
            <div v-if="showMangaFailedLogModal" class="fixed z-[70] inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-11/12 md:w-5/6 lg:w-2/3 max-h-[85vh] overflow-hidden flex flex-col">
                    <div class="sticky top-0 bg-cyan-900 p-4 flex justify-between items-center border-b border-cyan-700">
                        <div class="text-lg">ÿ≥ÿ¨ŸÑ ÿßŸÑŸÅÿ¥ŸÑ ({{ mangaFailedLog.length }})</div>
                        <button @click="closeMangaFailedLogModal" class="text-red-600 hover:text-yellow-300 transition-all duration-100 active:scale-90">
                            <span class="text-2xl font-black">‚úï</span>
                        </button>
                    </div>
                    <div class="p-4 overflow-y-auto flex-1 always-visible-scrollbar space-y-3">
                        <!-- Current Retry Status -->
                        <div v-if="retryQueueCurrent && retryQueueCurrent.chapter !== null" class="bg-gray-800 p-3 rounded flex items-center justify-center">
                            <div class="flex items-center gap-3" dir="ltr">
                                <span class="text-lg font-bold text-yellow-300">{{ retryQueueCurrent.chapter }}</span>
                                <span v-if="retryQueueCurrent.status === 'sending'" class="inline-flex items-center">
                                    <span class="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></span>
                                </span>
                                <span v-else-if="retryQueueCurrent.status === 'success'" class="text-green-400 text-lg">‚úÖ</span>
                                <span v-else-if="retryQueueCurrent.status === 'failed'" class="text-red-400 text-lg">‚ùå</span>
                            </div>
                        </div>

                        <div v-if="!allFailedMangaRowsSucceeded" class="flex gap-3 items-center justify-center flex-wrap">
                            <button
                                @click="retryAllFailedMangas"
                                :disabled="checkAnyRetryRunning() || !mangaFailedLog.some(e => e.status !== 'success') || (isMangaQueueRunning && !isMangaQueuePaused)"
                                class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 disabled:opacity-80 disabled:cursor-not-allowed transition-all duration-100 active:scale-90"
                            >
                                <span v-if="isRetryAllFailedRunning" class="inline-flex items-center gap-2">
                                    <span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></span>
                                    ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ({{ retryAllFailedProgress.done }}/{{ retryAllFailedProgress.total }})
                                </span>
                                <span v-else>ÿ•ÿπÿßÿØÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÉŸÑ</span>
                            </button>

                            <!-- Queue Controls -->
                             <button
                                @click="startFailedQueue"
                                :disabled="checkAnyRetryRunning() || failedMangaQueue.length === 0"
                                class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-80 disabled:cursor-not-allowed transition-all duration-100 active:scale-90"
                            >
                                <span v-if="isRetryQueueRunning" class="inline-flex items-center gap-2">
                                    <span v-if="!isRetryQueuePaused" class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></span>
                                    {{ isRetryQueuePaused ? 'ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ŸÖŸàŸÇŸÅÿ© ŸÖŸàŸÇÿ™Ÿãÿß' : 'ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©' }} ({{ failedQueueStats.sent + failedQueueStats.failed }}/{{ failedQueueStats.total }})
                                </span>
                                <span v-else>ÿ®ÿØÿ° ÿßŸÑÿ∑ÿßÿ®Ÿàÿ±</span>
                            </button>

                            <button 
                                v-if="isRetryQueueRunning || isRetryQueuePaused"
                                @click="toggleRetryQueuePause" 
                                :disabled="isRetryQueuePauseRequested"
                                class="bg-yellow-500 text-black px-4 py-2 rounded hover:bg-yellow-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90 font-bold">
                                {{ isRetryQueuePauseRequested ? 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ•ŸäŸÇÿßŸÅ...' : (isRetryQueuePaused ? 'ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ ÿßŸÑÿ∑ÿßÿ®Ÿàÿ±' : 'ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™ ŸÑŸÑÿ∑ÿßÿ®Ÿàÿ±') }}
                            </button>

                            <button 
                                v-if="isRetryQueueRunning || isRetryQueuePaused"
                                @click="cancelRetryQueue" 
                                class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 transition-all duration-100 active:scale-90 font-bold">
                                ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ÿßÿ®Ÿàÿ±
                            </button>
                        </div>

                        <div v-if="!mangaFailedLog.length" class="text-center text-gray-200">
                            ŸÑÿß ŸäŸàÿ¨ÿØ ŸÅÿµŸàŸÑ ŸÅÿßÿ¥ŸÑÿ©.
                        </div>

                        <div v-else class="overflow-x-auto">
                            <table class="w-full border border-cyan-700 rounded">
                                <thead class="bg-cyan-800">
                                    <tr>
                                        <th class="p-2 border border-cyan-700 w-24">ÿßŸÑŸÅÿµŸÑ</th>
                                        <th v-if="!allFailedMangaRowsSucceeded" class="p-2 border border-cyan-700">ÿßŸÑÿÆÿ∑ÿ£</th>
                                        <th class="p-2 border border-cyan-700 w-36">ÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="entry in mangaFailedLog" :key="entry.chapter" class="bg-gray-800">
                                        <td class="p-2 border border-cyan-700 text-center text-yellow-300" dir="ltr">
                                            <span class="font-bold">{{ entry.chapter }}</span>
                                        </td>
                                        <td v-if="!allFailedMangaRowsSucceeded" class="p-2 border border-cyan-700 align-top">
                                            <div class="text-xs text-gray-100 whitespace-pre-wrap break-words max-h-28 overflow-y-auto" dir="ltr">
                                                {{ entry.error }}
                                            </div>
                                        </td>
                                        <td class="p-2 border border-cyan-700 text-center">
                                            <span v-if="entry.status === 'success'" class="text-green-400 text-xl">‚úÖ</span>
                                            <div v-else class="flex flex-col gap-2">
                                                <button
                                                    @click="retryFailedMangaWrapped(entry)"
                                                    :disabled="entry.status === 'retrying' || checkAnyRetryRunning() || (isMangaQueueRunning && !isMangaQueuePaused)"
                                                    class="bg-blue-500 text-white px-3 py-2 rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90"
                                                >
                                                    <span v-if="entry.status === 'retrying'" class="inline-flex items-center gap-2">
                                                        <span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></span>
                                                    </span>
                                                    <span v-else>ÿ•ÿπÿßÿØÿ©</span>
                                                </button>
                                                
                                                <button
                                                    @click="toggleFailedQueue(entry)"
                                                    :disabled="isRetryQueueRunning || isRetryAllFailedRunning"
                                                    class="px-3 py-2 rounded transition-all duration-100 active:scale-90 text-sm font-bold"
                                                    :class="getQueueRank(entry) > 0 ? 'bg-purple-600 hover:bg-purple-700 text-white' : 'bg-gray-600 hover:bg-gray-500 text-gray-200'"
                                                >
                                                    {{ getQueueRank(entry) > 0 ? 'ÿ±.ÿ∑: ' + getQueueRank(entry) : 'ÿ∑ÿßÿ®Ÿàÿ±' }}
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Error Message with Retry Button -->
        <div v-if="error" class="text-center text-xl mb-4 text-red-500 font-bold py-4">
            <p class="mb-4">{{ error }}</p>
            <button 
            @click="reloadPage" 
            :disabled="waitTime > 0" 
            class="bg-blue-500 text-white font-bold py-2 px-4 rounded transition-all duration-100 active:scale-90"
            :class="{'opacity-50 cursor-not-allowed': waitTime > 0, 'hover:bg-blue-700': waitTime === 0}">
            ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ
        </button>    
        </div>

        <h1 
            v-if="loadingModeResolved && !loadingFromCache"
            class="text-5xl font-bold mt-10 mb-4 text-center">
            <span>ÿßŸÑÿØŸÑŸäŸÑ ÿßŸÑÿ¥ÿßŸÖŸÑ ŸÑŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑŸÖÿ≠ŸÇŸÇ ŸÉŸàŸÜÿßŸÜ</span>
        </h1>
        <div v-if="loading" class="flex items-center justify-center w-full">
            <div v-if="loadingFromCache" class="fixed inset-0 flex items-center justify-center z-50">
                <div class="mt-4 text-center text-white text-sm font-semibold tracking-wider">
                    <span class="inline-flex items-center gap-2">
                        <span class="animate-spin inline-block h-12 w-12 rounded-full border-2 border-white/30 border-t-white"></span>
                    </span>
                </div>
            </div>
            <div v-else-if="loadingModeResolved" class="flex flex-col items-center" style="position: relative; top: 0;">
                <transition name="fade">
                    <span key="zikr" class="zikr-box">{{ currentZikr }}</span>
                </transition>
                <div class="w-[18rem]">
                    <div class="relative h-10 rounded-full overflow-hidden bg-gray-700 shadow-inner ring-2 ring-gray-600">
                        <div class="absolute top-0 left-0 h-full w-full bg-gradient-to-r from-blue-700 via-teal-500 to-emerald-500 animate-gradient-x"></div>
                        <div class="absolute top-0 left-0 h-full w-full opacity-30 bg-[length:20px_20px] bg-[linear-gradient(45deg,rgba(255,255,255,.15)_25%,transparent_25%,transparent_50%,rgba(255,255,255,.15)_50%,rgba(255,255,255,.15)_75%,transparent_75%,transparent)] animate-stripes"></div>
                        <div class="absolute top-0 right-0 h-full bg-gray-800 transition-all duration-300 ease-out" :style="{ width: (100 - loadProgress) + '%' }"></div>
                        <div class="absolute top-0 left-0 h-full w-full flex items-center justify-center">
                            <span class="text-xs font-bold text-white shadow-black drop-shadow-md">{{ loadProgress }}%</span>
                        </div>
                    </div>
                    <div class="mt-4 text-center text-white text-sm font-semibold tracking-wider animate-pulse">
                        <span class="inline-flex items-center gap-2">
                            <span>ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™...</span>
                            <!-- <span class="animate-spin inline-block h-5 w-5 rounded-full border-2 border-black/30 border-t-black"></span> -->
                        </span>
                    </div>
                </div>
            </div>
        </div>
        <!-- <br>

        <div class="flex flex-col items-center justify-center">
            <div class="flex items-center">

                <div class="flex flex-col items-center">
                    <a href="https://t.me/CodeSubs" target="_blank" rel="noopener noreferrer" class="icon-pointer" title="Channel">
                        <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/TelegramChannel.png" alt="Channel" class="h-12 w-12">
                        <span class="text-center m-1 font-bold text-lg block">ÿßŸÑŸÇŸÜÿßÿ©</span>
                    </a>
                </div>
        

                <div class="w-12"></div>


                <div class="flex flex-col items-center">
                    <a href="https://t.me/DCRef_bot" target="_blank" rel="noopener noreferrer" class="icon-pointer" title="Bot">
                        <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/TelegramBot.png" alt="Bot" class="h-12 w-12">
                        <span class="text-center m-1 font-bold text-lg block">ÿßŸÑÿ®Ÿàÿ™</span>
                    </a>
                </div>
            </div>
        </div>              

        <br>

        <div class="flex" style="justify-content: flex-start;">
            <div class="relative overflow-hidden bg-yellow-300 px-4 rounded w-full" style="padding-left: 0px; padding-right: 0px; overflow: hidden;">
                <div class="flex items-center justify-center h-10 animate-ticker" style="justify-content: flex-start; width: max-content;">
                    <span class="font-bold text-lg text-red-700">ÿ™ŸÜŸàŸäŸá: ÿ≥Ÿäÿ™ŸÖ ŸÜÿ¥ÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ÿßŸÑŸÖÿ™ÿπŸÑŸÇÿ© ÿ®ÿßŸÑÿ®Ÿàÿ™ ÿ£Ÿà ÿßŸÑÿØŸÑŸäŸÑ ÿπÿ®ÿ± ŸÇŸÜÿßÿ© ÿßŸÑÿ™ŸäŸÑÿ¨ÿ±ÿßŸÖ. ŸÜÿ±ÿ¨Ÿà ŸÖŸÜŸÉŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ© ŸÑŸÑÿ®ŸÇÿßÿ° ÿπŸÑŸâ ÿßÿ∑ŸÑÿßÿπ ÿØÿßÿ¶ŸÖ ÿ®ŸÉŸÑ ÿ¨ÿØŸäÿØ.</span>
                </div>
            </div>
        </div> -->

        <!--<div id="app">
            <div class="flex flex-col items-center justify-center mt-10 px-4 sm:px-6 md:px-8 lg:px-10 xl:px-12">
                <div class="relative overflow-hidden bg-yellow-200 border border-yellow-400 px-4 sm:px-6 md:px-8 py-3 sm:py-4 rounded-lg w-full max-w-2xl shadow-lg">
                    <div class="flex items-center justify-center">
                        <span class="font-bold text-red-700 text-center w-full whitespace-nowrap"
                            :style="{ fontSize: fontSize + 'px' }">
                            ‚úÖ ÿ™ŸÖ ÿ•ÿµŸÑÿßÿ≠ ŸÖÿ¥ŸÉŸÑÿ© ÿπÿØŸÖ ŸÅÿ™ÿ≠ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ŸàÿßŸÑŸÖÿßŸÜÿ∫ÿß
                        </span>
                    </div>
                </div>
            </div>
        </div> -->

        <br>
        <!-- Search and Filters -->
        <div v-if="!loading" class="flex flex-col gap-4 items-center">
            <div class="flex gap-3 w-full justify-center">
                <select
                    v-model="selectedFilter"
                    :disabled="isCapturingEpisodeTableImages"
                    @mousedown="guardEventIfCapturing($event)"
                    @click="guardEventIfCapturing($event)"
                    class="border px-4 font-bold py-2 rounded disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    <option value="all">ÿßŸÑŸÉŸÑ</option>
                    <option value="anime">ÿßŸÑÿ≠ŸÑŸÇÿßÿ™</option>
                    <option value="movies">ÿ£ŸÅŸÑÿßŸÖ</option>
                    <option value="hourly_special">ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ©)</option>
                    <option value="two_hour_special">ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ™ŸäŸÜ)</option>
                    <option value="short_story">ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©</option>
                    <option value="ova">ÿ£ŸàŸÅÿß</option>
                    <option value="movie_special">ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ</option>
                    <option value="special_release">ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ</option>
                    <option value="magic_kaito">ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà</option>
                    <option value="zero_diaries">ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà</option>
                    <option value="criminal_hanzawa">ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß</option>
                </select>
            
                <fieldset class="border border-gray-300 rounded p-2 w-1/2">
                    <legend class="px-1 font-bold text-white-600 text-sm">{{ episodeTypeLegend }}
                        <button 
                            class="bg-orange-500 text-white font-bold py-2 px-1 rounded hover:bg-orange-800 transition text-sm transition-all duration-100 active:scale-90" 
                            @click="openEmptyPopup">
                            ÿßŸÑŸÖÿ≤ŸäÿØ
                        </button>
                    </legend>
                    <div class="flex items-center text-blue font-bold gap-4 justify-center">
                        <label class="py-2 transition-all duration-100 active:scale-90 rounded">
                            <input type="radio" v-model="episodeTypeFilter" value="All" checked class="scale-150">
                            ÿßŸÑŸÉŸÑ
                        </label>
                        <label class="py-2 transition-all duration-100 active:scale-90 rounded" :class="{'bg-teal-900 text-white': episodeTypeFilter === 'Manga'}">
                            <input type="radio" v-model="episodeTypeFilter" value="Manga" class="scale-150">
                            ŸÖÿßŸÜÿ∫ÿß
                        </label>
                        <label class="py-2 transition-all duration-100 active:scale-90 rounded" :class="{'bg-red-950 text-white': episodeTypeFilter === 'Filler'}">
                            <input type="radio" v-model="episodeTypeFilter" value="Filler" class="scale-150">
                            ŸÅŸêŸÑÿ±
                        </label>
                    </div>
                </fieldset>
            </div>
            
            <!-- Empty popup window -->
            <div v-if="showEmptyPopup" ref="emptyPopupRoot" class="fixed top-0 left-0 w-full h-full bg-black bg-opacity-70 flex items-center justify-center z-50">
                <div class="relative bg-sky-900 rounded shadow-lg w-[100%] sm:w-[80%] md:w-[70%] lg:w-[50%] max-h-[100vh] overflow-hidden flex flex-col"> <!-- the defualt is 80vh in max-h-[95vh]-->
                    <!-- Sticky Header Section -->
                    <div class="sticky top-0 z-50 bg-sky-900 p-4">
                        <h2 class="text-2xl font-bold text-green-400 relative">
                            <!-- Close Button in the Top Left of the Title -->
                            <button 
                                @click="closeEmptyPopup" 
                                class="absolute top-0 left-0 text-yellow-300 hover:text-yellow-600 font-bold transition-all duration-100 active:scale-90">
                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/close.png" alt="Close" class="h-9 w-9"/>
                            </button>
                            ÿ™ÿµŸÅŸäÿ© ŸÖŸàÿ≥ÿπÿ©
                            <!-- Reset Button (Refresh Icon with Image) -->
                            <button 
                            @click="resetFilters" 
                            class="absolute top-0 left-14 text-yellow-300 hover:text-yellow-600 font-bold transition-all duration-100 active:scale-90">
                            <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/redo.png" alt="Reset" class="h-9 w-9"/>
                        </button>
                        </h2>
                        <span class="font-bold text-base">
                            <span style="color: rgb(0 255 222)">ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ™ÿµŸÅŸäÿ©: </span>
                            <span class="text-yellow-300">({{ episodeCountText }})</span>
                        </span>
                    </div>                    
                    
                    <!-- Scrollable Content -->
                    <div ref="emptyPopupScroll" class="overflow-y-auto p-4 flex-1 always-visible-scrollbar">

                        <!-- User Guide Section -->
                        <div class="bg-gray-800 text-white p-4 rounded mb-4">
                            <h3 class="text-lg font-bold mb-2">ÿßŸÑÿ¥ÿ±ÿ≠ ÿßŸÑÿ™Ÿàÿ∂Ÿäÿ≠Ÿä</h3>
                            <ul class="list-disc pl-5 pr-2 text-base">
                                <li class="mb-2">ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖÿ±ÿ¥ÿ≠ÿßÿ™ ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸä ÿßŸÑÿ£ÿ≥ŸÅŸÑ ŸÑÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿπÿ±ÿ∂Ÿá Ÿàÿ™ŸÇŸäŸäÿØŸá ÿØÿßÿÆŸÑ ÿßŸÑÿ¨ÿØŸàŸÑ.</li>
                                <li class="mb-2">ŸÑÿπÿ±ÿ∂ ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑŸÖÿ±ÿ¥ÿ≠ÿßÿ™ÿå ÿßŸÜÿ™ŸÇŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ¨ÿØŸàŸÑ ÿπŸÜ ÿ∑ÿ±ŸäŸÇ ÿ•ÿ∫ŸÑÿßŸÇ Ÿáÿ∞Ÿá ÿßŸÑŸÜÿßŸÅÿ∞ÿ© ÿ®ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿ≤ÿ± ÿßŸÑÿ•ÿ∫ŸÑÿßŸÇ (ÿßŸÑÿ≤ÿ± ÿßŸÑÿ£ÿ≠ŸÖÿ±) ŸÅŸä ÿßŸÑÿ≤ÿßŸàŸäÿ© ÿßŸÑÿπŸÑŸàŸäÿ© ÿßŸÑŸäÿ≥ÿ±Ÿâ.</li>
                                <li>ŸÑÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ±ÿ¥ÿ≠ÿßÿ™ ÿ•ŸÑŸâ ÿßŸÑŸàÿ∂ÿπ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿå ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿ≤ÿ± ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿπŸäŸäŸÜ (ÿßŸÑÿ≤ÿ± ÿßŸÑÿ®ÿ±ÿ™ŸÇÿßŸÑŸä) ŸÅŸä ÿßŸÑÿ≤ÿßŸàŸäÿ© ÿßŸÑÿπŸÑŸàŸäÿ© ÿßŸÑŸäÿ≥ÿ±Ÿâ.</li>                                
                            </ul>
                        </div>
                        
                        <div class="bg-gray-800 text-yellow-300 p-4 rounded mb-4 text-center">
                            <h3 class="text-lg font-bold mb-2">ŸÖŸÑÿßÿ≠ÿ∏ÿ©</h3>
                            <p class="text-base">ÿßÿ≥ŸÖÿßÿ° ÿßŸÑÿ¥ÿÆÿµŸäÿßÿ™ ÿ®ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑŸäÿßÿ®ÿßŸÜŸä (ÿßÿ≥ŸÖ ÿßŸÑÿπÿßÿ¶ŸÑÿ© + ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿÆÿµ)</p>
                        </div>

                        <div class="space-y-4">
                            <fieldset v-for="section in filterUi.sections" :key="section.kind" class="border p-4 rounded">
                                <legend class="font-bold text-lg px-2 mb-2" style="color: rgb(2 255 0);">{{ section.title }}</legend>

                                <div v-if="section.kind === 'basic'" class="space-y-5">
                                    <label
                                        v-for="opt in filterUi[section.optionsKey]"
                                        :key="section.inputType === 'radio' ? opt.value : opt.modelKey"
                                        class="flex items-center space-x-2 transition-all duration-100 active:scale-90"
                                    >
                                        <input
                                            v-if="section.inputType === 'radio'"
                                            type="radio"
                                            class="scale-150"
                                            :value="opt.value"
                                            :checked="getByKey(section.modelKey) === opt.value"
                                            :data-filter-key="section.modelKey"
                                            :data-filter-value="opt.value"
                                            @change="onFilterRadioChange(section.modelKey, opt.value)"
                                        >
                                        <input
                                            v-else
                                            type="checkbox"
                                            class="scale-150"
                                            :checked="getByKey(opt.modelKey)"
                                            :data-filter-key="opt.modelKey"
                                            @change="onFilterCheckboxChange(opt.modelKey, $event)"
                                        >
                                        <span class="px-2 text-base font-bold">{{ opt.label }} ({{ getByKey(opt.countKey) }})</span>
                                    </label>
                                </div>

                                <div v-else class="space-y-4">
                                    <fieldset v-for="group in filterUi.characterGroups" :key="group.title" class="border p-4 rounded">
                                        <legend class="font-bold text-lg px-2 mb-2" style="color: rgb(2 255 0);">{{ group.title }}</legend>

                                        <div class="space-y-5">
                                            <div v-for="id in group.ids" :key="id" class="space-y-2">
                                                <label class="flex items-center space-x-2 transition-all duration-100 active:scale-90">
                                                    <input
                                                        type="checkbox"
                                                        class="scale-150"
                                                        :checked="getByKey(characterEpisodesKey(id))"
                                                        :data-filter-key="characterEpisodesKey(id)"
                                                        @change="onCharacterToggle(id, $event.target.checked)"
                                                    >
                                                    <span class="px-2 text-base font-bold">{{ characterLabel(id) }} ({{ getByKey(characterCountKey(id)) }})</span>
                                                </label>

                                                <fieldset
                                                    v-if="isCharacterAdvanced(id) && getByKey(characterEpisodesKey(id))"
                                                    class="border border-orange-400 p-4 rounded"
                                                >
                                                    <div class="ml-4 flex space-x-2">
                                                        <label
                                                            v-for="logic in filterUi.logicOptions"
                                                            :key="logic.value"
                                                            class="flex items-center transition-all duration-100 active:scale-90"
                                                            :class="logic.value === 'Some' ? 'px-4' : ''"
                                                        >
                                                            <input
                                                                type="radio"
                                                                class="scale-150"
                                                                :name="'logic-' + id"
                                                                :value="logic.value"
                                                                :checked="getByKey(characterLogicKey(id)) === logic.value"
                                                                @change="setByKey(characterLogicKey(id), logic.value)"
                                                            >
                                                            <span class="px-2">{{ logic.label }}</span>
                                                        </label>
                                                    </div>

                                                    <br />

                                                    <div class="space-y-3">
                                                        <label
                                                            v-for="detail in filterUi.detailOptions"
                                                            :key="detail.kind"
                                                            class="flex items-center space-x-2 transition-all duration-100 active:scale-90"
                                                        >
                                                            <input
                                                                type="checkbox"
                                                                class="scale-150"
                                                                :checked="getByKey(characterDetailKey(id, detail.kind))"
                                                                :data-filter-key="characterDetailKey(id, detail.kind)"
                                                                @change="onFilterCheckboxChange(characterDetailKey(id, detail.kind), $event)"
                                                            >
                                                            <span class="px-2 font-bold">{{ detail.label }} ({{ getByKey(characterDetailCountKey(id, detail.kind)) }})</span>
                                                        </label>
                                                    </div>
                                                </fieldset>
                                            </div>
                                        </div>
                                    </fieldset>
                                </div>
                            </fieldset>
                        </div>
                    </div>
                    
                    <div
                        v-if="activeFiltersCount > 0"
                        class="sticky bottom-0 bg-yellow-900 text-white font-bold text-center px-4 py-3 cursor-pointer select-none"
                        @click="cycleActiveFilterFocus"
                    >
                        ÿπÿØÿØ ÿßŸÑŸÖÿ±ÿ¥ÿ≠ÿßÿ™ ÿßŸÑŸÖŸÅÿπŸëŸÑÿ© ÿ≠ÿßŸÑŸäŸãÿß: {{ activeFiltersCount }}
                    </div>
                </div>
            </div>   

                        <!-- Manga Announcement Box -->
                        <div class="relative w-full max-w-2xl p-4 mt-4 bg-black bg-opacity-85 rounded-lg shadow-lg border border-yellow-500 animate-borderMove">
                            <!-- Set Grid to 3 Columns -->
                            <div class="grid grid-cols-3 gap-4">
                                
                                <!-- 1. Episode Column (Right or Left depending on page direction) -->
                                <div class="flex flex-col items-center">
                                    <p class="text-white text-lg text-center font-bold mb-4">ÿ≠ŸÑŸÇÿ© ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ</p>
                                    <button 
                                        v-if="episodes && episodes.length > 0"
                                        @click="openEpisodeModal(ep)"
                                        class="w-full py-2 bg-teal-600 text-white font-bold text-lg rounded hover:bg-teal-500 transition-all duration-100 hover:scale-105 active:scale-90">
                                        {{ ep }}
                                    </button>
                                    <p v-if="episodeOfWeekTimeAgo || episodeOfWeekTimeAgoEnglish" 
                                    @click="toggleTimeFormat" 
                                    class="text-white text-xs text-center mt-3 cursor-pointer hover:text-gray-300 transition-colors duration-200">
                                        {{ showEnglishTimeFormat ? episodeOfWeekTimeAgoEnglish : episodeOfWeekTimeAgo }}
                                    </p>
                                </div>

                                <!-- 2. Movie Column (MIDDLE POSITION) -->
                                <div class="flex flex-col items-center">
                                    <p class="text-white text-lg text-center font-bold mb-4">ŸÅŸäŸÑŸÖ ÿßŸÑÿ≥ŸÜÿ© ÿßŸÑŸÖÿßÿ∂Ÿäÿ©</p>
                                    <button 
                                        @click="openEpisodeModal('ÿßŸÑŸÅŸäŸÑŸÖ 28')"
                                        class="w-full py-2 bg-red-500 text-white font-bold text-lg rounded transition-all duration-100 hover:scale-105 active:scale-90">
                                        28
                                    </button>
                                    <p v-if="(movieCountdownArabic || movieTimeAgoArabic)"
                                        @click="toggleMovieTimeFormat"
                                        class="text-white text-xs text-center mt-3 cursor-pointer hover:text-gray-300 transition-colors duration-200">
                                        {{ showEnglishMovieTimeFormat 
                                            ? (movieHasUpcomingRelease ? movieCountdownEnglish : movieTimeAgoEnglish)
                                            : (movieHasUpcomingRelease ? movieCountdownArabic : movieTimeAgoArabic) }}
                                    </p>
                                </div>

                                <!-- 3. Manga Column (Last position) -->
                                <div class="flex flex-col items-center">
                                    <p class="text-white text-lg text-center font-bold mb-4">ŸÅÿµŸÑ ÿßŸÑŸÖÿßŸÜÿ∫ÿß</p>
                                    <button 
                                        v-if="mangas && mangas.length > 0"
                                        @click="openMangaModal(mangaCh)"
                                        class="w-full py-2 bg-green-600 text-white font-bold text-lg rounded hover:bg-green-500 transition-all duration-100 hover:scale-105 active:scale-90">
                                        {{ mangaCh }}
                                    </button>
                                    <p v-if="mangaOfWeekTimeAgo || mangaOfWeekTimeAgoEnglish" 
                                    @click="toggleTimeFormatManga" 
                                    class="text-white text-xs text-center mt-3 cursor-pointer hover:text-gray-300 transition-colors duration-200">
                                        {{ showEnglishTimeFormatManga ? mangaOfWeekTimeAgoEnglish : mangaOfWeekTimeAgo }}
                                    </p>
                                </div>

                            </div>
                            <fieldset class="mt-4 border border-[#62a7ff] rounded-lg pb-4 space-y-2">
                                <legend class="px-2 text-white text-lg text-center font-bold">
                                    ÿßŸÑÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÇÿßÿØŸÖÿ©
                                </legend>

                                <!-- Upcoming Episode Notice -->
                                <div
                                    v-if="nextEpisodeInfo && nextEpisodeInfo.Enable !== false && nextEpisodeStatus"
                                    class="text-center space-y-1"
                                >
                                    <p
                                        v-if="nextEpisodeStatus === 'countdown' && nextEpisodeCountdownArabicDynamic"
                                        class="text-white text-base flex flex-wrap justify-center items-center gap-1"
                                    >
                                        <span>ŸÖÿ™ÿ®ŸÇŸä</span>
                                        <span
                                            class="cursor-pointer hover:text-gray-300"
                                            @click="toggleNextEpisodeCountdownLanguage"
                                        >
                                        {{
                                            showEnglishNextEpisodeCountdown
                                            ? nextEpisodeCountdownEnglishValue
                                            : nextEpisodeCountdownArabicDynamic
                                        }}
                                        </span>
                                        <span>ŸÑŸÑÿ≠ŸÑŸÇÿ©</span>
                                        <span
                                            v-if="nextEpisodeHasRecord"
                                            class="text-yellow-300 underline cursor-pointer transition-all duration-100 active:scale-90"
                                            @click="openEpisodeModal(String(nextEpisodeInfo.number))"
                                        >
                                        {{ nextEpisodeInfo.number }}
                                        </span>
                                        <span
                                            v-else
                                            class="text-yellow-300"
                                        >
                                        {{ nextEpisodeInfo.number }}
                                        </span>
                                    </p>

                                    <p
                                        v-else-if="nextEpisodeStatus === 'translation'"
                                        class="text-white text-base"
                                    >
                                        <span>ÿßŸÑÿ≠ŸÑŸÇÿ© </span>
                                        <span
                                            class="text-yellow-300 underline cursor-pointer transition-all duration-100 active:scale-90"
                                            @click="openEpisodeModal(String(nextEpisodeInfo.number))"
                                        >
                                        {{ nextEpisodeInfo.number }}
                                        </span>
                                        <span> ŸÇŸäÿØ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ŸÖŸÜ ŸÇÿ®ŸÑ ÿßŸÑŸÖÿ™ÿ±ÿ¨ŸÖŸäŸÜ.</span>
                                    </p>
                                </div>

                                <!-- Upcoming Manga Notice -->
                                <div
                                    v-if="nextMangaInfo && nextMangaInfo.Enable !== false && nextMangaStatus"
                                    class="text-center space-y-1"
                                >
                                    <p
                                        v-if="nextMangaStatus === 'countdown' && nextMangaCountdownArabicDynamic"
                                        class="text-white text-base flex flex-wrap justify-center items-center gap-1"
                                    >
                                        <span>ŸÖÿ™ÿ®ŸÇŸä</span>
                                        <span
                                            class="cursor-pointer hover:text-gray-300"
                                            @click="toggleNextMangaCountdownLanguage"
                                        >
                                        {{
                                            showEnglishNextMangaCountdown
                                            ? nextMangaCountdownEnglishValue
                                            : nextMangaCountdownArabicDynamic
                                        }}
                                        </span>
                                        <span>ŸÑŸÑŸÅÿµŸÑ</span>
                                        <span class="text-yellow-300">
                                        {{ nextMangaInfo.number }}
                                        </span>
                                    </p>

                                    <p
                                        v-else-if="nextMangaStatus === 'translation'"
                                        class="text-white text-base"
                                    >
                                        <span>ÿßŸÑŸÅÿµŸÑ </span>
                                        <span
                                            class="text-yellow-300 underline cursor-pointer transition-all duration-100 active:scale-90"
                                            @click="openMangaModal(String(nextMangaInfo.number))"
                                        >
                                        {{ nextMangaInfo.number }}
                                        </span>
                                        <span> ŸÇŸäÿØ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ŸÖŸÜ ŸÇÿ®ŸÑ ÿßŸÑŸÖÿ™ÿ±ÿ¨ŸÖŸäŸÜ.</span>
                                    </p>
                                </div>
                            </fieldset>
                        </div>

                        <!-- Centered Description Box for Colors and Their Names with "ŸÖÿπÿßŸÜŸä ÿßŸÑÿ£ŸÑŸàÿßŸÜ" Legend -->
                        <fieldset class="my-4 w-full font-bold p-4 rounded border relative">
                            <legend class="px-2 font-bold text-white-600">ŸÖÿπÿßŸÜŸä ÿßŸÑÿ£ŸÑŸàÿßŸÜ</legend>
                            <div class="flex flex-wrap gap-4 justify-center">
                                <div class="flex items-center gap-2" v-tippy="'ÿ≠ŸÑŸÇÿßÿ™ ŸÖÿ£ÿÆŸàÿ∞ÿ© ŸÖŸÜ ÿßŸÑŸÖÿßŸÜÿ∫ÿß ÿßŸÑÿ£ÿµŸÑŸäÿ©'">
                                    <span class="w-6 h-6 bg-teal-900 rounded-full"></span>
                                    <span>ŸÖÿßŸÜÿ∫ÿß</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ÿ≠ŸÑŸÇÿßÿ™ ŸÑÿß ÿ™ŸÜÿ™ŸÖŸä ÿ•ŸÑŸâ ÿßŸÑŸÇÿµÿ© ÿßŸÑÿ£ÿµŸÑŸäÿ© ŸàŸÑÿß ÿ™ÿ±ÿ™ÿ®ÿ∑ ÿ®ÿ≥Ÿäÿ± ÿßŸÑÿ£ÿ≠ÿØÿßÿ´'">
                                    <span class="w-6 h-6 bg-red-900 rounded-full"></span>
                                    <span>ŸÅŸêŸÑÿ±</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ÿ£ŸÅŸÑÿßŸÖ ŸÑÿß ÿπŸÑÿßŸÇÿ© ŸÑŸáÿß ÿ®ÿßŸÑŸÇÿµÿ© ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ŸàÿπÿßŸÑŸÖŸáÿß ŸÖŸÜŸÅÿµŸÑ'">
                                    <span class="w-6 h-6 bg-amber-800 rounded-full"></span>
                                    <span>ŸÅŸäŸÑŸÖ</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ÿ≠ŸÑŸÇÿßÿ™ ÿ™ŸÖÿ™ÿØ ŸÑŸÅÿ™ÿ±ÿ© ÿ£ÿ∑ŸàŸÑ ŸÖŸÜ ÿßŸÑÿ≠ŸÑŸÇÿ© ÿßŸÑÿπÿßÿØŸäÿ© ÿßŸÑÿ™Ÿä ŸÖÿØÿ™Ÿáÿß 24 ÿØŸÇŸäŸÇÿ©ÿå ÿ≠Ÿäÿ´ ŸäÿµŸÑ ÿ®ÿπÿ∂Ÿáÿß ÿ•ŸÑŸâ ÿ≥ÿßÿπÿ© ŸàŸÜÿµŸÅ'">
                                    <span class="w-6 h-6 bg-sky-800 rounded-full"></span>
                                    <span>ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ©)</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ÿ≠ŸÑŸÇÿßÿ™ ÿ™ŸÖÿ™ÿØ ŸÑŸÅÿ™ÿ±ÿ© ÿ£ÿ∑ŸàŸÑ ŸÖŸÜ ÿßŸÑÿ≠ŸÑŸÇÿ© ÿßŸÑÿπÿßÿØŸäÿ© ÿßŸÑÿ™Ÿä ŸÖÿØÿ™Ÿáÿß 24 ÿØŸÇŸäŸÇÿ©ÿå ÿ≠Ÿäÿ´ ŸäÿµŸÑ ÿ®ÿπÿ∂Ÿáÿß ÿ•ŸÑŸâ ÿ≥ÿßÿπÿ™ŸäŸÜ ŸàŸÜÿµŸÅ'">
                                    <span class="w-6 h-6 bg-orange-600 rounded-full"></span>
                                    <span>ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ™ŸäŸÜ)</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ŸÇÿµÿµ ŸÇÿµŸäÿ±ÿ© ÿ™Ÿèÿ®ÿ±ÿ≤ ÿ£ÿ≥ŸÑŸàÿ® ÿ∫Ÿàÿ¥Ÿà ÿ£ŸàŸäÿßŸÖÿß ÿßŸÑÿ•ÿ®ÿØÿßÿπŸä Ÿàÿ™ŸÉÿ¥ŸÅ ÿ¨ÿ∞Ÿàÿ± Ÿàÿ™ÿ∑Ÿàÿ± ÿπÿßŸÑŸÖ ÿßŸÑŸÖÿ≠ŸÇŸÇ ŸÉŸàŸÜÿßŸÜ ÿØŸàŸÜ ÿßÿ±ÿ™ÿ®ÿßÿ∑ ÿ®ÿßŸÑÿ≥ÿ±ÿØ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä.'">
                                    <span class="w-6 h-6 bg-green-600 rounded-full"></span>
                                    <span>ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ÿ≠ŸÑŸÇÿßÿ™ ÿÆÿßÿµÿ© ÿ™ŸÇÿØŸÖ ŸÇÿµÿµÿßŸã ÿ£Ÿà ŸÖÿ∫ÿßŸÖÿ±ÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© ÿ™ŸÉÿ¥ŸÅ ÿ™ŸÅÿßÿµŸäŸÑ ÿ¨ÿØŸäÿØÿ© ÿπŸÜ ÿπÿßŸÑŸÖ ŸÉŸàŸÜÿßŸÜ ÿØŸàŸÜ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÑŸâ ÿßŸÑÿ≠ÿ®ŸÉÿ© ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©.'">
                                    <span class="w-6 h-6 bg-yellow-600 rounded-full"></span>
                                    <span>ÿ£ŸàŸÅÿß</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ÿ≠ŸÑŸÇÿßÿ™ ŸÇÿµŸäÿ±ÿ© ÿ™Ÿèÿπÿ±ŸÅ ÿ®ÿßÿ≥ŸÖ ¬´ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿ£ŸÅŸÑÿßŸÖ ÿßŸÑÿÆÿßÿµÿ©¬ª ÿ£Ÿà ¬´ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ≥ÿ≠ÿ±Ÿä¬ªÿå Ÿàÿ™ÿµŸÑ ŸÖÿØÿ© ÿπÿ±ÿ∂Ÿáÿß ÿ•ŸÑŸâ ŸÜÿ≠Ÿà 25 ÿØŸÇŸäŸÇÿ©.'">
                                    <span class="w-6 h-6 bg-cyan-500 rounded-full"></span>
                                    <span>ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ÿ≠ŸÑŸÇÿßÿ™ ŸÅÿ±ŸäÿØÿ© ŸÖŸÜ ŸÜŸàÿπŸáÿß ÿ™ŸÇÿπ ÿÆÿßÿ±ÿ¨ ÿßŸÑÿ≥ŸäÿßŸÇ ÿ£Ÿà ÿßŸÑÿ™ÿØŸÅŸÇ ÿßŸÑŸÖÿπÿ™ÿßÿØ ŸÑŸÑŸÖÿ≥ŸÑÿ≥ŸÑÿå ÿ™ŸÇÿØŸÖ ŸÖŸÜÿ∏Ÿàÿ±ÿßŸã ŸÖÿÆÿ™ŸÑŸÅÿßŸã ÿ£Ÿà ŸÜÿ∏ÿ±ÿ© ÿ´ÿßŸÇÿ®ÿ© ŸÑŸÇÿµÿ© ŸÖÿπŸäŸÜÿ©.'">
                                    <span class="w-6 h-6 bg-purple-500 rounded-full"></span>
                                    <span>ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ŸÖÿ≥ŸÑÿ≥ŸÑ Ÿäÿ±ŸàŸä ŸÖÿ∫ÿßŸÖÿ±ÿßÿ™ ŸÉÿßŸäÿ™Ÿà ŸÉŸàÿ±Ÿàÿ®ÿßÿå ŸÅÿ™Ÿâ Ÿäÿ™ŸÇŸÖÿµ ŸáŸàŸäÿ© ÿßŸÑŸÑÿµ ŸÉÿßŸäÿ™Ÿà ŸÉŸäÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸãÿß ÿßŸÑÿÆÿØÿπ ÿßŸÑÿ≥ÿ≠ÿ±Ÿäÿ© ŸÑŸÉÿ¥ŸÅ ŸÑÿ∫ÿ≤ ŸÖŸÇÿ™ŸÑ ŸàÿßŸÑÿØŸá ŸàÿßŸÑÿ™ÿµÿØŸä ŸÑŸÖŸÜÿ∏ŸÖÿ© ÿ∫ÿßŸÖÿ∂ÿ©.'">
                                    <span class="w-6 h-6 bg-indigo-600 rounded-full"></span>
                                    <span>ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ŸÖÿ≥ŸÑÿ≥ŸÑ ŸÅÿ±ÿπŸä Ÿäÿ≥ŸÑÿ∑ ÿßŸÑÿ∂Ÿàÿ° ÿπŸÑŸâ ÿßŸÑÿ≠Ÿäÿßÿ© ÿßŸÑŸÖÿ≤ÿØŸàÿ¨ÿ© ŸÑÿ™Ÿàÿ±Ÿà ÿ£ŸÖŸàÿ±Ÿàÿå ŸÖŸÇÿØŸÖŸãÿß ŸÖŸÜÿ∏Ÿàÿ±Ÿãÿß ÿ¨ÿØŸäÿØŸãÿß ŸÑÿ¥ÿÆÿµŸäÿ™Ÿá ÿÆÿßÿ±ÿ¨ ÿ•ÿ∑ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÇŸäŸÇÿßÿ™ ÿßŸÑŸÖÿπÿ™ÿßÿØÿ©.'">
                                    <span class="w-6 h-6 bg-pink-600 rounded-full"></span>
                                    <span>ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà</span>
                                </div>
                                <div class="flex items-center gap-2" v-tippy="'ŸÖÿ≥ŸÑÿ≥ŸÑ ŸÉŸàŸÖŸäÿØŸä ŸÅÿ±ÿπŸä Ÿäÿπÿ±ÿ∂ ŸÖÿ∫ÿßŸÖÿ±ÿßÿ™ ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß ŸÖŸÜ ŸÖŸÜÿ∏Ÿàÿ± ÿ≥ÿßÿÆÿ±ÿå ÿ≠Ÿäÿ´ ŸäŸàÿßÿ¨Ÿá ŸÖŸàÿßŸÇŸÅ ÿ∑ÿ±ŸäŸÅÿ© ÿ£ÿ´ŸÜÿßÿ° ÿ≥ÿπŸäŸá ŸÑÿ™ÿ≠ŸÇŸäŸÇ ÿ£ŸáÿØÿßŸÅŸá ŸÅŸä ŸÖÿØŸäŸÜÿ© ÿ™ÿπÿ¨Ÿë ÿ®ÿßŸÑÿ¨ÿ±ÿßÿ¶ŸÖ.'">
                                    <span class="w-6 h-6 bg-stone-600 rounded-full"></span>
                                    <span>ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß</span>
                                </div>
                            </div>
                        </fieldset>

                        <!-- Pagination Controls -->
                        <div class="flex flex-wrap justify-between items-center" id="pagination-buttons">
                            
                            <button @click="goToFirstPage" 
                                    :disabled="currentPage === 1"
                                    class="bg-green-700 text-white font-bold px-4 py-2 rounded 
                                        hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed
                                        transition-all duration-100 active:bg-green-800 active:scale-90">
                                ÿßŸÑÿ£ŸàŸÑ
                            </button>
                            
                            <button @click="nextPage" 
                                    :disabled="currentPage === totalPages"
                                    class="bg-blue-700 text-white font-bold px-4 py-2 rounded 
                                        hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed
                                        transition-all duration-100 active:bg-blue-800 active:scale-90">
                                ÿßŸÑÿ™ÿßŸÑŸä
                            </button>
                            
                            <button @click="prevPage" 
                                    :disabled="currentPage === 1"
                                    class="bg-blue-700 text-white font-bold px-4 py-2 rounded 
                                        hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed
                                        transition-all duration-100 active:bg-blue-800 active:scale-90">
                                ÿßŸÑÿ≥ÿßÿ®ŸÇ
                            </button>
                            
                            <button @click="goToLastPage" 
                                    :disabled="currentPage === totalPages"
                                    class="bg-green-700 text-white font-bold px-4 py-2 rounded 
                                        hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed
                                        transition-all duration-100 active:bg-green-800 active:scale-90">
                                ÿßŸÑÿ£ÿÆŸäÿ±
                            </button>
                            
                        </div>

                        <div class="mt-4 w-full">
                            <div class="flex flex-col gap-2 text-white font-bold items-center">
                                <div class="w-full flex items-center justify-center gap-3">
                                    <div class="flex flex-col gap-1">
                                        <label class="inline-flex items-center gap-2">
                                            <input type="radio" v-model="jumpTargetMode" value="episode" class="cursor-pointer" />
                                            <span>ÿ≠ŸÑŸÇÿ©</span>
                                        </label>
                                        <label class="inline-flex items-center gap-2">
                                            <input type="radio" v-model="jumpTargetMode" value="page" class="cursor-pointer" />
                                            <span>ÿµŸÅÿ≠ÿ©</span>
                                        </label>
                                    </div>
                                    <div class="relative flex-1 w-full max-w-xs">
                                        <textarea
                                            v-model.trim="jumpInput"
                                            @focus="onJumpInputFocus"
                                            @blur="onJumpInputBlur"
                                            @keydown.enter.prevent="executeJumpValue"
                                            :inputmode="jumpTargetMode === 'page' ? 'numeric' : 'text'"
                                            rows="1"
                                            :class="[
                                                'w-full px-1 py-3 text-base bg-gray-700 rounded text-white focus:outline-none focus:ring-2 focus:ring-teal-400 resize-none overflow-y-auto whitespace-pre-wrap break-words',
                                                jumpTargetMode === 'page'
                                                    ? (jumpInputActive ? 'text-right' : 'text-center')
                                                    : ''
                                            ]"
                                            :placeholder="jumpTargetMode === 'page' ? 'ÿ±ŸÇŸÖ ÿßŸÑÿµŸÅÿ≠ÿ©...' : 'ÿ±ŸÇŸÖ ÿßŸÑÿ≠ŸÑŸÇÿ©...'"
                                        ></textarea>
                                        <button
                                            v-if="jumpTargetMode !== 'page'"
                                            @click="clearJumpInput"
                                            class="absolute left-3 top-3 text-xl text-red-600 font-black transition-all duration-100 active:scale-90"
                                        >
                                            ‚úï
                                        </button>
                                    </div>
                                    <button
                                        @click.stop="executeJumpValue"
                                        class="bg-teal-600 text-white font-bold px-2 py-3 rounded hover:bg-teal-500 transition-all duration-100 active:scale-90"
                                    >
                                        ÿßÿ∞Ÿáÿ®
                                    </button>
                                </div>
                            </div>
                        </div>

        </div>

        <!-- Table -->
        <div v-if="!loading">
            <table class="min-w-full border-collapse border border-gray-300">
                <thead>
                    <!-- Top full-width row -->
                    <tr>
                        <th colspan="2" :class="['border border-gray-300 h-8', (isAnyFilterActive || searchQuery) ? 'bg-orange-500' : '']">
                            <span
                                v-if="isAnyFilterActive || searchQuery"
                                class="inline-block text-base text-black transition-all duration-100"
                            >
                                <template v-if="isAnyFilterActive && searchQuery">
                                    <span class="inline-block text-base text-black cursor-pointer transition-all duration-100 active:scale-90" @click="toggleSearch">
                                        ÿßŸÑÿ®ÿ≠ÿ´
                                    </span>
                                    Ÿà
                                    <span class="inline-block text-base text-black cursor-pointer transition-all duration-100 active:scale-90" @click="openEmptyPopup">
                                        ÿßŸÑÿ™ÿµŸÅŸäÿ©
                                    </span>
                                    ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿ≠ÿßŸÑŸäŸãÿß
                                </template>
                                <template v-else-if="isAnyFilterActive">
                                    <span class="inline-block text-base text-black cursor-pointer transition-all duration-100 active:scale-90" @click="openEmptyPopup">
                                        ÿßŸÑÿ™ÿµŸÅŸäÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿ≠ÿßŸÑŸäŸãÿß
                                    </span>
                                </template>
                                <template v-else>
                                    <span class="inline-block text-base text-black cursor-pointer transition-all duration-100 active:scale-90" @click="toggleSearch">
                                        ÿßŸÑÿ®ÿ≠ÿ´ ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿ≠ÿßŸÑŸäŸãÿß
                                    </span>
                                </template>
                            </span>
                            <br v-if="isAnyFilterActive || searchQuery" />
                            <span :class="combinedFilterBadgeClasses">
                                {{ selectedFilterLabel }} - {{ episodeTypeFilterLabel }}
                            </span>
                            <div class="relative">
                                <span
                                    class="text-lg text-red-600"
                                    v-tippy="tooltipText"
                                    :style="(isAnyFilterActive || searchQuery) ? 'color: rgb(0 6 255);' : ''"
                                >
                                    ({{ episodeCountText }})
                                </span>
                            </div>
                            <div v-if="showEpisodeTableCaptureButton" class="mt-2 flex flex-col items-center gap-2">
                                <button
                                    type="button"
                                    @click="captureEpisodeTableImages"
                                    :disabled="isCapturingEpisodeTableImages || totalEpisodes === 0"
                                    class="bg-slate-900 text-white font-bold px-4 py-1 rounded hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90"
                                >
                                    {{ isCapturingEpisodeTableImages ? `ÿ¨ÿßÿ±Ÿä ÿßŸÑÿßŸÑÿ™ŸÇÿßÿ∑ (${captureEpisodeTableImagesDone}/${captureEpisodeTableImagesTotal})` : (totalEpisodes <= 15 ? 'ÿ≠ŸÅÿ∏ ÿßŸÑÿ¨ÿØŸàŸÑ ŸÉÿµŸàÿ±ÿ©' : 'ÿ≠ŸÅÿ∏ ÿßŸÑÿ¨ÿØŸàŸÑ ŸÉÿµŸàÿ±') }}
                                </button>

                                <div v-if="isCapturingEpisodeTableImages && captureEpisodeTableDelayRemainingMs > 0" class="text-base font-black" style="color: rgb(0 0 0);">
                                    ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ™ÿßŸÑŸä: {{ Math.ceil(captureEpisodeTableDelayRemainingMs / 1000) }} ÿ´ÿßŸÜŸäÿ©
                                </div>

                                <button
                                    v-if="isCapturingEpisodeTableImages"
                                    type="button"
                                    @click="openCaptureCancelConfirmation"
                                    data-capture-allow="1"
                                    class="bg-red-500 text-white font-bold px-4 py-1 rounded hover:bg-red-600 transition-all duration-100 active:scale-90"
                                >
                                    ÿ•ŸäŸÇÿßŸÅ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ™ÿµŸàŸäÿ±
                                </button>
                            </div>
                        </th>
                    </tr>

                    <!-- Existing header row -->
                    <tr class="">
                        <th class="border border-gray-300 text-xl px-2 py-2 text-center w-1/6">
                            {{ episodeNumberHeader }}
                        </th>               
                        <th class="border border-gray-300 text-xl px-4 py-2 text-center w-5/6">
                            {{ episodeTitleHeader }}
                            <br />
                            <span class="text-base" style="color: rgb(108 255 0); font-weight: 900;">
                                ÿßŸÜŸÇÿ± ÿπŸÑŸâ ÿ£Ÿä ÿπŸÜŸàÿßŸÜ ŸÑÿπÿ±ÿ∂ ÿ™ŸÅÿßÿµŸäŸÑŸá
                            </span>
                        </th>                                                                          
                    </tr>
                </thead>

                <div id="app" class="container mx-auto p-4 shadow-lg rounded">
                    <tbody>
                        <template v-for="(episode, index) in paginatedEpisodes" :key="episode.EpisodeNumber">
                            <tr :id="'ep-' + normalizeEpisodeIdentifier(episode.EpisodeNumber)" class="hover:bg-blue-100">
                                <td :class="[getBackgroundColor(episode), 'border', 'border-gray-300', 'px-2', 'text-lg', 'font-bold', 'py-2', 'text-center']" v-tippy="getEpisodeTypeTooltip(episode)">
                                    {{ formatEpisodeNumber(episode.EpisodeNumber) }}
                                </td>
                                <td
                                    :class="[
                                        'border border-gray-300 px-4 text-lg font-bold py-2 text-center cursor-pointer',
                                        isJumpHighlighted(episode)
                                            ? 'bg-yellow-300 text-black hover:bg-yellow-900 hover:text-white'
                                            : 'hover:bg-yellow-900',
                                        lastClickedEpisode === episode ? 'bg-blue-300 text-black hover:text-white' : ''
                                    ]"
                                    @click="selectEpisodeAndOpen(episode)"
                                >
                                    {{ episode.EpisodeTitle }}
                                </td>
                            </tr>
                            <tr v-if="showEpisodeAds && episodeAdInterval > 0 && (index + 1) % episodeAdInterval === 0">
                                <td class="border border-amber-500 bg-amber-700 text-white text-lg font-bold py-2 text-center">
                                    ÿ•ÿπŸÑÿßŸÜ
                                </td>
                                <td class="border border-amber-500 bg-amber-900 text-yellow-200 text-base font-bold py-2 text-center">
                                    ŸÖÿ≥ÿßÿ≠ÿ© ÿ•ÿπŸÑÿßŸÜŸäÿ© ŸÖŸÖŸäÿ≤ÿ© ŸÑÿØÿπŸÖ ÿßŸÑÿØŸÑŸäŸÑ ŸàÿßŸÑÿßÿ≥ÿ™ŸÖÿ±ÿßÿ± ŸÅŸä ÿ™ÿ∑ŸàŸäÿ±Ÿá
                                </td>
                            </tr>
                        </template>
                    </tbody>
            
                    <div v-if="showModal" class="fixed z-50 inset-0 overflow-y-auto bg-black bg-opacity-70 flex items-center justify-center">
                        
                        <div class="relative bg-cyan-900 text-slate-200 font-bold rounded-lg w-[100%] sm:w-[80%] md:w-[70%] lg:w-[50%] max-h-[100vh] flex flex-col"> <!-- the defualt is 80vh in max-h-[95vh]-->

                            <!-- Sticky Header Section -->
                            <div class="sticky top-0 bg-cyan-900 pt-4 pl-4 pr-4 pb-2">
                                <div class="flex justify-between items-center h-10">
                                    <!-- Middle: Sticky Title -->
                                    <div class="flex-1 flex items-center justify-center transition-opacity duration-300" :class="showStickyLabel ? 'opacity-100' : 'opacity-0'">
                                        <p v-if="selectedEpisode && showStickyLabel" class="text-lg font-bold truncate">
                                            <span>{{ parseEpisodeLabel(selectedEpisode.EpisodeNumber).cleanLabel }}</span>
                                            {{ parseEpisodeLabel(selectedEpisode.EpisodeNumber).cleanNum }}
                                        </p>
                                    </div>
                                    <!-- Left Side: Close Modal Button -->
                                    <button @click="closeModal" class="text-red-600 hover:text-yellow-300 font-bold transition-all duration-100 active:scale-90">
                                        <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/close.png" alt="Close" class="h-8 w-8" />
                                    </button>
                                </div>
                            </div>                          
                            
                            <!-- Scrollable Content -->
                            <div 
                                class="overflow-y-auto p-4 flex-1 always-visible-scrollbar" 
                                @click="relatedEpisodeMenuOpen = false"
                                @scroll="handleModalScroll"
                            >


                                <div v-if="selectedEpisode" class="relative mb-4">
                                    <button
                                        type="button"
                                        class="text-xl font-bold overflow-hidden text-ellipsis w-full"
                                        :class="[
                                            hasRelatedEpisodesForEpisode(selectedEpisode) && !isEpisodeSwitchBlocked(selectedEpisode) ? 'underline text-yellow-300 cursor-pointer' : '',
                                            isEpisodeSwitchBlocked(selectedEpisode) ? 'opacity-80 cursor-not-allowed' : ''
                                        ]"
                                        @click.stop="toggleRelatedEpisodeMenu"
                                    >
                                        {{ selectedEpisode.EpisodeTitle }}
                                    </button>

                                    <div
                                        v-if="relatedEpisodeMenuOpen && hasRelatedEpisodesForEpisode(selectedEpisode)"
                                        class="absolute left-1/2 -translate-x-1/2 mt-2 w-full max-w-md bg-cyan-950 border border-cyan-700 rounded-lg shadow-lg z-20 max-h-60 overflow-y-auto"
                                    >
                                        <button
                                            v-for="ep in getRelatedEpisodesForEpisode(selectedEpisode)"
                                            :key="ep.EpisodeNumber"
                                            type="button"
                                            class="w-full text-right px-4 py-2 text-base hover:bg-cyan-800 transition-all duration-100"
                                            :disabled="ep._relatedMissing"
                                            :class="[
                                                normalizeEpisodeIdentifier(ep.EpisodeNumber) === normalizeEpisodeIdentifier(selectedEpisode.EpisodeNumber) ? 'bg-cyan-700 text-yellow-200' : '',
                                                ep._relatedMissing ? 'opacity-60 cursor-not-allowed hover:bg-transparent' : ''
                                            ]"
                                            @click.stop="openRelatedEpisode(ep)"
                                        >
                                            {{ ep.EpisodeTitle }}
                                        </button>
                                    </div>
                                </div>

                                <p v-if="selectedEpisode" ref="episodeTitleLabel" class="mb-2 text-lg">
                                    <span>{{ parseEpisodeLabel(selectedEpisode.EpisodeNumber).cleanLabel }}</span>
                                    {{ parseEpisodeLabel(selectedEpisode.EpisodeNumber).cleanNum }}
                                </p>
                                
                                <p v-if="selectedEpisode" class="mb-2 text-lg">
                                    <span v-if="selectedEpisode.EpisodeNumber.includes('ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ')">ŸÜŸàÿπ ÿßŸÑÿ≠ŸÑŸÇÿ© ÿßŸÑÿÆÿßÿµÿ©: </span>
                                    <span v-else-if="selectedEpisode.EpisodeNumber.includes('ÿßŸÑŸÅŸäŸÑŸÖ')">ŸÜŸàÿπ ÿßŸÑŸÅŸäŸÑŸÖ: </span>
                                    <span v-else-if="selectedEpisode.EpisodeNumber.includes('ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©')">ŸÜŸàÿπ ÿßŸÑŸÇÿµÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ©: </span>
                                    <span v-else-if="selectedEpisode.EpisodeNumber.includes('ÿ£ŸàŸÅÿß2')">ŸÜŸàÿπ ÿßŸÑÿ£ŸàŸÅÿß ÿßŸÑÿ´ÿßŸÜŸäÿ©: </span>
                                    <span v-else-if="selectedEpisode.EpisodeNumber.includes('ÿ£ŸàŸÅÿß3')">ŸÜŸàÿπ ÿßŸÑÿ£ŸàŸÅÿß ÿßŸÑÿ´ÿßŸÑÿ´ÿ©: </span>
                                    <span v-else-if="selectedEpisode.EpisodeNumber.includes('ÿ£ŸàŸÅÿß')">ŸÜŸàÿπ ÿßŸÑÿ£ŸàŸÅÿß: </span>
                                    <span v-else-if="selectedEpisode.EpisodeNumber.includes('ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ')">ŸÜŸàÿπ ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ: </span>
                                    <span v-else>ŸÜŸàÿπ ÿßŸÑÿ≠ŸÑŸÇÿ©: </span>
                                    
                                    <span v-if="selectedEpisode.EpisodeNumber.includes('ÿßŸÑŸÅŸäŸÑŸÖ') || selectedEpisode.EpisodeNumber.includes('ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©')">
                                      <span v-if="selectedEpisode.EpisodeType === 'ŸÅ'">ŸÅŸêŸÑÿ±</span>
                                      <span v-else-if="selectedEpisode.EpisodeType === 'ŸÖ'">ŸÖÿßŸÜÿ∫ÿß</span>
                                      <span v-else-if="selectedEpisode.EpisodeType === 'ÿ´'">ŸÖÿßŸÜÿ∫ÿß</span>
                                      <span v-else-if="selectedEpisode.EpisodeType === 'ŸÖŸÅ'">ŸÖÿßŸÜÿ∫ÿß/ŸÅŸêŸÑÿ±</span>
                                      <span v-else>{{ selectedEpisode.EpisodeType }}</span>
                                      <!-- Append (ÿ£ŸàŸÅÿß) if EpisodeNumber includes "ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©" -->
                                      <span v-if="selectedEpisode.EpisodeNumber.includes('ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©') || selectedEpisode.EpisodeNumber.includes('ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ')"> (ÿ£ŸàŸÅÿß)</span>
                                    </span>
                                    
                                    <span v-else>
                                      <span v-if="selectedEpisode.EpisodeType === 'ŸÅ'">ŸÅŸêŸÑÿ±</span>
                                      <span v-else-if="selectedEpisode.EpisodeType === 'ŸÖ'">ŸÖÿßŸÜÿ∫ÿß</span>
                                      <span v-else-if="selectedEpisode.EpisodeType === 'ÿ´'">ŸÖÿßŸÜÿ∫ÿß</span>
                                      <span v-else-if="selectedEpisode.EpisodeType === 'ŸÖŸÅ'">ŸÖÿßŸÜÿ∫ÿß/ŸÅŸêŸÑÿ±</span>
                                      <span v-else>{{ selectedEpisode.EpisodeType }}</span>
                                    </span>                                    
                                </p>
                                                                

                                <p v-if="selectedEpisode && (selectedEpisode.EpisodeSpecial !== '' && selectedEpisode.EpisodeSpecial !== 'ÿ£ŸàŸÅÿß')" class="mb-2 text-lg">
                                    <span>ÿÆÿßÿµÿ©: </span>
                                    <span v-if="selectedEpisode.EpisodeSpecial === '1'"> (ÿ≥ÿßÿπÿ©)</span>
                                    <span v-else-if="selectedEpisode.EpisodeSpecial === '2'"> (ÿ≥ÿßÿπÿ™ŸäŸÜ)</span>
                                    <span v-else>ŸÑÿßŸäŸàÿ¨ÿØ</span>
                                </p>                                

                                <fieldset 
                                    v-if="selectedEpisode && selectedEpisode.EpisodeMangaQuoted !== ''" 
                                    :class="{
                                        'border p-2 rounded mb-2': selectedEpisode.EpisodeMangasIDs && selectedEpisode.EpisodeMangasIDs.length > 0
                                    }"
                                    >
                                    <!-- Show legend only if EpisodeMangasIDs exists and is not empty -->
                                    <legend 
                                        v-if="selectedEpisode.EpisodeMangasIDs && selectedEpisode.EpisodeMangasIDs.length > 0" 
                                        class="font-bold text-lg"
                                    >
                                        <p>
                                        <span dir="ltr">:ÿßŸÑŸÅÿµŸàŸÑ ÿßŸÑŸÖŸÇÿ™ÿ®ÿ≥ÿ©</span> {{ selectedEpisode.EpisodeMangaQuoted }}
                                        </p>
                                    </legend>

                                    <!-- If EpisodeMangasIDs is empty/null, only show the text -->
                                    <p v-else class="text-lg mb-2">
                                        <span dir="ltr">:ÿßŸÑŸÅÿµŸàŸÑ ÿßŸÑŸÖŸÇÿ™ÿ®ÿ≥ÿ©</span> {{ selectedEpisode.EpisodeMangaQuoted }}
                                    </p>

                                    <!-- Manga download buttons -->
                                    <div 
                                        v-if="selectedEpisode.EpisodeMangasIDs && selectedEpisode.EpisodeMangasIDs.length > 0" 
                                        class="flex flex-col justify-center gap-4"
                                    >
                                        <div 
                                        v-for="(manga, index) in selectedEpisode.EpisodeMangasIDs" 
                                        :key="manga.MangaNumber" 
                                        class="relative flex flex-col gap-4"
                                        >
                                        <button
                                            :disabled="manga.status === 'success' || manga.status === 'ratelimiting' || manga.status === 'sending'"
                                            @click="() => { sendMangaWrapper(manga.MangaFileID, manga.MangaNumber, index, false); }"
                                            class="bg-green-500 text-white px-6 py-2 rounded hover:bg-green-700 flex items-center justify-center shadow-md disabled:opacity-50 transition-all duration-100 active:scale-90 disabled:cursor-not-allowed"
                                            dir="ltr"
                                        >
                                            <span v-if="manga.status === 'ratelimiting'">{{ manga.MangaNumber }} ({{ formatFileSize(manga.MangaFileSize) }})</span>
                                            <span v-else-if="manga.countdown !== undefined">{{ manga.countdown }}</span>
                                            <span v-else>{{ manga.MangaNumber }} ({{ formatFileSize(manga.MangaFileSize) }})</span>
                                        </button>
                                        <img 
                                            v-if="manga.status === 'success'" 
                                            src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/true.png"
                                            class="absolute right-0 top-0 w-6 h-6 ml-2"
                                        />
                                        <img 
                                            v-if="manga.status === 'error'" 
                                            src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/close.png"
                                            class="absolute right-0 top-0 w-6 h-6 ml-2"
                                        />
                                        <div v-if="manga.status === 'sending'" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded">
                                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                                        </div>
                                        </div>
                                    </div>
                                </fieldset>                                                                    
                                <p v-if="selectedEpisode && selectedEpisode.EpisodeSeason !== ''" class="mb-2 text-lg">
                                    <span>ÿßŸÑŸÖŸàÿ≥ŸÖ: </span>{{ selectedEpisode.EpisodeSeason }}
                                    <span class="opacity-80">(</span>
                                    <span v-if="seasonCountParts.numberText" class="text-yellow-300 font-black pl-1">{{ seasonCountParts.numberText }}</span>
                                    <span class="opacity-80">{{ seasonCountParts.suffixText }}</span>
                                    <span class="opacity-80">)</span>
                                </p>

                                <p v-if="selectedEpisode && selectedEpisode.EpisodeBCDate !== ''" class="mb-2 text-lg">
                                    <span dir="ltr">:ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿπÿ±ÿ∂</span> {{ selectedEpisode.EpisodeBCDate }} <span v-if="hasCountdown" @click="toggleCountdownLanguage" class="text-orange-300 text-sm cursor-pointer transition-all duration-100 active:scale-90">({{ showEnglishCountdown ? countdownEnglish : countdownArabic }})</span>
                                </p>

                                <p v-if="selectedEpisode && selectedEpisode.EpisodeRRDate !== ''" class="mb-2 text-lg">
                                    <span dir="ltr">:ÿ™ÿßÿ±ŸäÿÆ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿπÿ±ÿ∂</span> {{ selectedEpisode.EpisodeRRDate }}
                                </p>

                                <p v-if="selectedEpisode && selectedEpisode.EpisodeRMDate !== ''" class="mb-2 text-lg">
                                    <span dir="ltr">:ÿ™ÿßÿ±ŸäÿÆ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨</span> {{ selectedEpisode.EpisodeRMDate }}
                                </p>

                                <p v-if="selectedEpisode && selectedEpisode.EpisodeRMDate2 !== ''" class="mb-2 text-lg">
                                    <span dir="ltr">:ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ ÿßŸÑÿ´ÿßŸÜŸä</span> {{ selectedEpisode.EpisodeRMDate2 }}
                                </p>

                                <p v-if="selectedEpisode && selectedEpisode.EpisodeEvents !== ''" class="mb-2 text-lg">
                                    <span>ÿßŸÑÿ£ÿ≠ÿØÿßÿ´ : </span>
                                    <template v-for="(char, index) in selectedEpisode.EpisodeEvents" :key="index">
                                        <template v-if="char === 'ÿ≥'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ÿßŸÑŸÖŸÜÿ∏ŸÖÿ© ÿßŸÑÿ≥ŸàÿØÿßÿ°'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-BO.png" 
                                                    alt="ÿßŸÑŸÖŸÜÿ∏ŸÖÿ© ÿßŸÑÿ≥ŸàÿØÿßÿ°" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else-if="char === 'ÿ¨'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ÿ¥ÿÆÿµŸäÿ© ÿ¨ÿØŸäÿØÿ©'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-New.png" 
                                                    alt="ÿ¥ÿÆÿµŸäÿ© ÿ¨ÿØŸäÿØÿ©" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else-if="char === 'ÿ±'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ŸÇÿµÿ© ÿ±ŸàŸÖÿßŸÜÿ≥Ÿäÿ©'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-Romance.png" 
                                                    alt="ŸÇÿµÿ© ÿ±ŸàŸÖÿßŸÜÿ≥Ÿäÿ©" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else-if="char === 'ÿ™'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ÿ™ÿ∑Ÿàÿ± ÿ¥ÿÆÿµŸäÿ©'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-Char.png" 
                                                    alt="ÿ™ÿ∑Ÿàÿ± ÿ¥ÿÆÿµŸäÿ©" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else-if="char === 'ÿ∑'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ŸÅÿ±ŸäŸÇ ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸäŸÜ ÿßŸÑÿµÿ∫ÿßÿ±'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-DB.png" 
                                                    alt="ŸÅÿ±ŸäŸÇ ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸäŸÜ ÿßŸÑÿµÿ∫ÿßÿ±" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else-if="char === 'ŸÖ'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ÿ∞ŸÉÿ±Ÿäÿßÿ™ ŸÖŸÜ ÿßŸÑŸÖÿßÿ∂Ÿä'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-Past.png" 
                                                    alt="ÿ∞ŸÉÿ±Ÿäÿßÿ™ ŸÖŸÜ ÿßŸÑŸÖÿßÿ∂Ÿä" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else-if="char === 'Ÿá'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'Ÿáÿßÿ™Ÿàÿ±Ÿä ŸáŸäÿ¨Ÿä'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/PlotHH.png" 
                                                    alt="Ÿáÿßÿ™Ÿàÿ±Ÿä ŸáŸäÿ¨Ÿä" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else-if="char === 'ŸÉ'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ŸÉÿßŸäÿ™Ÿà ŸÉŸäÿØ'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-MK.png" 
                                                    alt="ŸÉÿßŸäÿ™Ÿà ŸÉŸäÿØ" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else-if="char === 'ŸÅ'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ŸÖŸÉÿ™ÿ® ÿßŸÑÿ™ÿ≠ŸÇŸäŸÇÿßÿ™ ÿßŸÑŸÅŸäÿØÿ±ÿßŸÑŸä (FBI)'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-FBI.png" 
                                                    alt="ŸÖŸÉÿ™ÿ® ÿßŸÑÿ™ÿ≠ŸÇŸäŸÇÿßÿ™ ÿßŸÑŸÅŸäÿØÿ±ÿßŸÑŸä (FBI)" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else-if="char === 'ÿπ'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ŸÖŸÉÿ™ÿ® ÿßŸÑÿ£ŸÖŸÜ ÿßŸÑÿπÿßŸÖ (PSB)'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-PSB.png" 
                                                    alt="ŸÖŸÉÿ™ÿ® ÿßŸÑÿ£ŸÖŸÜ ÿßŸÑÿπÿßŸÖ (PSB)" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
										<template v-else-if="char === 'ŸÜ'">
                                            <div class="inline-block h-6 w-6 mr-1 transition-all duration-100 active:scale-90"
                                                v-tippy="'ŸÖŸÉÿ™ÿ® ÿßŸÑÿßÿ≥ÿ™ÿÆÿ®ÿßÿ±ÿßÿ™ ŸàÿßŸÑÿ™ÿ≠ŸÇŸäŸÇÿßÿ™ ÿßŸÑÿ™ÿßÿ®ÿπ ŸÑŸÖÿ¨ŸÑÿ≥ ÿßŸÑŸàÿ≤ÿ±ÿßÿ° (CIRO)'">
                                                <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/Plot-CIRO.png" 
                                                    alt="ŸÖŸÉÿ™ÿ® ÿßŸÑÿßÿ≥ÿ™ÿÆÿ®ÿßÿ±ÿßÿ™ ŸàÿßŸÑÿ™ÿ≠ŸÇŸäŸÇÿßÿ™ ÿßŸÑÿ™ÿßÿ®ÿπ ŸÑŸÖÿ¨ŸÑÿ≥ ÿßŸÑŸàÿ≤ÿ±ÿßÿ° (CIRO)" 
                                                    class="inline-block h-6 w-6">
                                            </div>
                                        </template>
                                        <template v-else>
                                            {{ char }}
                                        </template>
                                    </template>
                                </p>

                                <fieldset v-if="selectedEpisode && selectedEpisode.EpisodeCurrentHint !== ''" class="border p-2 rounded mb-2">
                                    <legend class="font-bold text-lg">ÿ™ŸÑŸÖŸäÿ≠ ÿßŸÑÿ≠ŸÑŸÇÿ©</legend>
                                    <p class="text-lg text-center">{{ selectedEpisode.EpisodeCurrentHint }}</p>
                                </fieldset>

                                <fieldset v-if="selectedEpisode && selectedEpisode.EpisodeStory !== ''" class="border p-2 rounded mb-2">
                                    <legend class="font-bold text-lg">ÿßŸÑŸÇÿµÿ©</legend>
                                    <p class="text-lg">{{ selectedEpisode.EpisodeStory }}</p>
                                </fieldset>

                                <fieldset v-if="selectedEpisode && selectedEpisode.EpisodeSummary !== ''" class="border p-2 border-orange-400 rounded mb-2">
                                    <legend class="font-bold cursor-pointer transition-all duration-100 active:scale-90" @click="toggleSpoiler">
                                        <span class="text-lg">
                                            <span v-html="highlightSpoilerText()"></span>
                                        </span>
                                    </legend>
                                    <p v-if="spoilerVisible" class="text-lg">{{ selectedEpisode.EpisodeSummary }}</p>
                                </fieldset>                                                    

                                <fieldset v-if="selectedEpisode && selectedEpisode.EpisodeNextHint !== ''" class="border p-2 rounded mb-2">
                                    <legend class="font-bold text-lg">ÿ™ŸÑŸÖŸäÿ≠ ÿßŸÑÿ≠ŸÑŸÇÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©</legend>
                                    <p class="text-lg text-center">{{ selectedEpisode.EpisodeNextHint }}</p>
                                </fieldset>

                                <fieldset v-if="selectedEpisode && selectedEpisode.EpisodeNotes !== ''" class="border border-red-500 p-2 rounded mb-2 episode-notes-container">
                                    <legend class="font-bold text-lg">ŸÖŸÑÿßÿ≠ÿ∏ÿ©</legend>
                                    <div class="episode-notes-container">
                                        <p class="text-lg" v-html="processEpisodeNotes(selectedEpisode.EpisodeNotes)"></p>
                                    </div>
                                </fieldset>

                                <fieldset v-if="selectedEpisode && episodeTrailers.length > 0" class="border p-2 rounded mb-2 border-purple-400">
                                    <legend class="font-bold text-lg px-2 text-center">
                                        {{ trailerModalTitleText }}
                                    </legend>
                                    <button
                                        @click="openTrailerModal"
                                        class="w-full bg-purple-600 text-white px-6 py-2 rounded hover:bg-purple-700 flex items-center justify-center shadow-md transition-all duration-100 active:scale-90"
                                    >
                                        {{ trailerMainButtonText }}
                                    </button>
                                </fieldset>

                                <fieldset v-if="selectedEpisode && Array.isArray(selectedEpisode.EpisodeVideosIDs) && selectedEpisode.EpisodeVideosIDs.length > 0" class="border p-2 rounded mb-4">
                                    <legend class="font-bold text-lg">ŸÖÿ¥ÿßŸáÿØÿ© (ÿπÿ®ÿ± ÿßŸÑÿ®Ÿàÿ™)</legend>
                                    <div class="flex flex-col gap-4">
                                        <!-- Videos without metadata (rendered directly under main legend) -->
                                        <template v-for="group in groupedVideos">
                                            <template v-if="!group.hasMetadata">
                                                <!-- No metadata group - render directly under main legend -->
                                                <div v-for="(video, index) in group.videos" :key="`no-md-${video.VideoID}`" class="relative">
                                                    <div class="relative w-full">
                                                        <!-- The Button -->
                                                        <button
                                                            :disabled="video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending'"
                                                            @click="() => { sendEpisodeToBot(video.VideoID, video.Resolution, video.Size, video.originalIndex, video.IntroductionTime, video.StartStoryTime, video.EpisodeSuspenseTime, video.StartSongTime, video.ChapterOneTime, video.ChapterTwoTime, video.EndSongTime, video.ChapterThreeTime, video.NextEpisodeTeaserTime, video.NextEpisodeHintTime); }"
                                                            class="w-full bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-700 flex items-center justify-center shadow-md disabled:opacity-50 transition-all duration-100 active:scale-90 disabled:cursor-not-allowed relative overflow-hidden">
                                                            <span v-if="video.status === 'ratelimiting'">{{ video.Resolution }} ({{ formatFileSize(video.Size) }})</span>
                                                            <span v-else-if="video.countdown !== undefined">{{ video.countdown }}</span>
                                                            <span v-else>{{ video.Resolution }} ({{ formatFileSize(video.Size) }})</span>
                                                        </button>

                                                        <!-- Status Images (Pinned to Top Right of the Button area) -->
                                                        <img 
                                                            v-if="video.status === 'success'" 
                                                            src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/true.png" 
                                                            class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none"
                                                        />
                                                        <img 
                                                            v-else-if="video.status === 'error'" 
                                                            src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/close.png" 
                                                            class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none"
                                                        />

                                                        <!-- Sending Overlay (Centered over the Button only) -->
                                                        <div v-if="video.status === 'sending'" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded z-20">
                                                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </template>
                                            <div v-else :key="group.key" class="relative">
                                                <fieldset class="rounded relative border p-2">
                                                    <!-- Group Legend -->
                                                    <legend class="px-1 text-sm">
                                                        <span v-if="group.EpisodeCategory">
                                                            {{ group.EpisodeCategory === 'S' ? 'ŸÖÿ™ÿ±ÿ¨ŸÖ' : (group.EpisodeCategory === 'D' ? 'ŸÖÿØÿ®ŸÑÿ¨' : group.EpisodeCategory) }}
                                                        </span>
                                                        <span v-if="group.EpisodeTranslator">
                                                            <span v-if="group.EpisodeCategory"> - </span>{{ group.EpisodeTranslator }}<span v-if="isProfessionalTranslator(group.EpisodeTranslator)" v-tippy="'ÿ™ÿ±ÿ¨ŸÖÿ© ÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ©'"> ‚≠ê</span>
                                                        </span>
                                                        <span v-if="group.EpisodeRemastered">
                                                            <span v-if="group.EpisodeCategory || group.EpisodeTranslator"> - </span>
                                                            {{ group.EpisodeRemastered === 'TP' ? 'ŸÖÿ≠ÿ≥ŸÜÿ© ŸàÿÆÿßÿµÿ©' : (group.EpisodeRemastered === 'FP' ? 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿ≥ŸÜÿ© ŸàÿÆÿßÿµÿ©' : (group.EpisodeRemastered === 'P' ? 'ÿ≠ŸÑŸÇÿ© ÿÆÿßÿµÿ©' : (group.EpisodeRemastered === 'T' ? 'ŸÖÿ≠ÿ≥ŸÜÿ©' : (group.EpisodeRemastered === 'F' ? 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿ≥ŸÜÿ©' : group.EpisodeRemastered)))) }}
                                                        </span>
                                                    </legend>
                                                    
                                                    <!-- Video buttons for this group -->
                                                    <div class="grid grid-cols-1 gap-2 mt-2">
                                                        <div v-for="(video, index) in group.videos" :key="video.VideoID" class="relative">
                                                            <div class="relative w-full">
                                                                <!-- The Button -->
                                                                <button
                                                                    :disabled="video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending'"
                                                                    @click="() => { sendEpisodeToBot(video.VideoID, video.Resolution, video.Size, video.originalIndex, video.IntroductionTime, video.StartStoryTime, video.EpisodeSuspenseTime, video.StartSongTime, video.ChapterOneTime, video.ChapterTwoTime, video.EndSongTime, video.ChapterThreeTime, video.NextEpisodeTeaserTime, video.NextEpisodeHintTime); }"
                                                                    class="w-full bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-700 flex items-center justify-center shadow-md disabled:opacity-50 transition-all duration-100 active:scale-90 disabled:cursor-not-allowed relative overflow-hidden">
                                                                    <span v-if="video.status === 'ratelimiting'">{{ video.Resolution }} ({{ formatFileSize(video.Size) }})</span>
                                                                    <span v-else-if="video.countdown !== undefined">{{ video.countdown }}</span>
                                                                    <span v-else>{{ video.Resolution }} ({{ formatFileSize(video.Size) }})</span>
                                                                </button>

                                                                <!-- Status Images (Pinned to Top Right of the Button area) -->
                                                                <img 
                                                                    v-if="video.status === 'success'" 
                                                                    src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/true.png" 
                                                                    class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none"
                                                                />
                                                                <img 
                                                                    v-else-if="video.status === 'error'" 
                                                                    src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/close.png" 
                                                                    class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none"
                                                                />

                                                                <!-- Sending Overlay (Centered over the Button only) -->
                                                                <div v-if="video.status === 'sending'" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded z-20">
                                                                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </fieldset>
                                            </div>
                                        </template>
                                    </div>
                                </fieldset>
                            </div>
                            <div
                                v-if="!preserveSelectedEpisodeOnModalClose"
                                class="sticky bottom-1 bg-cyan-900 py-1 z-30"
                            >
                                <div class="w-full flex items-center justify-center gap-3 sm:gap-8">
                                    <div class="flex items-center gap-4 sm:gap-8">
                                        <!-- Next Episode Button -->
                                        <button 
                                            v-if="selectedEpisode.EpisodeParts" 
                                            :disabled="!nextEpisodeExists || selectedEpisode.EpisodeVideosIDs?.some(video => video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending') || selectedEpisode.EpisodeMangasIDs?.some(manga => manga.status === 'success' || manga.status === 'ratelimiting' || manga.status === 'sending')" 
                                            @click="fetchNextEpisode(); resetStatusForEpisodeManga();" 
                                            class="disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90"
                                        >
                                            <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/next.png" alt="ÿßŸÑÿ™ÿßŸÑŸä" class="h-8 w-8" />
                                        </button>
                                        <button
                                            :disabled="!hasNextFilteredEpisode || selectedEpisode.EpisodeVideosIDs?.some(video => video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending') || selectedEpisode.EpisodeMangasIDs?.some(manga => manga.status === 'success' || manga.status === 'ratelimiting' || manga.status === 'sending')" 
                                            @click="fetchNextEpisodeByNumber(); resetStatusForEpisodeManga();" 
                                            class="rounded-full p-2 md:p-3 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90"
                                        >
                                            <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/next-tb.png" alt="ÿßŸÑÿ™ÿßŸÑŸä" class="h-8 w-8" />
                                        </button>
                                    </div>

                                    <button 
                                        @click="openComments('modal')" 
                                        class="group relative flex items-center gap-2 px-5 py-2 bg-gradient-to-r from-cyan-600 text-white rounded-full shadow-lg hover:shadow-cyan-500/50 hover:scale-105 active:scale-95 transition-all duration-300 border border-cyan-400/30 overflow-hidden"
                                    >
                                        <div class="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300 ease-out"></div>
                                        <span class="font-bold text-base relative z-10 drop-shadow-md">ÿßŸÑÿ™ÿπŸÑŸäŸÇÿßÿ™</span>
                                    </button>

                                    <div class="flex items-center gap-4 sm:gap-8">
                                        <button
                                            :disabled="!hasPreviousFilteredEpisode || selectedEpisode.EpisodeVideosIDs?.some(video => video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending') || selectedEpisode.EpisodeMangasIDs?.some(manga => manga.status === 'success' || manga.status === 'ratelimiting' || manga.status === 'sending')" 
                                            @click="fetchPreviousEpisodeByNumber(); resetStatusForEpisodeManga();" 
                                            class="rounded-full p-2 md:p-3 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90"
                                        >
                                            <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/previous-tb.png" alt="ÿßŸÑÿ≥ÿßÿ®ŸÇ" class="h-8 w-8" />
                                        </button>
                                        <!-- Previous Episode Button -->
                                        <button 
                                            v-if="selectedEpisode.EpisodeParts" 
                                            :disabled="!previousEpisodeExists || selectedEpisode.EpisodeVideosIDs?.some(video => video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending') || selectedEpisode.EpisodeMangasIDs?.some(manga => manga.status === 'success' || manga.status === 'ratelimiting' || manga.status === 'sending')" 
                                            @click="fetchPreviousEpisode(); resetStatusForEpisodeManga();" 
                                            class="disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-100 active:scale-90"
                                        >
                                            <img src="https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/previous.png" alt="ÿßŸÑÿ≥ÿßÿ®ŸÇ" class="h-8 w-8" />
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div v-if="showTrailerModal" class="fixed z-[90] inset-0 overflow-y-auto bg-black bg-opacity-80 flex items-center justify-center" @click.self="closeTrailerModal">
                        <div class="relative bg-slate-950 text-slate-200 font-bold rounded-lg w-11/12 md:w-3/4 lg:w-1/2 max-h-[95vh] overflow-hidden flex flex-col border border-cyan-800">
                            <div class="sticky top-0 bg-slate-950 p-4 flex items-center justify-end border-b border-cyan-900 relative">
                                <div class="text-lg text-center w-full absolute left-1/2 -translate-x-1/2 pointer-events-none">
                                    {{ trailerModalTitleText }}
                                </div>
                                <button @click="closeTrailerModal" class="text-red-500 hover:text-yellow-300 transition-all duration-100 active:scale-90">
                                    <span class="text-2xl font-black">‚úï</span>
                                </button>
                            </div>

                            <div class="overflow-y-auto p-4 flex-1 always-visible-scrollbar">
                                <div v-if="groupedTrailers.length > 1" class="flex flex-wrap justify-center gap-2 mb-4 text-center">
                                    <button
                                        v-for="group in groupedTrailers"
                                        :key="group.key"
                                        @click="selectTrailerGroup(group.key)"
                                        :class="[
                                            'px-3 py-2 rounded font-bold transition-all duration-100 active:scale-90',
                                            selectedTrailerGroupKey === group.key ? 'bg-orange-500 text-black' : 'bg-gray-800 text-slate-200 hover:bg-gray-700'
                                        ]"
                                    >
                                        {{ group.label }}
                                    </button>
                                </div>

                                <div v-if="shouldShowTrailerProviderButtons" class="flex flex-wrap justify-center gap-2 mb-4 text-center">
                                    <button
                                        v-for="p in activeTrailerProviders"
                                        :key="p.key"
                                        @click="selectTrailerProvider(p.key)"
                                        :class="[
                                            'px-4 py-2 rounded font-bold transition-all duration-100 active:scale-90',
                                            selectedTrailerProviderKey === p.key
                                                ? 'bg-blue-600 text-white'
                                                : 'bg-blue-900 text-slate-100 hover:bg-blue-800'
                                        ]"
                                    >
                                        {{ p.label }}
                                    </button>
                                </div>

                                <div v-if="isActiveTrailerProviderTelegram" class="flex flex-col gap-2 mb-4">
                                    <div
                                        v-for="t in activeTrailerProviderTrailers"
                                        :key="`${t.TrailerID || ''}-${t.Resolution || ''}-${t.Size || ''}`"
                                        class="relative"
                                    >
                                        <button
                                            :disabled="t.status === 'success' || t.status === 'ratelimiting' || t.status === 'sending'"
                                            @click="sendTrailerWrapper(t)"
                                            class="w-full bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 flex items-center justify-center shadow-md disabled:opacity-50 transition-all duration-100 active:scale-90 disabled:cursor-not-allowed relative overflow-hidden"
                                        >
                                            <span v-if="t.status === 'ratelimiting'">{{ t.Resolution }} ({{ formatFileSize(t.Size) }})</span>
                                            <span v-else-if="t.countdown !== undefined">{{ t.countdown }}</span>
                                            <span v-else>{{ t.Resolution }} ({{ formatFileSize(t.Size) }})</span>
                                        </button>
                                        <img
                                            v-if="t.status === 'success'"
                                            src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/true.png"
                                            class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none"
                                        />
                                        <img
                                            v-else-if="t.status === 'error'"
                                            src="https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/close.png"
                                            class="absolute right-0 top-0 w-6 h-6 z-10 pointer-events-none"
                                        />
                                        <div v-if="t.status === 'sending'" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded z-20">
                                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                                        </div>
                                    </div>
                                </div>

                                <div v-else-if="trailerIframeSrc" class="w-full">
                                    <div class="w-full h-[60vh] rounded relative overflow-hidden bg-black/20">
                                        <div v-if="isTrailerIframeLoading" class="absolute inset-0 flex items-center justify-center">
                                            <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-white"></div>
                                        </div>
                                        <iframe
                                            :key="trailerIframeKey"
                                            :src="trailerIframeSrc"
                                            class="w-full h-full rounded"
                                            frameborder="0"
                                            allow="autoplay; fullscreen; picture-in-picture"
                                            allowfullscreen
                                            webkitallowfullscreen
                                            mozallowfullscreen
                                            v-show="!isTrailerIframeLoading"
                                            @load="handleTrailerIframeLoad"
                                            @error="handleTrailerIframeError"
                                        ></iframe>
                                    </div>
                                    <button
                                        v-if="trailerExternalUrl"
                                        @click="openTrailerInBrowser"
                                        class="w-full mt-3 bg-gray-700 text-white px-6 py-2 rounded hover:bg-gray-600 flex items-center justify-center shadow-md transition-all duration-100 active:scale-90"
                                    >
                                        ŸÅÿ™ÿ≠ ÿßŸÑÿ•ÿπŸÑÿßŸÜ ŸÅŸä ÿßŸÑŸÖÿ™ÿµŸÅÿ≠
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
            </table>

            <!-- Pagination Controls -->
            <div class="flex justify-between items-center mt-4">

                <button @click="nextPage" 
                        :disabled="currentPage === totalPages"
                        class="bg-blue-700 text-white font-bold px-4 py-2 rounded 
                            hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed 
                            transition-all duration-100 active:bg-blue-800 active:scale-90">
                    ÿßŸÑÿ™ÿßŸÑŸä
                </button>

                <div class="flex items-center gap-2 text-white font-bold">
                    <!-- <span>ÿµŸÅÿ≠ÿ©</span> -->
                    <select v-model="currentPage" 
                            @change="handlePageSelect" 
                            :disabled="isCapturingEpisodeTableImages" 
                            @mousedown="guardEventIfCapturing($event)" 
                            @click="guardEventIfCapturing($event)"
                            class="w-24 px-2 py-2 rounded border border-gray-500 bg-gray-800 text-center font-bold">
                        <option v-for="page in totalPages" :key="page" :value="page">
                            {{ page }}
                        </option>
                    </select>
                    <!-- <span>ŸÖŸÜ {{ totalPages }}</span> -->
                </div>

                <button @click="prevPage" 
                        :disabled="currentPage === 1"
                        class="bg-blue-700 text-white font-bold px-4 py-2 rounded 
                            hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed
                            transition-all duration-100 active:bg-blue-800 active:scale-90">
                    ÿßŸÑÿ≥ÿßÿ®ŸÇ
                </button>
            </div>

            <div class="text-center font-bold justify-center my-4">
                <span>{{ displayCurrentPage }}/{{ totalPages }}</span>
            </div>

            <!-- Page Size Controls (Right) -->
            <div class="text-center font-bold justify-center">
                <label class="inline-flex items-center mx-1 transition-all duration-100 active:scale-90">
                    <input type="radio" v-model="pageSize" :value="5" class="form-radio text-blue-500 mx-1" />
                    <span class="ml-2">5</span>
                </label>
                <label class="inline-flex items-center mx-1 transition-all duration-100 active:scale-90">
                    <input type="radio" v-model="pageSize" :value="10" class="form-radio text-blue-500 mx-1" />
                    <span class="ml-2">10</span>
                </label>
                <label class="inline-flex items-center mx-1 transition-all duration-100 active:scale-90">
                    <input type="radio" v-model="pageSize" :value="15" class="form-radio text-blue-500 mx-1" />
                    <span class="ml-2">15</span>
                </label>
                <label class="inline-flex items-center mx-1 transition-all duration-100 active:scale-90">
                    <input type="radio" v-model="pageSize" :value="20" class="form-radio text-blue-500 mx-1" />
                    <span class="ml-2">20</span>
                </label>
                <label class="inline-flex items-center mx-1 transition-all duration-100 active:scale-90">
                    <input type="radio" v-model="pageSize" :value="25" class="form-radio text-blue-500 mx-1" />
                    <span class="ml-2">25</span>
                </label>
            </div>
        </div>
        <!-- mainCommentPage -->
        <div class="w-full flex justify-center pt-10" v-if="!loading && userJoined">
             <button
                 @click="openComments('main')"
                 class="group relative flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-cyan-600 to-blue-600 text-white rounded-full shadow-lg hover:shadow-cyan-500/50 hover:scale-105 active:scale-95 transition-all duration-300 border border-cyan-400/30 overflow-hidden"
             >
                 <div class="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300 ease-out"></div>
                 <span class="font-bold text-sm relative z-10 drop-shadow-md">ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</span>
             </button>
        </div>

        <!-- Global Comnto Widget (Singleton) -->
        <div
            v-if="comntoVisible"
            class="fixed inset-0 z-[99] bg-transparent"
            @wheel.prevent
            @touchmove.prevent
            @scroll.prevent
            @click.stop
        ></div>
        <div v-show="comntoVisible" class="fixed bottom-0 left-0 right-0 z-[100] transition-transform duration-300 ease-in-out" :class="comntoVisible ? 'translate-y-0' : 'translate-y-full'">
             <div
                 class="mx-auto h-[90vh] rounded-t-xl overflow-hidden shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)] border-t border-gray-700 dark:border-gray-700 bg-gray-800 dark:bg-gray-800 flex flex-col"
                 :class="comntoContext === 'main' ? 'w-full sm:w-[80%] md:w-[70%] lg:w-[60%] max-w-screen-lg' : 'w-[100%] sm:w-[80%] md:w-[70%] lg:w-[60%]'"
             >
                 <div class="flex justify-between items-center p-3 bg-gray-900 dark:bg-gray-900 border-b border-gray-700 dark:border-gray-700">
                     <h3 class="font-bold text-yellow-300 dark:text-yellow-300">{{ commentsHeaderText }}</h3>
                     <button @click="comntoVisible = false" class="text-gray-500 hover:text-red-500">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="red">
                             <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                         </svg>
                     </button>
                 </div>
                 <div class="flex-1 overflow-y-auto bg-gray-800 dark:bg-gray-800 p-2">
                      <div id="comments" class="w-full" :data-topic="comntoTopic"></div>
                 </div>
             </div>
        </div>
    </div>

    <script>
        const webApp = window.Telegram?.WebApp || null;
        const { createApp, markRaw } = Vue;
        const WEB_APP_URL = "https://euz.pages.dev/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/";

        const DIRECT_WINDOW_CONFIG = [
            { 
                key: 'episodes', 
                label: 'ÿ≠ŸÑŸÇÿßÿ™',
                gridButtonClass: 'bg-blue-500 text-white p-2 rounded hover:bg-green-500',
                actionButtonClass: 'bg-blue-500 text-white px-6 py-2 rounded hover:bg-green-500'
            },
            { 
                key: 'movies', 
                label: 'ÿ£ŸÅŸÑÿßŸÖ',
                gridButtonClass: 'bg-amber-700 text-white p-2 rounded hover:bg-green-500',
                actionButtonClass: 'bg-amber-700 text-white px-6 py-2 rounded hover:bg-green-500'
            },
            { 
                key: 'mangas', 
                label: 'ŸÖÿßŸÜÿ∫ÿß',
                gridButtonClass: 'bg-green-500 text-white p-2 rounded hover:bg-blue-500',
                actionButtonClass: 'bg-green-500 text-white px-6 py-2 rounded hover:bg-blue-500'
            }
        ];

        const FILTER_UI = {
            categoryOptions: [
                { value: 'all', label: 'ÿßŸÑŸÉŸÑ', countKey: 'episodeTypeAllCount' },
                { value: 'anime', label: 'ÿ≠ŸÑŸÇÿßÿ™', countKey: 'episodeTypeAnimeCount' },
                { value: 'movies', label: 'ÿ£ŸÅŸÑÿßŸÖ', countKey: 'episodeTypeMovieCount' },
                { value: 'hourly_special', label: 'ÿÆÿßÿµÿ© \"ÿ≥ÿßÿπÿ©\"', countKey: 'episodeTypeHourlySpecialCount' },
                { value: 'two_hour_special', label: 'ÿÆÿßÿµÿ© \"ÿ≥ÿßÿπÿ™ŸäŸÜ\"', countKey: 'episodeTypeTwoHourSpecialCount' },
                { value: 'short_story', label: 'ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©', countKey: 'episodeTypeShortStoryCount' },
                { value: 'ova', label: 'ÿ£ŸàŸÅÿß', countKey: 'episodeTypeOVA' },
                { value: 'movie_special', label: 'ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ', countKey: 'episodeTypeMovieSpecial' },
                { value: 'special_release', label: 'ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ', countKey: 'episodeTypeSpecialRelease' },
                { value: 'magic_kaito', label: 'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà', countKey: 'episodeTypeMagicKaito' },
                { value: 'zero_diaries', label: 'ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà', countKey: 'episodeTypeZeroDiaries' },
                { value: 'criminal_hanzawa', label: 'ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß', countKey: 'episodeTypeHanazawa' },
            ],
            episodeTypeOptions: [
                { value: 'All', label: 'ÿßŸÑŸÉŸÑ', countKey: 'episodeTypeAllCount' },
                { value: 'Manga', label: 'ŸÖÿßŸÜÿ∫ÿß', countKey: 'episodeTypeMangaCount' },
                { value: 'Filler', label: 'ŸÅŸêŸÑÿ±', countKey: 'episodeTypeFillerCount' },
            ],
            groupOptions: [
                { modelKey: 'filterBlackOrganization', label: 'ÿßŸÑŸÖŸÜÿ∏ŸÖÿ© ÿßŸÑÿ≥ŸàÿØÿßÿ°', countKey: 'blackOrganizationCount' },
                { modelKey: 'filterDetectiveBoys', label: 'ŸÅÿ±ŸäŸÇ ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸäŸÜ ÿßŸÑÿµÿ∫ÿßÿ±', countKey: 'detectiveBoysCount' },
                { modelKey: 'filterFBI', label: 'ŸÖŸÉÿ™ÿ® ÿßŸÑÿ™ÿ≠ŸÇŸäŸÇÿßÿ™ ÿßŸÑŸÅŸäÿØÿ±ÿßŸÑŸä', countKey: 'FBICount' },
                { modelKey: 'filterPSB', label: 'ŸÖŸÉÿ™ÿ® ÿßŸÑÿ£ŸÖŸÜ ÿßŸÑÿπÿßŸÖ', countKey: 'PSBCount' },
                { modelKey: 'filterPoliceAcademy', label: 'ÿ£ŸÉÿßÿØŸäŸÖŸäÿ© ÿßŸÑÿ¥ÿ±ÿ∑ÿ©', countKey: 'policeAcademyCount' },
            ],
            sceneOptions: [
                { modelKey: 'filterScaryEpisodes', label: 'ŸÖÿ±ÿπÿ®', countKey: 'ScaryEpisodesCount' },
                { modelKey: 'filterSadyEpisodes', label: 'ÿ≠ÿ≤ŸäŸÜ', countKey: 'SadyEpisodesCount' },
                { modelKey: 'filterRomanceEpisodes', label: 'ÿ±ŸàŸÖÿßŸÜÿ≥Ÿä', countKey: 'RomanceEpisodesCount' },
                { modelKey: 'filterNewCharacter', label: 'ÿ¥ÿÆÿµŸäÿ© ÿ¨ÿØŸäÿØÿ©', countKey: 'NewCharacterEpisodesCount' },
                { modelKey: 'filterDevelopmentCharacter', label: 'ÿ™ÿ∑Ÿàÿ± ÿßŸÑÿ¥ÿÆÿµŸäÿ©', countKey: 'DevelopmentCharacterEpisodesCount' },
                { modelKey: 'filterFlashBackEpisodes', label: 'ÿ∞ŸÉÿ±Ÿäÿßÿ™ ŸÖŸÜ ÿßŸÑŸÖÿßÿ∂Ÿä', countKey: 'FlashBackEpisodesCount' },
            ],
            sections: [
                { kind: 'basic', title: 'ÿ≠ÿ≥ÿ® ÿßŸÑÿ™ÿµŸÜŸäŸÅ', optionsKey: 'categoryOptions', inputType: 'radio', modelKey: 'selectedFilter' },
                { kind: 'basic', title: 'ÿ≠ÿ≥ÿ® ÿßŸÑŸÜŸàÿπ', optionsKey: 'episodeTypeOptions', inputType: 'radio', modelKey: 'episodeTypeFilter' },
                { kind: 'basic', title: 'ÿ≠ÿ≥ÿ® ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©', optionsKey: 'groupOptions', inputType: 'checkbox' },
                { kind: 'basic', title: 'ÿ≠ÿ≥ÿ® ÿßŸÑŸÖÿ¥ŸáÿØ', optionsKey: 'sceneOptions', inputType: 'checkbox' },
                { kind: 'characters', title: 'ÿ≠ÿ≥ÿ® ÿßŸÑÿ¥ÿÆÿµŸäÿ©' },
            ],
            logicOptions: [
                { value: 'All', label: 'ÿØŸÖÿ¨' },
                { value: 'Some', label: 'ŸÖÿ¥ÿ™ÿ±ŸÉ' },
            ],
            detailOptions: [
                { kind: 'SceneEpisodes', label: 'ŸÖÿ¥ŸáÿØ' },
                { kind: 'BackgroundEpisodes', label: 'ÿÆŸÑŸÅŸäÿ©' },
                { kind: 'FlashbackEpisodes', label: 'ÿ≠ÿØÿ´ ŸÅŸä ÿßŸÑŸÖÿßÿ∂Ÿä' },
                { kind: 'OtherEpisodes', label: 'ÿ£ÿÆÿ±Ÿâ' },
            ],
            detailCodeSuffixByKind: {
                SceneEpisodes: '1',
                BackgroundEpisodes: '2',
                FlashbackEpisodes: '3',
                OtherEpisodes: '4',
            },
            characterSimpleIds: ['ConanEdogawa', 'RanMouri', 'KogoroMouri'],
            characterLabels: {
                "ShinichiKudo": "ŸÉŸàÿØŸà ÿ¥ŸäŸÜÿ™ÿ¥Ÿä",
                "ConanEdogawa": "ÿ•ÿØŸàÿ∫ÿßŸàÿß ŸÉŸàŸÜÿßŸÜ",
                "RanMouri": "ŸÖŸàÿ±Ÿä ÿ±ÿßŸÜ",
                "KogoroMouri": "ŸÖŸàÿ±Ÿä ŸÉŸàÿ∫Ÿàÿ±Ÿà",
                "AyumiYoshida": "ŸäŸàÿ¥ŸäÿØÿß ÿ£ŸäŸàŸÖŸä",
                "MitsuhikoTsuburaya": "ÿ™ÿ≥Ÿàÿ®Ÿàÿ±ÿßŸäÿß ŸÖŸäÿ™ÿ≥ŸàŸáŸäŸÉŸà",
                "GentaKojima": "ŸÉŸàÿ¨ŸäŸÖÿß ÿ¨ŸäŸÜÿ™ÿß",
                "AiHaibara": "ŸáÿßŸäÿ®ÿ±ÿß ÿ¢Ÿä",
                "HiroshiAgasa": "ÿ£ÿ∫ÿßÿ≥ÿß ŸáŸäÿ±Ÿàÿ¥Ÿä",
                "SonokoSuzuki": "ÿ≥Ÿàÿ≤ŸàŸÉŸä ÿ≥ŸàŸÜŸàŸÉŸà",
                "EriKisaki": "ŸÉŸäÿ≥ÿßŸÉŸä ÿ•Ÿäÿ±Ÿä",
                "YusakuKudo": "ŸÉŸàÿØŸà ŸäŸàÿ≥ÿßŸÉŸà",
                "YukikoKudo": "ŸÉŸàÿØŸà ŸäŸàŸÉŸäŸÉŸà",
                "HeijiHattori": "Ÿáÿßÿ™Ÿàÿ±Ÿä ŸáŸäÿ¨Ÿä",
                "KazuhaToyama": "ÿ™ŸàŸäÿßŸÖÿß ŸÉÿßÿ≤ŸàŸáÿß",
                "YokoOkino": "ÿ£ŸàŸÉŸäŸÜŸà ŸäŸàŸÉŸà",
                "SumikoKobayashi": "ŸÉŸàÿ®ÿßŸäÿßÿ¥Ÿä ÿ≥ŸàŸÖŸäŸÉŸà",
                "TomoakiAraide": "ÿ£ÿ±ÿßŸäÿØŸä ÿ™ŸàŸÖŸàÿßŸÉŸä",
                "MakotoKyogoku": "ŸÉŸäŸàÿ∫ŸàŸÉŸà ŸÖÿßŸÉŸàÿ™Ÿà",
                "ShizukaHattori": "Ÿáÿßÿ™Ÿàÿ±Ÿä ÿ¥Ÿäÿ≤ŸàŸÉÿß",
                "JirokichiSuzuki": "ÿ≥Ÿàÿ≤ŸàŸÉŸä ÿ¨Ÿäÿ±ŸàŸÉŸäÿ¥Ÿä",
                "EisukeHondou": "ŸáŸàŸÜÿØŸà ÿ•Ÿäÿ≥ŸàŸÉŸä",
                "AzusaEnomoto": "ÿ•ŸäŸÜŸàŸÖŸàÿ™Ÿà ÿ£ÿ≤Ÿàÿ≥ÿß",
                "SubaruOkiya": "ÿ£ŸàŸÉŸäÿß ÿ≥Ÿàÿ®ÿßÿ±Ÿà",
                "MasumiSera": "ÿ≥Ÿäÿ±ÿß ŸÖÿßÿ≥ŸàŸÖŸä",
                "ShukichiHaneda": "ŸáÿßŸÜŸäÿØÿß ÿ¥ŸàŸÉŸäÿ™ÿ¥Ÿä",
                "SakurakoYonehara": "ŸäŸàŸÜŸáÿßÿ±ÿß ÿ≥ÿßŸÉŸàÿ±ÿßŸÉŸà",
                "MomijiOoka": "ÿ£ŸàŸÉÿß ŸÖŸàŸÖŸäÿ¨Ÿä",
                "RumiWakasa": "ŸàÿßŸÉÿßÿ≥ÿß ÿ±ŸàŸÖŸä",
                "MugaLori": "ÿ•ŸäŸàÿ±Ÿä ŸÖŸàÿ∫ÿß",
                "JuzoMegure": "ŸÖŸäÿ∫Ÿàÿ±Ÿä ÿ∫Ÿàÿ≤Ÿà",
                "NinzaburoShiratori": "ÿ¥Ÿäÿ±ÿßÿ™Ÿàÿ±Ÿä ŸÜŸäÿ≤ÿßÿ®Ÿàÿ±Ÿà",
                "MiwakoSato": "ÿ≥ÿßÿ™Ÿà ŸÖŸäŸàÿßŸÉŸà",
                "WataruTakagi": "ÿ™ÿßŸÉÿßÿ¨Ÿä Ÿàÿßÿ™ÿßÿ±Ÿà",
                "KazunobuChiba": "ÿ™ÿ¥Ÿäÿ®ÿß ŸÉÿßÿ≤ŸàŸÜŸàÿ®Ÿà",
                "YumiMiyamoto": "ŸÖŸäÿßŸÖŸàÿ™Ÿà ŸäŸàŸÖŸä",
                "NaekoMiike": "ŸÖŸäŸÉŸä ŸÜÿßŸäŸÉŸà",
                "KiyonagaMatsumoto": "ŸÖÿßÿ™ÿ≥ŸàŸÖŸàÿ™Ÿà ŸÉŸäŸàŸÜÿßÿ∫ÿß",
                "InspectorYuminaga": "ÿßŸÑŸÖŸÅÿ™ÿ¥ ŸäŸàŸÖŸäŸÜÿßÿ∫ÿß",
                "ShintaroChaki": "ÿ™ÿ¥ÿßŸÉŸä ÿ¥ŸäŸÜÿ™ÿßÿ±Ÿà",
                "HyoueKuroda": "ŸÉŸàÿ±ŸàÿØÿß ŸáŸäŸàŸä",
                "JinpeiMatsuda": "ŸÖÿßÿ™ÿ≥ŸàÿØÿß ÿ¨ŸäŸÜÿ®Ÿä",
                "KenjiHagiwara": "Ÿáÿßÿ∫ŸäŸàÿßÿ±ÿß ŸÉŸäŸÜÿ¨Ÿä",
                "WataruDate": "ÿØÿßÿ™Ÿä Ÿàÿßÿ™ÿßÿ±Ÿà",
                "HeizoHattori": "Ÿáÿßÿ™Ÿàÿ±Ÿä ŸáŸäÿ≤Ÿà",
                "GinshiroToyama": "ÿ™ŸàŸäÿßŸÖÿß ÿ¨ŸäŸÜÿ¥Ÿäÿ±Ÿà",
                "GoroOtaki": "ÿ£Ÿàÿ™ÿßŸÉŸä ÿ∫Ÿàÿ±Ÿà",
                "KansukeYamato": "ŸäÿßŸÖÿßÿ™Ÿà ŸÉÿßŸÜÿ≥ŸàŸÉŸä",
                "YuiUehara": "ÿ£ŸàŸäŸáÿßÿ±ÿß ŸäŸàŸä",
                "TakaakiMorofushi": "ŸÖŸàÿ±ŸàŸÅŸàÿ¥Ÿä ÿ™ÿßŸÉÿßŸÉŸä",
                "SangoYokomizo": "ŸäŸàŸÉŸàŸÖŸäÿ≤Ÿà ÿ≥ÿßŸÜÿ¨Ÿà",
                "MisaoYamamura": "ŸäÿßŸÖÿßŸÖŸàÿ±ÿß ŸÖŸäÿ≥ÿßŸà",
                "JugoYokomizo": "ŸäŸàŸÉŸàŸÖŸäÿ≤Ÿà ÿ¨Ÿàÿ∫Ÿà",
                "ChihayaHagiwara": "Ÿáÿßÿ∫ŸäŸàÿßÿ±ÿß ÿ™ÿ¥ŸäŸáÿßŸäÿß",
                "FumimaroAyanokoji": "ÿ£ŸäÿßŸÜŸäŸÉŸàÿ¨Ÿä ŸÅŸàŸÖŸäŸÖÿßÿ±Ÿà",
                "ReiFuruya": "ŸÅŸàÿ±ŸàŸäÿß ÿ±Ÿä",
                "HiromitsuMorofushi": "ŸÖŸàÿ±ŸàŸÅŸàÿ¥Ÿä ŸáŸäÿ±ŸàŸÖŸäÿ™ÿ≥Ÿà",
                "YuyaKazami": "ŸÉÿßÿ≤ÿßŸÖŸä ŸäŸàŸäÿß",
                "ShuichiAkai": "ÿ£ŸÉÿßŸä ÿ¥ŸàŸäÿ™ÿ¥Ÿä",
                "JodieStarling": "ÿ≥ÿ™ÿßÿ±ŸÑŸäŸÜÿ∫ ÿ¨ŸàÿØŸä",
                "JamesBlack": "ÿ®ŸÑÿßŸÉ ÿ¨ŸäŸÖÿ≥",
                "AndreCamel": "ŸÉÿßŸÖŸäŸÑ ÿ£ŸÜÿØÿ±ŸäŸá",
                "HidemiHondou": "ŸáŸàŸÜÿØŸà ŸáŸäÿØŸäŸÖŸä",
                "EthanHondou": "ŸáŸàŸÜÿØŸà ÿ•Ÿäÿ´ÿßŸÜ",
                "MarySera": "ÿ≥Ÿäÿ±ÿß ŸÖŸäÿ±Ÿä",
                "TsutomuAkai": "ÿ£ŸÉÿßŸä ÿ™ÿ≥Ÿàÿ™ŸàŸÖŸà",
                "RenyaKarasuma": "ŸÉÿßÿ±ÿßÿ≥ŸàŸÖÿß ÿ±ŸäŸÜŸäÿß",
                "Rum": "ÿ±ÿßŸÖ",
                "Gin": "ÿ¨ŸäŸÜ",
                "Vodka": "ŸÅŸàÿØŸÉÿß",
                "ChrisVineyard": "ŸÅŸäÿ±ŸÖŸàÿ´",
                "Chianti": "ŸÉŸäÿßŸÜÿ™Ÿä",
                "Korn": "ŸÉŸàÿ±ŸÜ",
                "ShihoMiyano": "ÿ¥Ÿäÿ±Ÿä",
                "AkemiMiyano": "ŸÖŸäÿßŸÜŸà ÿ£ŸÉŸäŸÖŸä",
                "ElenaMiyano": "ŸÖŸäÿßŸÜŸà ÿ•ŸäŸÑŸäŸÜÿß",
                "AtsushiMiyano": "ŸÖŸäÿßŸÜŸà ÿ£ÿ™ÿ≥Ÿàÿ¥Ÿä",
                "GinzoNakamori": "ŸÜÿßŸÉÿßŸÖŸàÿ±Ÿä ÿ¨ŸäŸÜÿ≤Ÿà",
                "KaitouKid": "ŸÉÿßŸäÿ™Ÿà ŸÉŸäÿØ",
                "ToichiKuroba": "ŸÉŸàÿ±Ÿàÿ®ÿß ÿ™ŸàŸäÿ™ÿ¥Ÿä",
                "KohjiHaneda": "ŸáÿßŸÜŸäÿØÿß ŸÉŸàÿ¨Ÿä",
                "AmandaHughes": "ŸáŸäŸàÿ≤ ÿ£ŸÖÿßŸÜÿØÿß",
            },
            characterCodeById: {
                ShinichiKudo: '1SK',
                ConanEdogawa: '2CE0',
                RanMouri: '3RM0',
                KogoroMouri: '4KM0',
                AyumiYoshida: '5AY',
                MitsuhikoTsuburaya: '6MT',
                GentaKojima: '7GK',
                AiHaibara: '8AH',
                HiroshiAgasa: '9HA',
                SonokoSuzuki: '10SS',
                EriKisaki: '11EK',
                YusakuKudo: '12YK',
                YukikoKudo: '13YK',
                HeijiHattori: '14HH',
                KazuhaToyama: '15KT',
                YokoOkino: '16YO',
                SumikoKobayashi: '17SK',
                TomoakiAraide: '18TA',
                MakotoKyogoku: '19MK',
                ShizukaHattori: '20SH',
                JirokichiSuzuki: '21JS',
                EisukeHondou: '22EH',
                AzusaEnomoto: '23AE',
                SubaruOkiya: '24SO',
                MasumiSera: '25MS',
                ShukichiHaneda: '26SH',
                SakurakoYonehara: '27SY',
                MomijiOoka: '28MO',
                RumiWakasa: '29RW',
                MugaLori: '30ML',
                JuzoMegure: '31JM',
                NinzaburoShiratori: '32NS',
                MiwakoSato: '33MS',
                WataruTakagi: '34WT',
                KazunobuChiba: '35KC',
                YumiMiyamoto: '36YM',
                NaekoMiike: '37NM',
                KiyonagaMatsumoto: '38KM',
                InspectorYuminaga: '39IY',
                ShintaroChaki: '40SC',
                HyoueKuroda: '41HK',
                JinpeiMatsuda: '42JM',
                KenjiHagiwara: '43KH',
                WataruDate: '44WD',
                HeizoHattori: '45HH',
                GinshiroToyama: '46GT',
                GoroOtaki: '47GO',
                KansukeYamato: '48KY',
                YuiUehara: '49YU',
                TakaakiMorofushi: '50TM',
                SangoYokomizo: '51SY',
                MisaoYamamura: '52MY',
                JugoYokomizo: '53JY',
                ChihayaHagiwara: '54CH',
                FumimaroAyanokoji: '55FA',
                ReiFuruya: '56RF',
                HiromitsuMorofushi: '57HM',
                YuyaKazami: '58YK',
                ShuichiAkai: '59SA',
                JodieStarling: '60JS',
                JamesBlack: '61JB',
                AndreCamel: '62AC',
                HidemiHondou: '63HH',
                EthanHondou: '64EH',
                MarySera: '65MS',
                TsutomuAkai: '66TA',
                RenyaKarasuma: '67RK',
                Rum: '68RM',
                Gin: '69GN',
                Vodka: '70VA',
                ChrisVineyard: '71VH',
                Chianti: '72CI',
                Korn: '73KN',
                ShihoMiyano: '74SM',
                AkemiMiyano: '75AM',
                ElenaMiyano: '76EM',
                AtsushiMiyano: '77AM',
                KohjiHaneda: '78KH',
                AmandaHughes: '79AH',
                KaitouKid: '80KK',
                GinzoNakamori: '81GN',
                ToichiKuroba: '82TK',
            },
            characterGroups: [
                { title: 'ÿßŸÑÿ£ÿ®ÿ∑ÿßŸÑ', ids: ['ShinichiKudo', 'ConanEdogawa', 'RanMouri', 'KogoroMouri'] },
                { title: 'ŸÅÿ±ŸäŸÇ ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸäŸÜ ÿßŸÑÿµÿ∫ÿßÿ±', ids: ['AyumiYoshida', 'MitsuhikoTsuburaya', 'GentaKojima', 'AiHaibara'] },
                {
                    title: 'ÿßŸÑÿπÿßÿ¶ŸÑÿ© ŸàÿßŸÑÿ£ÿµÿØŸÇÿßÿ°',
                    ids: [
                        'HiroshiAgasa',
                        'SonokoSuzuki',
                        'EriKisaki',
                        'YusakuKudo',
                        'YukikoKudo',
                        'HeijiHattori',
                        'KazuhaToyama',
                        'YokoOkino',
                        'SumikoKobayashi',
                        'TomoakiAraide',
                        'MakotoKyogoku',
                        'ShizukaHattori',
                        'JirokichiSuzuki',
                        'EisukeHondou',
                        'AzusaEnomoto',
                        'SubaruOkiya',
                        'MasumiSera',
                        'ShukichiHaneda',
                        'SakurakoYonehara',
                        'MomijiOoka',
                        'RumiWakasa',
                        'MugaLori',
                    ],
                },
                {
                    title: 'ÿ¥ÿ±ÿ∑ÿ© ÿßŸÑÿπÿßÿµŸÖÿ©',
                    ids: [
                        'JuzoMegure',
                        'NinzaburoShiratori',
                        'MiwakoSato',
                        'WataruTakagi',
                        'KazunobuChiba',
                        'YumiMiyamoto',
                        'NaekoMiike',
                        'KiyonagaMatsumoto',
                        'InspectorYuminaga',
                        'ShintaroChaki',
                        'HyoueKuroda',
                        'JinpeiMatsuda',
                        'KenjiHagiwara',
                        'WataruDate',
                    ],
                },
                { title: 'ÿ¥ÿ±ÿ∑ÿ© ÿ£Ÿàÿ≥ÿßŸÉÿß', ids: ['HeizoHattori', 'GinshiroToyama', 'GoroOtaki'] },
                { title: 'ÿ¥ÿ±ÿ∑ÿ© ŸÜÿßÿ∫ÿßŸÜŸà', ids: ['KansukeYamato', 'YuiUehara', 'TakaakiMorofushi'] },
                {
                    title: 'ŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ¥ÿ±ÿ∑ÿ© ÿßŸÑÿ£ÿÆÿ±Ÿâ',
                    ids: ['SangoYokomizo', 'MisaoYamamura', 'JugoYokomizo', 'ChihayaHagiwara', 'FumimaroAyanokoji'],
                },
                { title: 'ŸÖŸÉÿ™ÿ® ÿßŸÑÿ£ŸÖŸÜ ÿßŸÑÿπÿßŸÖ', ids: ['ReiFuruya', 'HiromitsuMorofushi', 'YuyaKazami'] },
                { title: 'ŸÖŸÉÿ™ÿ® ÿßŸÑÿ™ÿ≠ŸÇŸäŸÇÿßÿ™ ÿßŸÑŸÅŸäÿØÿ±ÿßŸÑŸä', ids: ['ShuichiAkai', 'JodieStarling', 'JamesBlack', 'AndreCamel'] },
                { title: 'ŸàŸÉÿßŸÑÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿ®ÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿ±ŸÉÿ≤Ÿäÿ©', ids: ['HidemiHondou', 'EthanHondou'] },
                { title: 'ÿßŸÑÿßÿ≥ÿ™ÿÆÿ®ÿßÿ±ÿßÿ™ ÿßŸÑÿ®ÿ±Ÿäÿ∑ÿßŸÜŸäÿ©', ids: ['MarySera', 'TsutomuAkai'] },
                {
                    title: 'ÿßŸÑŸÖŸÜÿ∏ŸÖÿ© ÿßŸÑÿ≥ŸàÿØÿßÿ°',
                    ids: [
                        'RenyaKarasuma',
                        'Rum',
                        'Gin',
                        'Vodka',
                        'ChrisVineyard',
                        'Chianti',
                        'Korn',
                        'ShihoMiyano',
                        'AkemiMiyano',
                        'ElenaMiyano',
                        'AtsushiMiyano',
                        'HidemiHondou',
                        'ReiFuruya',
                        'HiromitsuMorofushi',
                    ],
                },
                { title: 'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà', ids: ['KaitouKid', 'GinzoNakamori', 'ToichiKuroba'] },
                { title: 'ÿ£ÿÆÿ±ŸàŸÜ', ids: ['KohjiHaneda', 'AmandaHughes'] },
            ],
        };

        const buildInitialFilterState = (filterUi) => {
            const state = {};
            const setFalse = (key) => {
                if (key) state[key] = false;
            };

            for (const listKey of ['groupOptions', 'sceneOptions']) {
                const list = filterUi && filterUi[listKey];
                if (!Array.isArray(list)) continue;
                for (const opt of list) {
                    if (!opt || !opt.modelKey) continue;
                    setFalse(opt.modelKey);
                }
            }

            const ids = new Set();
            const groups = filterUi && filterUi.characterGroups;
            if (Array.isArray(groups)) {
                for (const g of groups) {
                    if (!g || !Array.isArray(g.ids)) continue;
                    for (const id of g.ids) ids.add(id);
                }
            }

            const simple = new Set(Array.isArray(filterUi && filterUi.characterSimpleIds) ? filterUi.characterSimpleIds : []);
            const details = Array.isArray(filterUi && filterUi.detailOptions) ? filterUi.detailOptions : [];

            for (const id of ids) {
                state[`filter${id}Episodes`] = false;
                if (!simple.has(id)) {
                    state[`filterLogic${id}`] = 'All';
                    for (const d of details) {
                        if (!d || !d.kind) continue;
                        state[`filter${id}${d.kind}`] = false;
                    }
                }
            }

            return state;
        };

        const FILTER_STATE_DEFAULTS = buildInitialFilterState(FILTER_UI);
        const FILTER_STATE_KEYS = Object.keys(FILTER_STATE_DEFAULTS);

        const getAllCharacterIds = (filterUi) => {
            const ids = new Set();
            const groups = filterUi && filterUi.characterGroups;
            if (Array.isArray(groups)) {
                for (const g of groups) {
                    if (!g || !Array.isArray(g.ids)) continue;
                    for (const id of g.ids) ids.add(id);
                }
            }
            return Array.from(ids);
        };

        const buildResetCharacterMethods = (filterUi) => {
            const ids = getAllCharacterIds(filterUi);
            const methods = {};
            for (const id of ids) {
                methods[`reset${id}Filters`] = function () {
                    this.resetCharacterFilters(id);
                };
            }
            return methods;
        };

        const applyEpisodeTypeFilter = (episodes, episodeTypeFilter) => {
            if (episodeTypeFilter === 'Manga') {
                return episodes.filter(
                    (episode) => episode.EpisodeType === 'ŸÖ' || episode.EpisodeType === 'ÿ´' || episode.EpisodeType === 'ŸÖŸÅ'
                );
            }
            if (episodeTypeFilter === 'Filler') {
                return episodes.filter(
                    (episode) => episode.EpisodeType === 'ŸÅ' || episode.EpisodeType === 'ÿ´' || episode.EpisodeType === 'ŸÖŸÅ'
                );
            }
            return episodes;
        };

        const applyToggleFilters = (episodes, vm, rules) => {
            let out = episodes;
            for (const [key, predicate] of Object.entries(rules || {})) {
                if (vm && vm[key]) {
                    out = out.filter((episode) => predicate(episode));
                }
            }
            return out;
        };

        const applyCharacterFilters = (episodes, vm, filterUi) => {
            const ids = getAllCharacterIds(filterUi);
            const simple = new Set(Array.isArray(filterUi && filterUi.characterSimpleIds) ? filterUi.characterSimpleIds : []);
            const details = Array.isArray(filterUi && filterUi.detailOptions) ? filterUi.detailOptions : [];
            const suffixByKind = (filterUi && filterUi.detailCodeSuffixByKind) || {};
            const codeById = (filterUi && filterUi.characterCodeById) || {};

            let out = episodes;
            for (const id of ids) {
                const baseKey = `filter${id}Episodes`;
                if (!vm || !vm[baseKey]) continue;

                const baseCode = codeById[id];
                if (!baseCode) continue;

                if (simple.has(id)) {
                    out = out.filter((episode) => !String(episode.EpisodeFilterAdvanced || '').includes(baseCode));
                    continue;
                }

                out = out.filter((episode) => String(episode.EpisodeFilterAdvanced || '').includes(baseCode));

                const activeDetailCodes = [];
                for (const d of details) {
                    if (!d || !d.kind) continue;
                    const detailKey = `filter${id}${d.kind}`;
                    if (!vm[detailKey]) continue;
                    const suffix = suffixByKind[d.kind];
                    if (!suffix) continue;
                    activeDetailCodes.push(`${baseCode}${suffix}`);
                }

                if (activeDetailCodes.length > 0) {
                    const logic = vm[`filterLogic${id}`];
                    if (logic === 'All') {
                        out = out.filter((episode) =>
                            activeDetailCodes.some((code) => String(episode.EpisodeFilterAdvanced || '').includes(code))
                        );
                    } else if (logic === 'Some') {
                        out = out.filter((episode) =>
                            activeDetailCodes.every((code) => String(episode.EpisodeFilterAdvanced || '').includes(code))
                        );
                    }
                }
            }

            return out;
        };

        const buildCharacterCountComputed = (filterUi) => {
            const ids = getAllCharacterIds(filterUi);
            const simple = new Set(Array.isArray(filterUi && filterUi.characterSimpleIds) ? filterUi.characterSimpleIds : []);
            const details = Array.isArray(filterUi && filterUi.detailOptions) ? filterUi.detailOptions : [];
            const suffixByKind = (filterUi && filterUi.detailCodeSuffixByKind) || {};
            const codeById = (filterUi && filterUi.characterCodeById) || {};

            const computed = {};
            for (const id of ids) {
                const baseCode = codeById[id];
                if (!baseCode) continue;

                computed[`${id}EpisodesCount`] = function () {
                    const list = Array.isArray(this.episodes) ? this.episodes : [];
                    if (simple.has(id)) {
                        return list.filter((episode) => !String(episode.EpisodeFilterAdvanced || '').includes(baseCode)).length;
                    }
                    return list.filter((episode) => String(episode.EpisodeFilterAdvanced || '').includes(baseCode)).length;
                };

                if (simple.has(id)) continue;

                for (const d of details) {
                    if (!d || !d.kind) continue;
                    const suffix = suffixByKind[d.kind];
                    if (!suffix) continue;
                    const code = `${baseCode}${suffix}`;
                    computed[`${id}${d.kind}Count`] = function () {
                        const list = Array.isArray(this.episodes) ? this.episodes : [];
                        return list.filter((episode) => String(episode.EpisodeFilterAdvanced || '').includes(code)).length;
                    };
                }
            }

            return computed;
        };

        const EPISODE_TOGGLE_FILTERS = {
            filterBlackOrganization: (episode) => String(episode.EpisodeEvents || '').includes('ÿ≥'),
            filterDetectiveBoys: (episode) => String(episode.EpisodeEvents || '').includes('ÿ∑'),
            filterScaryEpisodes: (episode) => String(episode.EpisodeEventsAdvanced || '').includes('ÿ±ÿπÿ®'),
            filterSadyEpisodes: (episode) => String(episode.EpisodeEventsAdvanced || '').includes('ÿ≠ÿ≤ŸÜ'),
            filterPoliceAcademy: (episode) => String(episode.EpisodeEventsAdvanced || '').includes('ÿ£ŸÉÿßÿØŸäŸÖŸäÿ© ÿßŸÑÿ¥ÿ±ÿ∑ÿ©'),
            filterFBI: (episode) => String(episode.EpisodeEvents || '').includes('ŸÅ'),
            filterPSB: (episode) => String(episode.EpisodeEvents || '').includes('ÿπ'),
            filterNewCharacter: (episode) => String(episode.EpisodeEvents || '').includes('ÿ¨'),
            filterDevelopmentCharacter: (episode) => String(episode.EpisodeEvents || '').includes('ÿ™'),
            filterFlashBackEpisodes: (episode) => String(episode.EpisodeEvents || '').includes('ŸÖ'),
            filterRomanceEpisodes: (episode) => String(episode.EpisodeEvents || '').includes('ÿ±'),
        };

        const buildPredicateCountComputed = (predicatesByKey) => {
            const computed = {};
            for (const [key, predicate] of Object.entries(predicatesByKey || {})) {
                if (typeof predicate !== 'function') continue;
                computed[key] = function () {
                    const list = Array.isArray(this.episodes) ? this.episodes : [];
                    let count = 0;
                    for (const episode of list) {
                        if (predicate(episode)) count++;
                    }
                    return count;
                };
            }
            return computed;
        };

        const buildToggleCountComputed = (filterUi, rules) => {
            const computed = {};
            for (const listKey of ['groupOptions', 'sceneOptions']) {
                const list = filterUi && filterUi[listKey];
                if (!Array.isArray(list)) continue;
                for (const opt of list) {
                    if (!opt || !opt.countKey || !opt.modelKey) continue;
                    const predicate = rules && rules[opt.modelKey];
                    if (typeof predicate !== 'function') continue;
                    computed[opt.countKey] = function () {
                        const episodes = Array.isArray(this.episodes) ? this.episodes : [];
                        let count = 0;
                        for (const episode of episodes) {
                            if (predicate(episode)) count++;
                        }
                        return count;
                    };
                }
            }
            return computed;
        };

        const EPISODE_TYPE_COUNT_PREDICATES = {
            episodeTypeMangaCount: (episode) => String(episode?.EpisodeType || '').includes('ŸÖ'),
            episodeTypeFillerCount: (episode) => String(episode?.EpisodeType || '').includes('ŸÅ'),
            episodeTypeAllCount: (episode) => {
                const t = String(episode?.EpisodeType || '');
                return t.includes('ŸÅ') || t.includes('ŸÖ');
            },
        };

        const CATEGORY_COUNT_PREDICATES = {
            episodeTypeAnimeCount: (episode) => !String(episode?.EpisodeNumber || '').includes('ÿßŸÑŸÅŸäŸÑŸÖ'),
            episodeTypeShortStoryCount: (episode) => String(episode?.EpisodeNumber || '').includes('ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©'),
            episodeTypeOVA: (episode) => String(episode?.EpisodeNumber || '').includes('ÿ£ŸàŸÅÿß'),
            episodeTypeMovieSpecial: (episode) =>
                String(episode?.EpisodeNumber || '').includes('ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ') || String(episode?.EpisodeTitle || '').includes('ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ'),
            episodeTypeSpecialRelease: (episode) => String(episode?.EpisodeNumber || '').includes('ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ'),
            episodeTypeMagicKaito: (episode) => String(episode?.EpisodeNumber || '').includes('ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà'),
            episodeTypeZeroDiaries: (episode) => String(episode?.EpisodeNumber || '').includes('ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà'),
            episodeTypeHanazawa: (episode) => String(episode?.EpisodeNumber || '').includes('ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß'),
            episodeTypeMovieCount: (episode) => {
                const n = String(episode?.EpisodeNumber || '');
                return (n.includes('ÿßŸÑŸÅŸäŸÑŸÖ') || n.includes('ŸÅŸäŸÑŸÖ ÿ™ÿπÿßŸàŸÜŸä')) && !n.includes('ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ');
            },
            episodeTypeHourlySpecialCount: (episode) => String(episode?.EpisodeSpecial || '').includes('1'),
            episodeTypeTwoHourSpecialCount: (episode) => String(episode?.EpisodeSpecial || '').includes('2'),
        };

        const normalizeTranslatorName = (s) => String(s || '').toLowerCase().replace(/[\s\-_]+/g, '').trim();
        const PROFESSIONAL_TRANSLATOR_TOKENS = new Set([
            'CodeSubs',
            'ABOODYSUBS',
            'Aoibu',
            'DCAN',
            'ReineR',
            'ÿπÿ®ÿØ ÿßŸÑŸÖŸÑŸÑŸÉ',
            'Shinjitsu Fansubs',
            'DCMS',
            'Marchi-Fansub',
            'MA-SHI',
            'Variom',
            'MAT-Fansubs',
            'KaidoKidTH',
            'Yusaku-Kudo',
            'Mystery-Fansubs',
            'ALPhantom',
            'Celestial-Dragons'
        ].map(normalizeTranslatorName));
    
        const app = createApp({
            data() {
                return {
                    showStickyLabel: false,
                    comntoTopic: 'mainPageCD',
                    comntoVisible: false,
                    comntoContext: 'main',
                    comntoWidget: null,
                    lastComntoTopicApplied: null,
                    comntoScriptLoaded: false,
                    comntoScriptLoading: false,
                    comntoLoadingCallbacks: [],
                    debugModeCommentsHeader: false,
                    debugModeComntoTopic: false,
                    debugModeInactivityCountdown: false,
                    fontSize: 16,
                    menuOpen: false,
                    userJoined: false,
                    showEmptyPopup: false,
                    showDirectWindow: false,
                    showFastingWindow: false,
                    selectedCategory: 'episodes',
                    mangaStartNumber: null,
                    mangaEndNumber: null,
                    mangaQueue: [],
                    mangaQueueIndex: 0,
                    isMangaQueueRunning: false,
                    isMangaQueuePaused: false,
                    isMangaQueueSending: false,
                    isMangaQueuePauseRequested: false,
                    mangaQueueProcessId: null,
                    mangaQueueTimeoutId: null,
                    showStopConfirmation: false,
                    showLimitModal: false,
                    showMangaSentLogModal: false,
                    showMangaFailedLogModal: false,
                    mangaQueueCurrent: {
                        chapter: null,
                        status: null, // 'sending' | 'success' | 'failed'
                        error: null,
                    },
                    mangaSentLog: [], // [{ chapter, fileId, sentAt }]
                    mangaFailedLog: [], // [{ chapter, fileId, fileSize, error, status, attempts }]
                    isRetryAllFailedRunning: false,
                    retryAllFailedProgress: { done: 0, total: 0 },
                    // New Queue & Retry States
                    isRetryQueueRunning: false,
                    isRetryQueuePaused: false,
                    isRetryQueuePauseRequested: false,
                    showRetryStopConfirmation: false,
                    showSendInProgressConfirmation: false,
                    showCaptureInProgressConfirmation: false,
                    pendingCloseTarget: null,
                    sendCancelGeneration: 0,
                    captureCancelRequested: false,
                    captureEpisodeTableDelayRemainingMs: 0,
                    failedMangaQueue: [], // Array of objects { chapter, ... } reference from mangaFailedLog
                    failedQueueStats: {
                        total: 0,
                        sent: 0,
                        failed: 0,
                        waiting: 0,
                        elapsedTime: 0,
                        remainingTime: 0
                    },
                    retryQueueCurrent: {
                        chapter: null,
                        status: null, // 'sending' | 'success' | 'failed'
                        error: null,
                    },
                    mangaQueueStats: {
                        total: 0,
                        sent: 0,
                        failed: 0,
                        waiting: 0,
                        elapsedTime: 0,
                        remainingTime: 0
                    },
                    mangaQueueStartTime: null,
                    mangaQueuePausedTime: 0,
                    mangaQueueTotalPausedTime: 0,
                    mangaQueueInterval: null,
                    activeTab: { episodes: 0, movies: 0, mangas: 0 },
                    searchFilters: {
                        number: true,
                        title: false,
                        story: false,
                        summary: false,
                    },
                    pendingJumpTarget: null,
                    pendingJumpRegex: null,
                    pendingJumpOpenModal: false,
                    jumpHighlightIdentifier: null,
                    lastClickedEpisode: null,
                    errorMessage: "",
                    statusClearTimeout: 2000,
                    fastingStatusClearTimeout: 3000,
                    inactivityDurationSeconds: 300,
                    inactivityCountdown: 300,
                    inactivityIntervalId: null,
                    inactivityModal: false,
                    isRefreshingSession: false,
                    isTrailerIframeLoading: false,
                    inactivityListeners: [],
                    lastActivityAt: Date.now(),
                    filterUi: markRaw(FILTER_UI),
                    activeFilterCycleIndex: -1,
                    activeFilterHighlightedEl: null,
                    successHintVisible: false,
                    successHintAnimatingOut: false,
                    successHintMessage: '',
                    successHintCountdown: 0,
                    successHintCountdownIntervalId: null,
                    successHintHideTimeoutId: null,
                    successHintHideAnimationTimeoutId: null,
                    episode: { status: null },
                    movie: { status: null },
                    ep: 1189,
                    mangaCh: 1156,
                    jumpCycleState: null,
                    // Ads Rows
                    showEpisodeAds: false,
                    episodeAdInterval: 5,
                    // Daily Limit Data
                    dailyDownloads: 0,
                    dailyReady: false,
                    pendingDailyIncrements: 0,
                    dailyLimitRetryTimer: null,
                    dailyLimitRetryAttempts: 0,
                    dailyLimitRowId: null,
                    dailyLimitRowIdRam: null,
                    dailyLimitRowIdResyncIntervalId: null,
                    dailyLimitDate: null,
                    dailyLimitDayStartUtcMs: null,
                    maxDailyDownloads: 100,
                    now: Date.now(),
                    _db: null,
                    userId: window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 'anonymous-user', // Fallback for testing if not in Telegram
                    testMinuteReset: false,
                    nowIntervalId: null,
                    
                    // Time Synchronization
                    serverTimeOffset: 0,
                    lastServerSync: 0,
                    trustedToday: null,
                    unsubscribeDaily: null,

                    // Tab Locking System
                    tabLockModal: false,
                    isTabOwner: false,
                    tabWorkerPort: null,
                    tabBroadcastChannel: null,
                    tabLockLock: null,
                    tabHeartbeatInterval: null,
                    tabId: null,
                    tabStorageLockInterval: null,
                    tabStorageLockVisibilityHandler: null,
                    tabWebLockRetryInterval: null,
                    tabWebLockRequestInFlight: false,
                    tabWebLockReleaseResolver: null,
                    tabWebLockVisibilityHandler: null,

                    replacementDict: {
                        "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà": ["ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà", "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1", "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2"],
                        "ÿ≥ŸäŸÜÿ¥Ÿä": ["ÿ¥ŸäŸÜÿ™ÿ¥Ÿä", "ÿ≥ŸäŸÜÿ¥Ÿä"],
                        "ÿ¥ŸäŸÜÿ™ÿ¥Ÿä": ["ÿ≥ŸäŸÜÿ¥Ÿä", "ÿ¥ŸäŸÜÿ™ÿ¥Ÿä"],
                        "ÿ≥ŸäŸÜŸÅŸàŸÜŸäÿ©": ["ÿ≥ŸäŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÅŸàŸÜŸäÿ©"],
                        "ÿ≥ŸÜŸÅŸàŸÜŸäÿ©": ["ÿ≥ŸäŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÅŸàŸÜŸäÿ©"],
                        "ÿ≥ŸäŸÖŸÅŸàŸÜŸäÿ©": ["ÿ≥ŸäŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÅŸàŸÜŸäÿ©"],
                        "ÿ≥ŸÖŸÅŸàŸÜŸäÿ©": ["ÿ≥ŸäŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÅŸàŸÜŸäÿ©"],
                        "ÿ≥ŸÅŸàŸÜŸäÿ©":  ["ÿ≥ŸäŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÅŸàŸÜŸäÿ©"],
                        "ÿ≥ŸäŸÅŸàŸÜŸäÿ©": ["ÿ≥ŸäŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÜŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÖŸÅŸàŸÜŸäÿ©", "ÿ≥ŸÅŸàŸÜŸäÿ©", "ÿ≥ŸäŸÅŸàŸÜŸäÿ©"],
                        "ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©": ["ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©"],
                        "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©": ["ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©"],
                        "ÿßŸÑŸÖÿØŸäŸÜÿ©": ["ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©"],
                        "ÿßŸÑÿπÿßÿµŸÖÿ©": ["ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©"],
                        "ÿßŸÑÿ®ŸÑÿØÿ©": ["ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©", "ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©"],
                        "ÿßŸÑŸÇÿ±Ÿäÿ©": ["ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©", "ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©"],
                        "ÿßŸÑÿ≠Ÿä": ["ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©", "ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©"],
                        "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©": ["ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©"],
                        "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ": ["ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©"],
                        "ÿßŸÑŸàŸÑÿßŸäÿ©": ["ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©"],
                        "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©": ["ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©"],
                        "ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©": ["ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ©", "ÿßŸÑÿ•ŸÇŸÑŸäŸÖ", "ÿßŸÑŸàŸÑÿßŸäÿ©", "ÿßŸÑŸÖÿØŸäÿ±Ÿäÿ©", "ÿßŸÑŸÖŸÇÿßÿ∑ÿπÿ©", "ÿßŸÑŸÖÿØŸäŸÜÿ©", "ÿßŸÑÿπÿßÿµŸÖÿ©", "ÿßŸÑÿ®ŸÑÿØÿ©", "ÿßŸÑŸÇÿ±Ÿäÿ©", "ÿßŸÑÿ≠Ÿä", "ÿßŸÑÿ∂ÿßÿ≠Ÿäÿ©"],
                        _replacementMatcher: null,
                        "ÿ¨ÿ±ŸäŸÖÿ© ŸÅŸä": ["ÿ¨ÿ±ŸäŸÖÿ© ŸÇÿ™ŸÑ ŸÅŸä", "ÿ¨ÿ±ŸäŸÖÿ© ŸÅŸä"],
                        "ÿßŸÑŸÅŸÑŸÖ": ["ÿßŸÑŸÅŸäŸÑŸÖ","ŸÅŸäŸÑŸÖ","ÿßŸÑŸÅŸÑŸÖ","ŸÅŸÑŸÖ","ÿßŸÑŸÅŸÑŸäŸÖ","ŸÅŸÑŸäŸÖ"],
                        "ŸÅŸÑŸÖ": ["ÿßŸÑŸÅŸäŸÑŸÖ","ŸÅŸäŸÑŸÖ","ÿßŸÑŸÅŸÑŸÖ","ŸÅŸÑŸÖ","ÿßŸÑŸÅŸÑŸäŸÖ","ŸÅŸÑŸäŸÖ"],
                        "ÿßŸÑŸÅŸÑŸäŸÖ": ["ÿßŸÑŸÅŸäŸÑŸÖ","ŸÅŸäŸÑŸÖ","ÿßŸÑŸÅŸÑŸÖ","ŸÅŸÑŸÖ","ÿßŸÑŸÅŸÑŸäŸÖ","ŸÅŸÑŸäŸÖ"],
                        "ŸÅŸäŸÑŸÖ": ["ÿßŸÑŸÅŸäŸÑŸÖ","ŸÅŸäŸÑŸÖ","ÿßŸÑŸÅŸÑŸÖ","ŸÅŸÑŸÖ","ÿßŸÑŸÅŸÑŸäŸÖ","ŸÅŸÑŸäŸÖ"],
                        "ŸÅŸÑŸäŸÖ": ["ÿßŸÑŸÅŸäŸÑŸÖ","ŸÅŸäŸÑŸÖ","ÿßŸÑŸÅŸÑŸÖ","ŸÅŸÑŸÖ","ÿßŸÑŸÅŸÑŸäŸÖ","ŸÅŸÑŸäŸÖ"],
                        "ÿßŸÑŸÅŸäŸÑŸÖ": ["ÿßŸÑŸÅŸäŸÑŸÖ","ŸÅŸäŸÑŸÖ","ÿßŸÑŸÅŸÑŸÖ","ŸÅŸÑŸÖ","ÿßŸÑŸÅŸÑŸäŸÖ","ŸÅŸÑŸäŸÖ"],
                        "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà": ["ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà"],
                        "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1": ["ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1"],
                        "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2": ["ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2"],
                        "ÿ≥ÿßŸÜ": ["ÿ≥ŸäÿØ","ÿßŸÑÿ≥ŸäÿØ"],
                        "ÿ≥ŸäÿØ": ["ÿ≥ÿßŸÜ","ÿßŸÑÿ≥ŸäÿØ"],
                        "ÿßŸÑÿ≥ŸäÿØ": ["ÿ≥ÿßŸÜ","ÿ≥ŸäÿØ"],
                        "ÿ©": ["Ÿá","ÿ©"],
                        "Ÿá": ["ÿ©","Ÿá"],
                        "ÿ£": ["ÿß","ÿ•","ÿ£"],
                        "ÿß": ["ÿ£","ÿ•","ÿß"],
                        "ÿ•": ["ÿ£","ÿß","ÿ•"],
                        "ÿ≥": ["ÿ¥","ÿ≥"],
                        "ÿ¥": ["ÿ≥","ÿ¥"],
                        "ŸÑŸàÿ®ŸÜ": ["ŸÑŸàÿ®ŸäŸÜ","ŸÑŸàÿ®ŸÜ"],
                        "ŸÑŸàÿ®ŸäŸÜ": ["ŸÑŸàÿ®ŸÜ","ŸÑŸàÿ®ŸäŸÜ"],
                        "1": ["1", "ÿßŸÑÿ£ŸàŸÑ", "ÿßŸàŸÑ"],
                        "ÿßŸÑÿ£ŸàŸÑ": ["1", "ÿßŸÑÿ£ŸàŸÑ", "ÿßŸàŸÑ"],
                        "ÿßŸàŸÑ": ["1", "ÿßŸÑÿ£ŸàŸÑ", "ÿßŸàŸÑ"],
                        "2": ["2", "ÿßŸÑÿ´ÿßŸÜŸä", "ÿ´ÿßŸÜŸä"],
                        "ÿßŸÑÿ´ÿßŸÜŸä": ["2", "ÿßŸÑÿ´ÿßŸÜŸä", "ÿ´ÿßŸÜŸä"],
                        "ÿ´ÿßŸÜŸä": ["2", "ÿßŸÑÿ´ÿßŸÜŸä", "ÿ´ÿßŸÜŸä"],
                        "3": ["3", "ÿßŸÑÿ´ÿßŸÑÿ´", "ÿ´ÿßŸÑÿ´"],
                        "ÿßŸÑÿ´ÿßŸÑÿ´": ["3", "ÿßŸÑÿ´ÿßŸÑÿ´", "ÿ´ÿßŸÑÿ´"],
                        "ÿ´ÿßŸÑÿ´": ["3", "ÿßŸÑÿ´ÿßŸÑÿ´", "ÿ´ÿßŸÑÿ´"],
                        "4": ["4", "ÿßŸÑÿ±ÿßÿ®ÿπ", "ÿ±ÿßÿ®ÿπ"],
                        "ÿßŸÑÿ±ÿßÿ®ÿπ": ["4", "ÿßŸÑÿ±ÿßÿ®ÿπ", "ÿ±ÿßÿ®ÿπ"],
                        "ÿ±ÿßÿ®ÿπ": ["4", "ÿßŸÑÿ±ÿßÿ®ÿπ", "ÿ±ÿßÿ®ÿπ"],
                        "5": ["5", "ÿßŸÑÿÆÿßŸÖÿ≥", "ÿÆÿßŸÖÿ≥"],
                        "ÿßŸÑÿÆÿßŸÖÿ≥": ["5", "ÿßŸÑÿÆÿßŸÖÿ≥", "ÿÆÿßŸÖÿ≥"],
                        "ÿÆÿßŸÖÿ≥": ["5", "ÿßŸÑÿÆÿßŸÖÿ≥", "ÿÆÿßŸÖÿ≥"],
                        "6": ["6", "ÿßŸÑÿ≥ÿßÿØÿ≥", "ÿ≥ÿßÿØÿ≥"],
                        "ÿßŸÑÿ≥ÿßÿØÿ≥": ["6", "ÿßŸÑÿ≥ÿßÿØÿ≥", "ÿ≥ÿßÿØÿ≥"],
                        "ÿ≥ÿßÿØÿ≥": ["6", "ÿßŸÑÿ≥ÿßÿØÿ≥", "ÿ≥ÿßÿØÿ≥"],
                        "7": ["7", "ÿßŸÑÿ≥ÿßÿ®ÿπ", "ÿ≥ÿßÿ®ÿπ"],
                        "ÿßŸÑÿ≥ÿßÿ®ÿπ": ["7", "ÿßŸÑÿ≥ÿßÿ®ÿπ", "ÿ≥ÿßÿ®ÿπ"],
                        "ÿ≥ÿßÿ®ÿπ": ["7", "ÿßŸÑÿ≥ÿßÿ®ÿπ", "ÿ≥ÿßÿ®ÿπ"],
                        "8": ["8", "ÿßŸÑÿ´ÿßŸÖŸÜ", "ÿ´ÿßŸÖŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÖŸÜ": ["8", "ÿßŸÑÿ´ÿßŸÖŸÜ", "ÿ´ÿßŸÖŸÜ"],
                        "ÿ´ÿßŸÖŸÜ": ["8", "ÿßŸÑÿ´ÿßŸÖŸÜ", "ÿ´ÿßŸÖŸÜ"],
                        "9": ["9", "ÿßŸÑÿ™ÿßÿ≥ÿπ", "ÿ™ÿßÿ≥ÿπ"],
                        "ÿßŸÑÿ™ÿßÿ≥ÿπ": ["9", "ÿßŸÑÿ™ÿßÿ≥ÿπ", "ÿ™ÿßÿ≥ÿπ"],
                        "ÿ™ÿßÿ≥ÿπ": ["9", "ÿßŸÑÿ™ÿßÿ≥ÿπ", "ÿ™ÿßÿ≥ÿπ"],
                        "10": ["10", "ÿßŸÑÿπÿßÿ¥ÿ±", "ÿπÿßÿ¥ÿ±"],
                        "ÿßŸÑÿπÿßÿ¥ÿ±": ["10", "ÿßŸÑÿπÿßÿ¥ÿ±", "ÿπÿßÿ¥ÿ±"],
                        "ÿπÿßÿ¥ÿ±": ["10", "ÿßŸÑÿπÿßÿ¥ÿ±", "ÿπÿßÿ¥ÿ±"],
                        "11": ["11", "ÿßŸÑÿ≠ÿßÿØŸä ÿπÿ¥ÿ±", "ÿ≠ÿßÿØŸä ÿπÿ¥ÿ±"],
                        "ÿßŸÑÿ≠ÿßÿØŸä ÿπÿ¥ÿ±": ["11", "ÿßŸÑÿ≠ÿßÿØŸä ÿπÿ¥ÿ±", "ÿ≠ÿßÿØŸä ÿπÿ¥ÿ±"],
                        "ÿ≠ÿßÿØŸä ÿπÿ¥ÿ±": ["11", "ÿßŸÑÿ≠ÿßÿØŸä ÿπÿ¥ÿ±", "ÿ≠ÿßÿØŸä ÿπÿ¥ÿ±"],
                        "12": ["12", "ÿßŸÑÿ´ÿßŸÜŸä ÿπÿ¥ÿ±", "ÿ´ÿßŸÜŸä ÿπÿ¥ÿ±"],
                        "ÿßŸÑÿ´ÿßŸÜŸä ÿπÿ¥ÿ±": ["12", "ÿßŸÑÿ´ÿßŸÜŸä ÿπÿ¥ÿ±", "ÿ´ÿßŸÜŸä ÿπÿ¥ÿ±"],
                        "ÿ´ÿßŸÜŸä ÿπÿ¥ÿ±": ["12", "ÿßŸÑÿ´ÿßŸÜŸä ÿπÿ¥ÿ±", "ÿ´ÿßŸÜŸä ÿπÿ¥ÿ±"],
                        "13": ["13", "ÿßŸÑÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±", "ÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±"],
                        "ÿßŸÑÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±": ["13", "ÿßŸÑÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±", "ÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±"],
                        "ÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±": ["13", "ÿßŸÑÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±", "ÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±"],
                        "14": ["14", "ÿßŸÑÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±", "ÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±"],
                        "ÿßŸÑÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±": ["14", "ÿßŸÑÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±", "ÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±"],
                        "ÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±": ["14", "ÿßŸÑÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±", "ÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±"],
                        "15": ["15", "ÿßŸÑÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±", "ÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±"],
                        "ÿßŸÑÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±": ["15", "ÿßŸÑÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±", "ÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±"],
                        "ÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±": ["15", "ÿßŸÑÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±", "ÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±"],
                        "16": ["16", "ÿßŸÑÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±", "ÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±"],
                        "ÿßŸÑÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±": ["16", "ÿßŸÑÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±", "ÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±"],
                        "ÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±": ["16", "ÿßŸÑÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±", "ÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±"],
                        "17": ["17", "ÿßŸÑÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±", "ÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±"],
                        "ÿßŸÑÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±": ["17", "ÿßŸÑÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±", "ÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±"],
                        "ÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±": ["17", "ÿßŸÑÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±", "ÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±"],
                        "18": ["18", "ÿßŸÑÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±", "ÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±"],
                        "ÿßŸÑÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±": ["18", "ÿßŸÑÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±", "ÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±"],
                        "ÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±": ["18", "ÿßŸÑÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±", "ÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±"],
                        "19": ["19", "ÿßŸÑÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±", "ÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±"],
                        "ÿßŸÑÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±": ["19", "ÿßŸÑÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±", "ÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±"],
                        "ÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±": ["19", "ÿßŸÑÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±", "ÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±"],
                        "20": ["20", "ÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["20", "ÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿπÿ¥ÿ±ŸàŸÜ": ["20", "ÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿπÿ¥ÿ±ŸàŸÜ"],
                        "21": ["21", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["21", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["21", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "22": ["22", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["22", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["22", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "23": ["23", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["23", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["23", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "24": ["24", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["24", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["24", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "25": ["25", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["25", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["25", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "26": ["26", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["26", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["26", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "27": ["27", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["27", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["27", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "28": ["28", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["28", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["28", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "29": ["29", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["29", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ": ["29", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ", "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ"],
                        "30": ["30", "ÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["30", "ÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿ´ŸÑÿßÿ´ŸàŸÜ": ["30", "ÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "31": ["31", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["31", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["31", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "32": ["32", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["32", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["32", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "33": ["33", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["33", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["33", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "34": ["34", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["34", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["34", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "35": ["35", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["35", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["35", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "36": ["36", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["36", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["36", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "37": ["37", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["37", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["37", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "38": ["38", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["38", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["38", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "39": ["39", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["39", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ": ["39", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ", "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ"],
                        "40": ["40", "ÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿßÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["40", "ÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿßÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßÿ±ÿ®ÿπŸàŸÜ": ["40", "ÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿßÿ±ÿ®ÿπŸàŸÜ"],
                        "41": ["41", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["41", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["41", "ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ≠ÿßÿØŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "42": ["42", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["42", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["42", "ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ´ÿßŸÜŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "43": ["43", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["43", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["43", "ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "44": ["44", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["44", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["44", "ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "45": ["45", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["45", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["45", "ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "46": ["46", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["46", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["46", "ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "47": ["47", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["47", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["47", "ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "48": ["48", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["48", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["48", "ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "49": ["49", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["49", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ": ["49", "ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ", "ÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ"],
                        "50": ["50", "ÿßŸÑÿÆŸÖÿ≥ŸàŸÜ", "ÿÆŸÖÿ≥ŸàŸÜ"],
                        "ÿßŸÑÿÆŸÖÿ≥ŸàŸÜ": ["50", "ÿßŸÑÿÆŸÖÿ≥ŸàŸÜ", "ÿÆŸÖÿ≥ŸàŸÜ"],
                        "ÿÆŸÖÿ≥ŸàŸÜ": ["50", "ÿßŸÑÿÆŸÖÿ≥ŸàŸÜ", "ÿÆŸÖÿ≥ŸàŸÜ"],
                    },
                    jsonUrl: "https://enc.mdccxxixix.workers.dev",
                    imageBaseUrl: "https://raw.githubusercontent.com/c7bb/6Y9/main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/",
                    episodeNotesDebug: false,  // Enable for debugging episode notes processing
                    episodeLinkClickHandler: null,
                    episodeTypeFilter: 'All',
                    episodes: [],
                    selectedMovie: null, // Track the selected movie for resolution/size view
                    selectedManga: null, // Track the selected manga for file size view
                    movies: [], // Movies will be populated separately
                    mangas: [], // Declare mangas to avoid Vue render warn
                    loading: true,
                    loadingFromCache: false,
                    loadingModeResolved: false,
                    loadProgress: 0,
                    inputSearchQuery: '',
                    searchDebounceTimer: null,
                    loadingRelated: false,
                    loadingNextManga: false,
                    loadingPreviousManga: false,
                    loadingManga: false,
                    loadingEpisode: false,
                    circumference: 2 * Math.PI * 45, // 2œÄr where r=45
                    progressInterval: null,
                    error: null,
                    searchQuery: '',
                    textNumberMatchMode: 'enabled', // Default to disabled
                    searchOpen: false,
                    selectedFilter: 'all',
                    currentPage: 1,
                    lastPage: 1,
                    pageSize: 15,
                    oldPageSize: 15,
                    showModal: false,
                    showTrailerModal: false,
                    selectedEpisode: null,
                    relatedEpisodesDataUrl: null,
                    relatedEpisodeGroups: [],
                    relatedEpisodeGroupById: {},
                    relatedEpisodeGroupIdByEpisodeKey: {},
                    episodesByEpisodeKey: {},
                    relatedEpisodeMenuOpen: false,
                    isCapturingEpisodeTableImages: false,
                    captureEpisodeTableImagesDone: 0,
                    captureEpisodeTableImagesTotal: 0,
                    selectedTrailerGroupKey: null,
                    selectedTrailerProviderKey: null,
                    selectedTrailer: null,
                    trailerIframeSrc: '',
                    preserveSelectedEpisodeOnModalClose: false,
                    showMangaButtons: false,
                    ...FILTER_STATE_DEFAULTS,                    
                    // Countdown properties
                    countdownInterval: null,
                    countdownArabic: '',
                    countdownEnglish: '',
                    showEnglishCountdown: false,
                    hasCountdown: false,
                    movieReleaseDate: '',
                    movieCountdownArabic: '',
                    movieCountdownEnglish: '',
                    movieTimeAgoArabic: '',
                    movieTimeAgoEnglish: '',
                    showEnglishMovieTimeFormat: false,
                    movieHasUpcomingRelease: false,
                    movieTimingInterval: null,

                    nextEpisodeInfo: null,
                    nextEpisodeReleaseDate: null,
                    nextEpisodeStatus: '',
                    nextEpisodeCountdownArabicSentence: '',
                    nextEpisodeCountdownEnglishSentence: '',
                    showEnglishNextEpisodeCountdown: false,
                    nextEpisodeExistsInEpisodes: false,
                    nextEpisodeHasRecord: false,
                    nextEpisodeIntervalId: null,

                    nextMangaInfo: null,
                    nextMangaReleaseDate: null,
                    nextMangaStatus: '',
                    nextMangaCountdownArabicDynamic: '',
                    nextMangaCountdownEnglishValue: '',
                    showEnglishNextMangaCountdown: false,
                    nextMangaExistsInList: false,
                    nextMangaIntervalId: null,

                    spoilerVisible: false,
                    nextEpisodeExists: false,
                    previousEpisodeExists: false,
                    nextEpisodeByNumberExists: false,
                    previousEpisodeByNumberExists: false,
                    ratelimiting: false,
                    episodeOfWeekTimeAgo: '',
                    episodeOfWeekTimeAgoEnglish: '',
                    showEnglishTimeFormat: false,
                    mangaOfWeekTimeAgo: '',
                    mangaOfWeekTimeAgoEnglish: '',
                    showEnglishTimeFormatManga: false,
                    mangaUpdateDate: '',
                    currentZikr: '',
                    adhkar: [
                        "ÿßŸÑŸÑŸáŸÖ ÿµŸÑŸêŸë Ÿàÿ≥ŸÑŸÖ ÿπŸÑŸâ ŸÜÿ®ŸäŸÜÿß ŸÖÿ≠ŸÖÿØ",
                        "ÿ≥ÿ®ÿ≠ÿßŸÜ ÿßŸÑŸÑŸá Ÿàÿ®ÿ≠ŸÖÿØŸáÿå ÿ≥ÿ®ÿ≠ÿßŸÜ ÿßŸÑŸÑŸá ÿßŸÑÿπÿ∏ŸäŸÖ",
                        "ÿßŸÑÿ≠ŸÖÿØ ŸÑŸÑŸá",
                        "ŸÑÿß ÿ•ŸÑŸá ÿ•ŸÑÿß ÿßŸÑŸÑŸá",
                        "ÿßŸÑŸÑŸá ÿ£ŸÉÿ®ÿ±",
                        "ÿ£ÿ≥ÿ™ÿ∫ŸÅÿ± ÿßŸÑŸÑŸá ÿßŸÑÿπÿ∏ŸäŸÖ Ÿàÿ£ÿ™Ÿàÿ® ÿ•ŸÑŸäŸá"
                    ],
                    remainingAdhkar: [],
                    intervalZikrId: null,
                    jumpTargetMode: 'episode',
                    jumpInput: '',
                    jumpInputActive: false
                };
            },
            computed: {
                isApplePlatform() {
                    try {
                        const p = String(webApp?.platform || '').toLowerCase();
                        return p === 'ios' || p === 'macos';
                    } catch (_) {
                        return false;
                    }
                },
                commentsHeaderText() {
                    try {
                        if (this.comntoContext === 'main' || this.comntoTopic === 'mainPageCD') return 'ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©';
                        const ep = this.selectedEpisode;
                        if (!ep || !ep.EpisodeNumber) return 'ÿßŸÑÿ™ÿπŸÑŸäŸÇÿßÿ™';
                        const s = String(ep.EpisodeNumber || '');
                        const { cleanNum, cleanLabel } = this.parseEpisodeLabel(s);
                        const numOnly = String(cleanNum || '').replace(/\(ÿ¨[12]\)\s*$/,'').trim();
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿßŸÑÿ≠ŸÑŸÇÿ©:') return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑÿ≠ŸÑŸÇÿ© ${cleanNum}`;
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿßŸÑŸÅŸäŸÑŸÖ:') return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑŸÅŸäŸÑŸÖ ${cleanNum}`;
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿßŸÑŸÅŸäŸÑŸÖ ÿßŸÑÿ™ÿπÿßŸàŸÜŸä:') return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑŸÅŸäŸÑŸÖ ÿßŸÑÿ™ÿπÿßŸàŸÜŸä ${cleanNum}`;
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿßŸÑŸÇÿµÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ©:') return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑŸÇÿµÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ© - ÿ≠ŸÑŸÇÿ© ${cleanNum}`;
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿßŸÑÿ£ŸàŸÅÿß:') return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑÿ£ŸàŸÅÿß - ÿ≠ŸÑŸÇÿ© ${cleanNum}`;
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿßŸÑÿ≠ŸÑŸÇÿ© ÿßŸÑÿÆÿßÿµÿ©:') return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑÿ≠ŸÑŸÇÿ© ÿßŸÑÿÆÿßÿµÿ© ${cleanNum}`;
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ:') return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ - ÿ≠ŸÑŸÇÿ© ${cleanNum}`;
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿ≠ŸÑŸÇÿ© ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà:') {
                            if (s.includes('ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1')) return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà (ÿ¨1) - ÿ≠ŸÑŸÇÿ© ${numOnly}`;
                            if (s.includes('ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2')) return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà (ÿ¨2) - ÿ≠ŸÑŸÇÿ© ${numOnly}`;
                            return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà - ÿ≠ŸÑŸÇÿ© ${cleanNum}`;
                        }
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿ≠ŸÑŸÇÿ© ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà:') return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ŸäŸàŸÖŸäÿßÿ™ ÿßŸÑÿ≤Ÿäÿ±Ÿà - ÿ≠ŸÑŸÇÿ© ${cleanNum}`;
                        if (cleanLabel === 'ÿ±ŸÇŸÖ ÿ≠ŸÑŸÇÿ© ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß:') return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß - ÿ≠ŸÑŸÇÿ© ${cleanNum}`;
                        return `ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿßŸÑÿ≠ŸÑŸÇÿ© ${cleanNum}`;
                    } catch (e) { return 'ÿßŸÑÿ™ÿπŸÑŸäŸÇÿßÿ™'; }
                },
                activeFilters() {
                    const list = [];
                    if (this.selectedFilter && this.selectedFilter !== 'all') {
                        list.push({ key: 'selectedFilter', type: 'radio', value: this.selectedFilter });
                    }
                    if (this.episodeTypeFilter && this.episodeTypeFilter !== 'All') {
                        list.push({ key: 'episodeTypeFilter', type: 'radio', value: this.episodeTypeFilter });
                    }
                    for (const opt of (this.filterUi?.groupOptions || [])) {
                        if (this.getByKey(opt.modelKey)) list.push({ key: opt.modelKey, type: 'checkbox' });
                    }
                    for (const opt of (this.filterUi?.sceneOptions || [])) {
                        if (this.getByKey(opt.modelKey)) list.push({ key: opt.modelKey, type: 'checkbox' });
                    }
                    const ids = getAllCharacterIds(this.filterUi);
                    for (const id of ids) {
                        const baseKey = this.characterEpisodesKey(id);
                        if (this.getByKey(baseKey)) list.push({ key: baseKey, type: 'checkbox' });
                    }
                    return list;
                },
                activeFiltersCount() {
                    return this.activeFilters.length;
                },
                isGlobalBusy() {
                    const isEpisodeBusy = this.selectedEpisode?.EpisodeVideosIDs?.some(video => ['success', 'ratelimiting', 'sending'].includes(video.status)) ||
                                          this.selectedEpisode?.EpisodeMangasIDs?.some(manga => ['success', 'ratelimiting', 'sending'].includes(manga.status));
                    const isMangaBusy = ['success', 'ratelimiting', 'sending'].includes(this.selectedManga?.status);
                    return isEpisodeBusy || isMangaBusy;
                },
                directWindowCategories() {
                    return DIRECT_WINDOW_CONFIG.map(config => {
                        const isEpisodes = config.key === 'episodes';
                        const isMovies = config.key === 'movies';
                        const isMangas = config.key === 'mangas';
                        
                        let items = [];
                        let activeTabIndex = 0;
                        let selectedItem = null;
                        let handlers = {};
                        let gridData = [];
                        let listData = []; // For Episodes/Movies: groupedVideos
                        
                        if (isEpisodes) {
                            items = this.groupedEpisodes;
                            gridData = this.groupedEpisodes;
                            listData = this.groupedVideos;
                            activeTabIndex = this.activeTab.episodes;
                            selectedItem = this.selectedEpisode;
                            handlers = {
                                groupChange: this.handleEpisodeGroupChange,
                                resetView: this.resetEpisodesView,
                                selectItem: this.selectEpisode,
                                nextGroup: () => { this.navigateToNextEpisodeGroup(); this.resetStatusForEpisodeManga(); },
                                prevGroup: () => { this.navigateToPreviousEpisodeGroup(); this.resetStatusForEpisodeManga(); },
                                nextItem: () => { this.navigateToNextEpisode(); this.resetStatusForEpisodeManga(); },
                                prevItem: () => { this.navigateToPreviousEpisode(); this.resetStatusForEpisodeManga(); },
                                openModal: () => { this.preserveSelectedEpisodeOnModalClose = true; this.resetStatusForEpisodeManga(); this.openEpisodeModal(this.selectedEpisode.EpisodeNumber); }
                            };
                        } else if (isMovies) {
                            items = this.groupedMovies;
                            gridData = this.groupedMovies;
                            listData = this.groupedVideos;
                            activeTabIndex = this.activeTab.movies;
                            selectedItem = this.selectedEpisode; // Movies use selectedEpisode
                            handlers = {
                                groupChange: this.handleMovieGroupChange,
                                resetView: this.resetMoviesView,
                                selectItem: this.selectMovie,
                                nextGroup: () => { this.navigateToNextMovieGroup(); this.resetStatusForEpisodeManga(); },
                                prevGroup: () => { this.navigateToPreviousMovieGroup(); this.resetStatusForEpisodeManga(); },
                                nextItem: () => { this.navigateToNextMovie(); this.resetStatusForEpisodeManga(); },
                                prevItem: () => { this.navigateToPreviousMovie(); this.resetStatusForEpisodeManga(); },
                                openModal: () => { this.preserveSelectedEpisodeOnModalClose = true; this.resetStatusForEpisodeManga(); this.openEpisodeModal(this.selectedEpisode.EpisodeNumber); }
                            };
                        } else if (isMangas) {
                            items = this.groupedMangas;
                            gridData = this.groupedMangas;
                            // Mangas don't use listData (groupedVideos) in the same way, handled separately or via single item
                            activeTabIndex = this.activeTab.mangas;
                            selectedItem = this.selectedManga;
                            handlers = {
                                groupChange: this.handleMangaGroupChange,
                                resetView: this.resetMangasView,
                                selectItem: this.selectManga,
                                nextGroup: () => { this.navigateToNextMangaGroup(); this.resetStatusForEpisodeManga(); },
                                prevGroup: () => { this.navigateToPreviousMangaGroup(); this.resetStatusForEpisodeManga(); },
                                nextItem: () => { this.navigateToNextManga(); this.resetStatusForEpisodeManga(); },
                                prevItem: () => { this.navigateToPreviousManga(); this.resetStatusForEpisodeManga(); }
                            };
                        }

                        // Determine navigation flags
                        let showNextGroup = false;
                        let showPrevGroup = false;
                        let hasNext = false;
                        let hasPrev = false;

                        if (isEpisodes) {
                            showNextGroup = this.showNextGroupButton;
                            showPrevGroup = this.showPreviousGroupButton;
                            hasNext = this.hasNextEpisode;
                            hasPrev = this.hasPreviousEpisode;
                        } else if (isMovies) {
                            showNextGroup = this.showNextMovieGroupButton;
                            showPrevGroup = this.showPreviousMovieGroupButton;
                            hasNext = this.hasNextMovie;
                            hasPrev = this.hasPreviousMovie;
                        } else if (isMangas) {
                            showNextGroup = this.showNextMangaGroupButton;
                            showPrevGroup = this.showPreviousMangaGroupButton;
                            hasNext = this.hasNextManga;
                            hasPrev = this.hasPreviousManga;
                        }

                        const getGridLabel = (item) => {
                            if (!item) return '';
                            if (isEpisodes) return item.EpisodeNumber;
                            if (isMovies) return item.EpisodeNumber.replace('ÿßŸÑŸÅŸäŸÑŸÖ ', '');
                            if (isMangas) return item.MangaNumber;
                            return '';
                        };

                        const getListTitle = () => {
                             if (isEpisodes) return this.selectedEpisode?.EpisodeNumber;
                             if (isMovies) return this.selectedEpisode?.EpisodeNumber.replace('ÿßŸÑŸÅŸäŸÑŸÖ ', '');
                             if (isMangas) return this.selectedManga?.MangaNumber;
                             return '';
                        };

                        return {
                            ...config,
                            items,
                            gridData,
                            listData,
                            activeTabIndex,
                            selectedItem,
                            handlers,
                            getGridLabel,
                            getListTitle,
                            navigation: {
                                showNextGroup,
                                showPrevGroup,
                                hasNext,
                                hasPrev
                            }
                        };
                    });
                },
                mangaStartNumberModel: {
                    get() {
                        return this.mangaStartNumber ?? '';
                    },
                    set(value) {
                        const normalized = this.normalizeNumericString(value).trim();

                        if (normalized === '') {
                            this.mangaStartNumber = null;
                            return;
                        }

                        const parsed = parseFloat(normalized);
                        if (isNaN(parsed)) {
                            this.mangaStartNumber = null;
                            return;
                        }

                        const clamped = Math.min(Math.max(parsed, this.minMangaNumber), this.maxMangaNumber);
                        this.mangaStartNumber = Math.round(clamped);
                    }
                },
                mangaEndNumberModel: {
                    get() {
                        return this.mangaEndNumber ?? '';
                    },
                    set(value) {
                        const normalized = this.normalizeNumericString(value).trim();

                        if (normalized === '') {
                            this.mangaEndNumber = null;
                            return;
                        }

                        const parsed = parseFloat(normalized);
                        if (isNaN(parsed)) {
                            this.mangaEndNumber = null;
                            return;
                        }

                        const clamped = Math.min(Math.max(parsed, this.minMangaNumber), this.maxMangaNumber);
                        this.mangaEndNumber = Math.round(clamped);
                    }
                },
                isFailedToFetch() {
                    const msg = (this.errorMessage || '').trim().toLowerCase();
                    if (!msg) return false;
                    return (
                        msg.includes('failed to fetch') ||
                        msg.includes('load failed') ||
                        msg.includes('networkerror when attempting to fetch resource') ||
                        msg.includes('network error')
                    );
                },
                displayErrorPrimary() {
                    return this.isFailedToFetch
                        ? 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ÿå ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.'
                        : this.errorMessage;
                },
                displayErrorSecondary() {
                    return this.isFailedToFetch
                        ? 'ŸÅŸä ÿ≠ÿßŸÑ ÿßÿ≥ÿ™ŸÖÿ±ÿßÿ± ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©ÿå ÿ¨ÿ±Ÿëÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ VPN.'
                        : '';
                },
                showErrorOverlay() {
                    return Boolean(
                        ((this.errorMessage || '').trim()) ||
                        (this.selectedEpisode?.EpisodeMangasIDs?.some(manga => manga.status === 'error')) ||
                        (this.selectedEpisode?.EpisodeVideosIDs?.some(video => video.status === 'error')) ||
                        (this.episodeTrailers?.some(trailer => trailer.status === 'error')) ||
                        (this.selectedManga?.status === 'error') ||
                        (this.selectedEpisode?.status === 'error')
                    );
                },
                episodeSendInProgress() {
                    const episode = this.selectedEpisode;
                    if (!episode) return false;
                    if (Array.isArray(episode.EpisodeVideosIDs) && episode.EpisodeVideosIDs.some(v => v?.status === 'sending')) return true;
                    if (Array.isArray(episode.EpisodeMangasIDs) && episode.EpisodeMangasIDs.some(m => m?.status === 'sending')) return true;
                    return false;
                },
                directSendInProgress() {
                    return Boolean(this.episodeSendInProgress || this.selectedManga?.status === 'sending');
                },
                trailerSendInProgress() {
                    const trailers = this.activeTrailerProviderTrailers;
                    if (Array.isArray(trailers) && trailers.some(t => t?.status === 'sending')) return true;
                    if (Array.isArray(this.episodeTrailers) && this.episodeTrailers.some(t => t?.status === 'sending')) return true;
                    return false;
                },
                anySendInProgress() {
                    return Boolean(this.directSendInProgress || this.trailerSendInProgress);
                },
                effectiveDailyDownloads() {
                    return Math.min(this.safeMaxDailyDownloads, this.dailyDownloads);
                },
                effectiveRemainingDownloads() {
                    return Math.max(0, this.safeMaxDailyDownloads - this.effectiveDailyDownloads);
                },
                safeMaxDailyDownloads() {
                    return this.maxDailyDownloads > 0 ? this.maxDailyDownloads : 100;
                },
                remainingDownloads() {
                    return Math.max(0, this.maxDailyDownloads - (this.dailyDownloads + this.pendingDailyIncrements));
                },
                remainingDownloadsLabel() {
                    const n = this.remainingDownloads;
                    if (n === 1) return 'ŸÅÿµŸÑ';
                    if (n === 2) return 'ŸÅÿµŸÑŸäŸÜ';
                    if (n >= 3 && n <= 10) return 'ŸÅÿµŸàŸÑ';
                    return 'ŸÅÿµŸÑ';
                },
                timeUntilReset() {
                    // Calculate time until next UTC midnight (00:00 UTC)
                    // Matches Cloudflare Workers & Pages Functions reset time (UTC+0)
                    const tick = this.now;
                    const now = this.getTrustedDate();
                    const target = new Date(now);
                    if (this.testMinuteReset) {
                        target.setUTCSeconds(0, 0);
                        target.setUTCMinutes(target.getUTCMinutes() + 1);
                    } else {
                        target.setUTCHours(24, 0, 0, 0); // Sets to 00:00:00 UTC of the next day
                    }
                    const diff = target - now;
                    if (diff < 0) return "00:00:00"; // Should not happen with setUTCHours(24)

                    const hours = Math.floor(diff / (1000 * 60 * 60));
                    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                    
                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                },


                formattedInactivityCountdown() {
                    const minutes = Math.floor(this.inactivityCountdown / 60)
                        .toString()
                        .padStart(2, '0');
                    const seconds = (this.inactivityCountdown % 60)
                        .toString()
                        .padStart(2, '0');
                    return `${minutes}:${seconds}`;
                },

                strokeDashOffset() {
                    return this.circumference - (this.loadProgress / 100) * this.circumference;
                },

                groupedEpisodes() {
                    // Sort episodes by EpisodeNumber numerically
                    const validEpisodes = this.episodes
                        .filter(e => 
                            e.EpisodeVideosIDs && e.EpisodeVideosIDs.length > 0 &&
                            !e.EpisodeNumber.includes('ÿßŸÑŸÅŸäŸÑŸÖ') &&
                            !e.EpisodeNumber.includes('ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©') &&
                            !e.EpisodeNumber.includes('ÿ£ŸàŸÅÿß') &&
                            !e.EpisodeNumber.includes('ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ') &&
                            !e.EpisodeNumber.includes('ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà') &&
                            !e.EpisodeNumber.includes('ŸÅŸäŸÑŸÖ ÿ™ÿπÿßŸàŸÜŸä') &&
                            !e.EpisodeNumber.includes('ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà') &&
                            !e.EpisodeNumber.includes('ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß') &&
                            // Ensure EpisodeNumber is a valid number (including decimals)
                            !isNaN(parseFloat(e.EpisodeNumber)) && isFinite(parseFloat(e.EpisodeNumber))
                        )
                        .sort((a, b) => parseFloat(a.EpisodeNumber) - parseFloat(b.EpisodeNumber));

                    // Manually defined episode ranges
                    const ranges = [
                        { start: 1, end: 99 },
                        { start: 100, end: 199 },
                        { start: 200, end: 299 },
                        { start: 300, end: 399 },
                        { start: 400, end: 499 },
                        { start: 500, end: 599 },
                        { start: 600, end: 699 },
                        { start: 700, end: 799 },
                        { start: 800, end: 899 },
                        { start: 900, end: 999 },
                        { start: 1000, end: 1099 },
                        { start: 1100, end: 1199 }
                    ];
                    
                    const groups = [];
                    
                    // Filter episodes into each range
                    for (const range of ranges) {
                        const groupEpisodes = validEpisodes.filter(ep => {
                            const epNum = parseFloat(ep.EpisodeNumber);
                            return epNum >= range.start && epNum <= range.end;
                        });
                        
                        if (groupEpisodes.length > 0) {
                            groups.push({
                                range: `${range.start}‚Äì${range.end}`,
                                items: groupEpisodes
                            });
                        }
                    }
                    
                    return groups;
                },

                groupedMovies() {
                    const chunkSize = 29;
                    return this.episodes
                        .filter(e => (e.EpisodeNumber.includes('ÿßŸÑŸÅŸäŸÑŸÖ') || e.EpisodeNumber.includes('ŸÅŸäŸÑŸÖ ÿ™ÿπÿßŸàŸÜŸä')) && !e.EpisodeNumber.includes('ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ'))
                        .reduce((acc, _, i, arr) => (i % chunkSize) ? acc : 
                            [...acc, { 
                                range: `${i+1}-${Math.min(i+chunkSize, arr.length)}`, 
                                items: arr.slice(i, i+chunkSize)
                            }], []);
                },

                groupedMangas() {
                    const mangaSources = Array.isArray(this.mangas) ? this.mangas : [];
                    const episodeSources = Array.isArray(this.episodes) ? this.episodes : [];

                    const allMangas = [
                        ...mangaSources.flatMap(m => Array.isArray(m.MangasIDs) ? m.MangasIDs : []),
                        ...episodeSources.flatMap(e => Array.isArray(e.EpisodeMangasIDs) ? e.EpisodeMangasIDs : [])
                    ].filter(manga => manga && (manga.MangaNumber === 0 || manga.MangaNumber === "0" || manga.MangaNumber))
                     .sort((a, b) => Number(a.MangaNumber) - Number(b.MangaNumber));

                    if (!allMangas.length) {
                        return [];
                    }

                    // Remove duplicates by MangaNumber
                    const uniqueMangas = Array.from(new Set(allMangas.map(m => m.MangaNumber)))
                        .map(mangaNumber => allMangas.find(m => m.MangaNumber === mangaNumber));

                    const chunkSize = 100;
                    return uniqueMangas.reduce((acc, _, i, arr) => {
                        if (i % chunkSize === 0) {
                            return [
                                ...acc,
                                {
                                    range: `${arr[i].MangaNumber}-${arr[Math.min(i + chunkSize - 1, arr.length - 1)].MangaNumber}`,
                                    items: arr.slice(i, i + chunkSize)
                                }
                            ];
                        }
                        return acc;
                    }, []);
                },

                mangaQueueProgress() {
                    if (this.mangaQueueStats.total === 0) return 0;
                    const completed = this.mangaQueueStats.sent + this.mangaQueueStats.failed;
                    return Math.round((completed / this.mangaQueueStats.total) * 100);
                },

                allFailedMangaRowsSucceeded() {
                    return this.mangaFailedLog.length > 0 && this.mangaFailedLog.every(e => e.status === 'success');
                },

                isAnyMangaQueueRunning() {
                    return this.isMangaQueueRunning || this.isRetryAllFailedRunning;
                },

                sortedMangaSentLog() {
                    // Sort by chapter number (ascending: lower to upper)
                    return [...this.mangaSentLog].sort((a, b) => {
                        const numA = parseFloat(a.chapter);
                        const numB = parseFloat(b.chapter);
                        if (isNaN(numA) || isNaN(numB)) {
                            // Fallback to string comparison if not numeric
                            return String(a.chapter).localeCompare(String(b.chapter));
                        }
                        return numA - numB;
                    });
                },

                minMangaNumber() {
                    const allMangas = this.groupedMangas.flatMap(group => group.items);
                    if (allMangas.length === 0) return 0;
                    const numbers = allMangas.map(m => parseFloat(m.MangaNumber)).filter(n => !isNaN(n));
                    return numbers.length > 0 ? Math.min(...numbers) : 0;
                },

                maxMangaNumber() {
                    const allMangas = this.groupedMangas.flatMap(group => group.items);
                    if (allMangas.length === 0) return 0;
                    const numbers = allMangas.map(m => parseFloat(m.MangaNumber)).filter(n => !isNaN(n));
                    return numbers.length > 0 ? Math.max(...numbers) : 0;
                },

                hasNextEpisode() {
                    if (!this.selectedEpisode || !this.groupedEpisodes[this.activeTab.episodes]) {
                        return false;
                    }
                    const currentGroup = this.groupedEpisodes[this.activeTab.episodes].items;
                    const currentIndex = currentGroup.findIndex(ep => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    return currentIndex !== -1 && currentIndex < currentGroup.length - 1;
                },

                hasPreviousEpisode() {
                    if (!this.selectedEpisode || !this.groupedEpisodes[this.activeTab.episodes]) {
                        return false;
                    }
                    const currentGroup = this.groupedEpisodes[this.activeTab.episodes].items;
                    const currentIndex = currentGroup.findIndex(ep => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    return currentIndex !== -1 && currentIndex > 0;
                },

                isLastEpisodeInGroup() {
                    if (!this.selectedEpisode || !this.groupedEpisodes[this.activeTab.episodes]) {
                        return false;
                    }
                    const currentGroup = this.groupedEpisodes[this.activeTab.episodes].items;
                    const currentIndex = currentGroup.findIndex(ep => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    return currentIndex !== -1 && currentIndex === currentGroup.length - 1;
                },

                isFirstEpisodeInGroup() {
                    if (!this.selectedEpisode || !this.groupedEpisodes[this.activeTab.episodes]) {
                        return false;
                    }
                    const currentGroup = this.groupedEpisodes[this.activeTab.episodes].items;
                    const currentIndex = currentGroup.findIndex(ep => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    return currentIndex !== -1 && currentIndex === 0;
                },

                hasNextEpisodeGroup() {
                    if (!this.groupedEpisodes || this.groupedEpisodes.length === 0) {
                        return false;
                    }
                    return this.activeTab.episodes < this.groupedEpisodes.length - 1;
                },

                hasPreviousEpisodeGroup() {
                    if (!this.groupedEpisodes || this.groupedEpisodes.length === 0) {
                        return false;
                    }
                    return this.activeTab.episodes > 0;
                },

                showNextGroupButton() {
                    return this.isLastEpisodeInGroup && this.hasNextEpisodeGroup;
                },

                showPreviousGroupButton() {
                    return this.isFirstEpisodeInGroup && this.hasPreviousEpisodeGroup;
                },

                hasNextFilteredEpisode() {
                    if (!this.selectedEpisode) return false;
                    
                    const filteredEps = this.filteredEpisodes;
                    const currentIndex = filteredEps.findIndex(
                        ep => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber
                    );
                    
                    return currentIndex !== -1 && currentIndex < filteredEps.length - 1;
                },

                hasPreviousFilteredEpisode() {
                    if (!this.selectedEpisode) return false;
                    
                    const filteredEps = this.filteredEpisodes;
                    const currentIndex = filteredEps.findIndex(
                        ep => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber
                    );
                    
                    return currentIndex !== -1 && currentIndex > 0;
                },

                hasNextMovie() {
                    if (!this.selectedEpisode || !this.groupedMovies[this.activeTab.movies]) {
                        return false;
                    }
                    const currentGroup = this.groupedMovies[this.activeTab.movies].items;
                    const currentIndex = currentGroup.findIndex(movie => movie.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    return currentIndex !== -1 && currentIndex < currentGroup.length - 1;
                },

                groupedVideos() {
                    if (!this.selectedEpisode || !this.selectedEpisode.EpisodeVideosIDs) {
                        return [];
                    }

                    // Create a map to group videos by their unique combination of properties
                    const groups = new Map();
                    const noMetadataVideos = [];
                    
                    this.selectedEpisode.EpisodeVideosIDs.forEach((video, index) => {
                        // Check if video has any metadata
                        const hasMetadata = video.EpisodeCategory || video.EpisodeTranslator || video.EpisodeRemastered;
                        
                        if (!hasMetadata) {
                            // Add to noMetadataVideos array with original index
                            noMetadataVideos.push({
                                ...video,
                                originalIndex: index
                            });
                            return;
                        }
                        
                        // Create a unique key for the group
                        const groupKey = `${video.EpisodeCategory || ''}-${video.EpisodeTranslator || ''}-${video.EpisodeRemastered || ''}`;
                        
                        if (!groups.has(groupKey)) {
                            // Create a new group
                            groups.set(groupKey, {
                                key: groupKey,
                                EpisodeCategory: video.EpisodeCategory,
                                EpisodeTranslator: video.EpisodeTranslator,
                                EpisodeRemastered: video.EpisodeRemastered,
                                hasMetadata: true,
                                videos: []
                            });
                        }
                        
                        // Add the video to its group with the original index
                        groups.get(groupKey).videos.push({
                            ...video,
                            originalIndex: index // Store the original index for sendEpisodeToBot
                        });
                    });
                    
                    // Convert the map to an array and sort the videos within each group by resolution
                    const groupedVideos = Array.from(groups.values()).map(group => ({
                        ...group,
                        hasMetadata: true,
                        videos: group.videos.sort((a, b) => {
                            // Extract numeric part of resolution for proper sorting
                            const resA = parseInt(a.Resolution) || 0;
                            const resB = parseInt(b.Resolution) || 0;
                            return resB - resA; // Sort in descending order (highest resolution first)
                        })
                    }));
                    
                    // If there are videos without metadata, add them as a special group
                    if (noMetadataVideos.length > 0) {
                        const sortedNoMetadataVideos = noMetadataVideos.sort((a, b) => {
                            const resA = parseInt(a.Resolution) || 0;
                            const resB = parseInt(b.Resolution) || 0;
                            return resB - resA;
                        });
                        
                        return [
                            {
                                key: 'no-metadata',
                                hasMetadata: false,
                                videos: sortedNoMetadataVideos
                            },
                            ...groupedVideos
                        ];
                    }
                    
                    return groupedVideos;
                },

                episodeTrailers() {
                    if (!this.selectedEpisode) return [];
                    const raw = this.selectedEpisode.EpisodeTrailersIDs;
                    if (!raw) return [];
                    if (Array.isArray(raw)) return raw.filter(Boolean);
                    if (typeof raw === 'string') {
                        try {
                            const parsed = JSON.parse(raw);
                            if (Array.isArray(parsed)) return parsed.filter(Boolean);
                            if (parsed && typeof parsed === 'object') return [parsed];
                            return [];
                        } catch (e) {
                            return [];
                        }
                    }
                    if (raw && typeof raw === 'object') return [raw];
                    return [];
                },

                groupedTrailers() {
                    const trailers = this.episodeTrailers;
                    if (!trailers.length) return [];

                    const hasNumbers = trailers.some(t => t && t.TrailerNumber !== undefined && t.TrailerNumber !== null && String(t.TrailerNumber).trim() !== '');
                    const groups = new Map();

                    trailers.forEach((t) => {
                        const number = hasNumbers ? String(t.TrailerNumber ?? '').trim() : '';
                        const key = number || 'default';
                        if (!groups.has(key)) {
                            groups.set(key, { key, label: number ? `ÿ•ÿπŸÑÿßŸÜ ${number}` : 'ÿßŸÑÿ•ÿπŸÑÿßŸÜ', trailers: [] });
                        }
                        groups.get(key).trailers.push(t);
                    });

                    return Array.from(groups.values());
                },

                activeTrailerGroup() {
                    if (!this.groupedTrailers.length) return null;
                    const picked = this.groupedTrailers.find(g => g.key === this.selectedTrailerGroupKey);
                    return picked || this.groupedTrailers[0];
                },

                trailerMainButtonText() {
                    if (!this.selectedEpisode) return '';
                    return this.selectedEpisode.EpisodeNumber?.includes('ÿßŸÑŸÅŸäŸÑŸÖ')
                        ? 'ÿ£ÿ∂ÿ∫ÿ∑ ŸáŸÜÿß ŸÑŸÑŸÖÿ¥ÿßŸáÿØÿ©'
                        : 'ÿ£ÿ∂ÿ∫ÿ∑ ŸáŸÜÿß ŸÑŸÑŸÖÿ¥ÿßŸáÿØÿ©';
                },

                trailerModalTitleText() {
                    if (!this.selectedEpisode) return '';
                    const isMovie = !!this.selectedEpisode.EpisodeNumber?.includes('ÿßŸÑŸÅŸäŸÑŸÖ');
                    const isPlural = this.groupedTrailers.length > 1;
                    if (isPlural) {
                        return isMovie ? 'ÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿßŸÑŸÅŸäŸÑŸÖ' : 'ÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿßŸÑÿ≠ŸÑŸÇÿ©';
                    }
                    return isMovie ? 'ÿ•ÿπŸÑÿßŸÜ ÿßŸÑŸÅŸäŸÑŸÖ' : 'ÿ•ÿπŸÑÿßŸÜ ÿßŸÑÿ≠ŸÑŸÇÿ©';
                },

                activeTrailerProviders() {
                    const trailers = this.activeTrailerGroup?.trailers || [];
                    const byProvider = new Map();

                    trailers.forEach((t) => {
                        const label = (t?.Provider == null ? '' : String(t.Provider)).trim() || 'Server';
                        const key = label.toLowerCase();
                        if (!byProvider.has(key)) {
                            byProvider.set(key, { key, label });
                        }
                    });

                    return Array.from(byProvider.values());
                },

                activeTrailerProviderTrailers() {
                    const trailers = this.activeTrailerGroup?.trailers || [];
                    const key = (this.selectedTrailerProviderKey == null ? '' : String(this.selectedTrailerProviderKey)).toLowerCase();
                    if (!key) return [];
                    return trailers.filter(t => ((t?.Provider == null ? '' : String(t.Provider)).trim() || 'Server').toLowerCase() === key);
                },

                isActiveTrailerProviderTelegram() {
                    const key = (this.selectedTrailerProviderKey == null ? '' : String(this.selectedTrailerProviderKey)).toLowerCase();
                    return key === 'tg' || key.includes('telegram');
                },

                shouldShowTrailerProviderButtons() {
                    return this.activeTrailerProviders.length > 1;
                },

                trailerExternalUrl() {
                    const t = this.selectedTrailer;
                    if (!t) return '';
                    return this.buildTrailerExternalUrl(t.Provider, t.TrailerID);
                },

                trailerIframeKey() {
                    return `${this.selectedTrailerGroupKey || ''}-${this.selectedTrailerProviderKey || ''}-${this.trailerIframeSrc || ''}`;
                },

                seasonCountParts() {
                    const count = Number(this.selectedEpisode?.EpisodeSeasonCount);
                    if (!Number.isFinite(count) || count <= 0) return { numberText: '', suffixText: '' };
                    if (count === 1) return { numberText: '', suffixText: 'ÿ≠ŸÑŸÇÿ©' };
                    if (count === 2) return { numberText: '', suffixText: 'ÿ≠ŸÑŸÇÿ™ŸäŸÜ' };
                    if (count >= 3 && count <= 10) return { numberText: String(count), suffixText: 'ÿ≠ŸÑŸÇÿßÿ™' };
                    return { numberText: String(count), suffixText: 'ÿ≠ŸÑŸÇÿ©' };
                },

                hasPreviousMovie() {
                    if (!this.selectedEpisode || !this.groupedMovies[this.activeTab.movies]) {
                        return false;
                    }
                    const currentGroup = this.groupedMovies[this.activeTab.movies].items;
                    const currentIndex = currentGroup.findIndex(movie => movie.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    return currentIndex !== -1 && currentIndex > 0;
                },

                isLastMovieInGroup() {
                    if (!this.selectedEpisode || !this.groupedMovies[this.activeTab.movies]) {
                        return false;
                    }
                    const currentGroup = this.groupedMovies[this.activeTab.movies].items;
                    const currentIndex = currentGroup.findIndex(movie => movie.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    return currentIndex !== -1 && currentIndex === currentGroup.length - 1;
                },

                isFirstMovieInGroup() {
                    if (!this.selectedEpisode || !this.groupedMovies[this.activeTab.movies]) {
                        return false;
                    }
                    const currentGroup = this.groupedMovies[this.activeTab.movies].items;
                    const currentIndex = currentGroup.findIndex(movie => movie.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    return currentIndex !== -1 && currentIndex === 0;
                },

                hasNextMovieGroup() {
                    if (!this.groupedMovies || this.groupedMovies.length === 0) {
                        return false;
                    }
                    return this.activeTab.movies < this.groupedMovies.length - 1;
                },

                hasPreviousMovieGroup() {
                    if (!this.groupedMovies || this.groupedMovies.length === 0) {
                        return false;
                    }
                    return this.activeTab.movies > 0;
                },

                showNextMovieGroupButton() {
                    return this.isLastMovieInGroup && this.hasNextMovieGroup;
                },

                showPreviousMovieGroupButton() {
                    return this.isFirstMovieInGroup && this.hasPreviousMovieGroup;
                },

                hasNextManga() {
                    if (!this.selectedManga || !this.groupedMangas[this.activeTab.mangas]) {
                        return false;
                    }
                    const currentGroup = this.groupedMangas[this.activeTab.mangas].items;
                    const currentIndex = currentGroup.findIndex(manga => manga.MangaNumber === this.selectedManga.MangaNumber);
                    return currentIndex !== -1 && currentIndex < currentGroup.length - 1;
                },

                hasPreviousManga() {
                    if (!this.selectedManga || !this.groupedMangas[this.activeTab.mangas]) {
                        return false;
                    }
                    const currentGroup = this.groupedMangas[this.activeTab.mangas].items;
                    const currentIndex = currentGroup.findIndex(manga => manga.MangaNumber === this.selectedManga.MangaNumber);
                    return currentIndex !== -1 && currentIndex > 0;
                },

                isLastMangaInGroup() {
                    if (!this.selectedManga || !this.groupedMangas[this.activeTab.mangas]) {
                        return false;
                    }
                    const currentGroup = this.groupedMangas[this.activeTab.mangas].items;
                    const currentIndex = currentGroup.findIndex(manga => manga.MangaNumber === this.selectedManga.MangaNumber);
                    return currentIndex !== -1 && currentIndex === currentGroup.length - 1;
                },

                isFirstMangaInGroup() {
                    if (!this.selectedManga || !this.groupedMangas[this.activeTab.mangas]) {
                        return false;
                    }
                    const currentGroup = this.groupedMangas[this.activeTab.mangas].items;
                    const currentIndex = currentGroup.findIndex(manga => manga.MangaNumber === this.selectedManga.MangaNumber);
                    return currentIndex !== -1 && currentIndex === 0;
                },

                hasNextMangaGroup() {
                    if (!this.groupedMangas || this.groupedMangas.length === 0) {
                        return false;
                    }
                    return this.activeTab.mangas < this.groupedMangas.length - 1;
                },

                hasPreviousMangaGroup() {
                    if (!this.groupedMangas || this.groupedMangas.length === 0) {
                        return false;
                    }
                    return this.activeTab.mangas > 0;
                },

                showNextMangaGroupButton() {
                    return this.isLastMangaInGroup && this.hasNextMangaGroup;
                },

                showPreviousMangaGroupButton() {
                    return this.isFirstMangaInGroup && this.hasPreviousMangaGroup;
                },

                episodeOfWeek() {
                    const enableEpisodeDebug = false; // Set to true to enable debug logging
                    const episode = this.episodes.find(e => e.EpisodeNumber === String(this.ep));
                    if (enableEpisodeDebug) console.log('episodeOfWeek - ep:', this.ep, 'found episode:', episode);
                    return episode;
                },

                filteredEpisodes() {
                    const rawSearchQuery = this.normalizeDigits(this.searchQuery.trim().toLowerCase());
                    const searchQuery = this.normalizeText(this.searchQuery);
                    let searchRegex = null;
                    if (searchQuery) {
                        try {
                            searchRegex = new RegExp(searchQuery, 'i');
                        } catch (e) {
                            searchRegex = null;
                        }
                    }
                    const parsedNumberSearch = this.searchFilters.number && rawSearchQuery
                        ? this.parseNumberSearchParts(rawSearchQuery)
                        : null;

                    const normalizedNoBraces = rawSearchQuery
                        .replace(/\{\s*ÿ¨\s*[12]\s*\}/g, '')
                        .replace(/\(\s*ÿ¨\s*[12]\s*\)/g, '')
                        .trim();
                    const containsMagicKaito = /(^|[\sÿå,])ŸÖÿßÿ¨ŸäŸÉ\s+ŸÉÿßŸäÿ™Ÿà($|[\sÿå,])/i.test(normalizedNoBraces);
                    const containsFilm = /(^|[\sÿå,])(ÿßŸÑŸÅŸäŸÑŸÖ|ŸÅŸäŸÑŸÖ|ÿßŸÑŸÅŸÑŸÖ|ŸÅŸÑŸÖ|ÿßŸÑŸÅŸÑŸäŸÖ|ŸÅŸÑŸäŸÖ)($|[\sÿå,])/i.test(normalizedNoBraces);
                    const skipCategoryFilter = !!this.searchQuery && (containsMagicKaito || containsFilm);
                    let filteredByType = applyEpisodeTypeFilter(this.episodes, this.episodeTypeFilter);
                    filteredByType = applyToggleFilters(filteredByType, this, EPISODE_TOGGLE_FILTERS);
                    filteredByType = applyCharacterFilters(filteredByType, this, FILTER_UI);
                    
                    // Filter for FBI Episodes
                    if (this.filterFBI) {
                        filteredByType = filteredByType.filter(episode => episode.EpisodeEvents.includes('ŸÅ'));
                    }
                    // Filter for PSB Episodes
                    if (this.filterPSB) {
                        filteredByType = filteredByType.filter(episode => episode.EpisodeEvents.includes('ÿπ'));
                    }
                    // Filter for New Character Episodes
                    if (this.filterNewCharacter) {
                        filteredByType = filteredByType.filter(episode => episode.EpisodeEvents.includes('ÿ¨'));
                    }
                    // Filter for Development Character Episodes
                    if (this.filterDevelopmentCharacter) {
                        filteredByType = filteredByType.filter(episode => episode.EpisodeEvents.includes('ÿ™'));
                    }
                    // Filter for Flash Back Episodes
                    if (this.filterFlashBackEpisodes) {
                        filteredByType = filteredByType.filter(episode => episode.EpisodeEvents.includes('ŸÖ'));
                    }

                    // Filter for Romance Episodes
                    if (this.filterRomanceEpisodes) {
                        filteredByType = filteredByType.filter(episode => episode.EpisodeEvents.includes('ÿ±'));
                    }

                    // Apply other filters (e.g., category and search query)
                    return filteredByType
                    .filter(episode => {
                        if (skipCategoryFilter) return true;
                        if (this.selectedFilter === 'anime') {
                            return /^[0-9]+(\.[0-9]+)?$/.test(episode.EpisodeNumber);
                        } else if (this.selectedFilter === 'movies') {
                            return (episode.EpisodeNumber.includes("ÿßŸÑŸÅŸäŸÑŸÖ") || episode.EpisodeNumber.includes("ŸÅŸäŸÑŸÖ ÿ™ÿπÿßŸàŸÜŸä")) && !episode.EpisodeNumber.includes("ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ");
                        } else if (this.selectedFilter === 'hourly_special') {
                            return episode.EpisodeSpecial === "1";
                        } else if (this.selectedFilter === 'two_hour_special') {
                            return episode.EpisodeSpecial === "2";
                        } else if (this.selectedFilter === 'short_story') {
                            return episode.EpisodeNumber.includes("ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©");
                        } else if (this.selectedFilter === 'ova') {
                            return episode.EpisodeNumber.includes("ÿ£ŸàŸÅÿß");
                        } else if (this.selectedFilter === 'movie_special') {
                            const isMovieSpecial = episode.EpisodeNumber.includes("ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ") || episode.EpisodeTitle.includes("ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ");
                            const isSpecialRelease1 = String(episode.EpisodeNumber || '').trim() === "ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ 1";
                            return isMovieSpecial && !isSpecialRelease1;
                        } else if (this.selectedFilter === 'special_release') {
                            return episode.EpisodeNumber.includes("ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ");
                        } else if (this.selectedFilter === 'magic_kaito') {
                            return episode.EpisodeNumber.includes("ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà");
                        } else if (this.selectedFilter === 'zero_diaries') {
                            return episode.EpisodeNumber.includes("ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà");
                        } else if (this.selectedFilter === 'criminal_hanzawa') {
                            return episode.EpisodeNumber.includes("ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß");
                        }
                        return true;
                    })
                    .filter(episode => {
                        if (searchQuery === "") return true; // Show all episodes when search bar is empty
                        
                        // Build an array of conditions based on checked filters
                        const matchConditions = [];
                        
                        // Number filter logic
                        if (this.searchFilters.number) {
                            const numberList = parsedNumberSearch ? parsedNumberSearch.numberList : [];
                            const textFragments = parsedNumberSearch ? parsedNumberSearch.textFragments : [];
                            const textFragmentRegexes = parsedNumberSearch ? parsedNumberSearch.textFragmentRegexes : [];

                            // Extract number from episode.EpisodeNumber based on textNumberMatchMode
                            let numberConditionEvaluated = false;
                            let numberMatch = false;

                            if (numberList.length) {
                                numberConditionEvaluated = true;
                                let episodeNumber;
                                if (this.textNumberMatchMode === 'enabled') {
                                    const episodeNumberMatch = episode.EpisodeNumber.toString().match(/\d+\.?\d*$/);
                                    episodeNumber = episodeNumberMatch ? episodeNumberMatch[0] : episode.EpisodeNumber;
                                } else {
                                    episodeNumber = episode.EpisodeNumber.toString();
                                }

                                numberMatch = numberList.includes(episodeNumber);
                            }

                            if (textFragments.length) {
                                numberConditionEvaluated = true;
                                const episodeNumberText = this.normalizeDigits(String(episode.EpisodeNumber || '')).toLowerCase();
                                const normalizedEpisodeNumberText = this.normalizeEpisodeIdentifier(episodeNumberText);

                                numberMatch = numberMatch || textFragmentRegexes.some(regex => (regex ? regex.test(episodeNumberText) : false));
                                if (!numberMatch) {
                                    numberMatch = textFragments.some(fragment =>
                                        normalizedEpisodeNumberText.includes(this.normalizeEpisodeIdentifier(fragment))
                                    );
                                }
                                if (!numberMatch) {
                                    const formattedEpisodeNumberText = this.normalizeDigits(String(this.formatEpisodeNumber(episode.EpisodeNumber) || '')).toLowerCase();
                                    const normalizedFormattedEpisodeNumberText = this.normalizeEpisodeIdentifier(formattedEpisodeNumberText);
                                    numberMatch = numberMatch || textFragmentRegexes.some(regex => (regex ? regex.test(formattedEpisodeNumberText) : false));
                                    if (!numberMatch) {
                                        numberMatch = textFragments.some(fragment =>
                                            normalizedFormattedEpisodeNumberText.includes(this.normalizeEpisodeIdentifier(fragment))
                                        );
                                    }
                                }
                            }

                            if (numberConditionEvaluated) {
                                matchConditions.push(numberMatch);
                            }
                        }
                        
                        // Title filter logic
                        if (this.searchFilters.title) {
                            const titleText = String(episode.EpisodeTitle || '');
                            matchConditions.push(searchRegex ? searchRegex.test(titleText) : titleText.toLowerCase().includes(rawSearchQuery));
                        }
                        
                        // Story filter logic
                        if (this.searchFilters.story) {
                            const storyText = String(episode.EpisodeStory || '');
                            matchConditions.push(searchRegex ? searchRegex.test(storyText) : storyText.toLowerCase().includes(rawSearchQuery));
                        }
                        
                        // Summary filter logic
                        if (this.searchFilters.summary) {
                            const summaryText = String(episode.EpisodeSummary || '');
                            matchConditions.push(searchRegex ? searchRegex.test(summaryText) : summaryText.toLowerCase().includes(rawSearchQuery));
                        }
                        
                        // Return true if ANY condition is true (OR logic)
                        return matchConditions.length > 0 && matchConditions.some(condition => condition);
                    });
                },

                ...buildPredicateCountComputed(EPISODE_TYPE_COUNT_PREDICATES),
                ...buildPredicateCountComputed(CATEGORY_COUNT_PREDICATES),
                ...buildToggleCountComputed(FILTER_UI, EPISODE_TOGGLE_FILTERS),
                ...buildCharacterCountComputed(FILTER_UI),

                totalPages() {
                    return Math.ceil(this.filteredEpisodes.length / this.pageSize);
                },
                displayCurrentPage() {
                    return this.totalPages === 0 ? 0 : this.currentPage;
                },
                paginatedEpisodes() {
                    const start = (this.currentPage - 1) * this.pageSize;
                    return this.filteredEpisodes.slice(start, start + this.pageSize);
                },
                totalEpisodes() {
                    return this.filteredEpisodes.length; // Calculates based on the filtered episodes
                },
                episodeCountText() {
                    const count = this.totalEpisodes;
                    if (count === 1) return 'ÿ≠ŸÑŸÇÿ©';
                    if (count === 2) return 'ÿ≠ŸÑŸÇÿ™ŸäŸÜ';
                    if (count >= 3 && count <= 10) return `${count} ÿ≠ŸÑŸÇÿßÿ™`;
                    return `${count} ÿ≠ŸÑŸÇÿ©`;
                },
                episodeNumberHeader() {
                    return this.selectedFilter === 'movies' ? 'ÿ±ŸÇŸÖ ÿßŸÑŸÅŸäŸÑŸÖ' : 'ÿ±ŸÇŸÖ ÿßŸÑÿ≠ŸÑŸÇÿ©';
                },
                episodeTitleHeader() {
                    return this.selectedFilter === 'movies' ? 'ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÅŸäŸÑŸÖ' : 'ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ≠ŸÑŸÇÿ©';
                },
                episodeTypeLegend() {
                    return this.selectedFilter === 'movies' ? 'ŸÜŸàÿπ ÿßŸÑŸÅŸäŸÑŸÖ' : 'ŸÜŸàÿπ ÿßŸÑÿ≠ŸÑŸÇÿ©';
                },

                selectedFilterLabel() {
                    const labels = {
                        all: 'ÿßŸÑŸÉŸÑ',
                        anime: 'ÿßŸÑÿ≠ŸÑŸÇÿßÿ™',
                        movies: 'ÿ£ŸÅŸÑÿßŸÖ',
                        hourly_special: 'ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ©)',
                        two_hour_special: 'ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ™ŸäŸÜ)',
                        short_story: 'ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©',
                        ova: 'ÿ£ŸàŸÅÿß',
                        movie_special: 'ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ',
                        special_release: 'ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ',
                        magic_kaito: 'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà',
                        zero_diaries: 'ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà',
                        criminal_hanzawa: 'ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß'
                    };
                    return labels[this.selectedFilter] || 'ÿßŸÑŸÉŸÑ';
                },

                episodeTypeFilterLabel() {
                    const labels = {
                        All: 'ÿßŸÑŸÉŸÑ',
                        Manga: 'ŸÖÿßŸÜÿ∫ÿß',
                        Filler: 'ŸÅŸêŸÑÿ±'
                    };
                    return labels[this.episodeTypeFilter] || 'ÿßŸÑŸÉŸÑ';
                },

                combinedFilterBadgeClasses() {
                    const isDefaultSelection = this.selectedFilter === 'all' && this.episodeTypeFilter === 'All';
                    return [
                        'inline-block text-base text-yellow-300 font-bold px-3 py-1 rounded transition-all duration-100',
                        isDefaultSelection ? 'text-yellow-300' : 'text-yellow-300'
                    ];
                },

                tooltipText() {
                    const f = this.selectedFilter;
                    const t = this.episodeTypeFilter;

                    if(f === 'all' && t === 'All') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ + ÿßŸÑÿ£ŸÅŸÑÿßŸÖ + ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ©) + ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ™ŸäŸÜ) + ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ© + ÿ£ŸàŸÅÿß + ÿÆÿßÿµÿ© ÿ®ÿßŸÑÿ£ŸÅŸÑÿßŸÖ + ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ + ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà + ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà + ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'all' && t === 'Manga') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ + ÿßŸÑÿ£ŸÅŸÑÿßŸÖ + ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ©) + ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ™ŸäŸÜ) + ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ© + ÿ£ŸàŸÅÿß + ÿÆÿßÿµÿ© ÿ®ÿßŸÑÿ£ŸÅŸÑÿßŸÖ + ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ + ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà + ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà + ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'all' && t === 'Filler') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ + ÿßŸÑÿ£ŸÅŸÑÿßŸÖ + ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ©) + ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ™ŸäŸÜ) + ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ© + ÿ£ŸàŸÅÿß + ÿÆÿßÿµÿ© ÿ®ÿßŸÑÿ£ŸÅŸÑÿßŸÖ + ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ + ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà + ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà + ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß (ŸÅŸêŸÑÿ±)';
                    if(f === 'anime' && t === 'All') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'anime' && t === 'Manga') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'anime' && t === 'Filler') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ (ŸÅŸêŸÑÿ±)';
                    if(f === 'movies' && t === 'All') return 'ÿπÿØÿØ ÿßŸÑÿ£ŸÅŸÑÿßŸÖ (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'movies' && t === 'Manga') return 'ÿπÿØÿØ ÿßŸÑÿ£ŸÅŸÑÿßŸÖ (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'movies' && t === 'Filler') return 'ÿπÿØÿØ ÿßŸÑÿ£ŸÅŸÑÿßŸÖ (ŸÅŸêŸÑÿ±)';
                    if(f === 'hourly_special' && t === 'All') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ≥ÿßÿπÿ© (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'hourly_special' && t === 'Manga') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ≥ÿßÿπÿ© (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'hourly_special' && t === 'Filler') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ≥ÿßÿπÿ© (ŸÅŸêŸÑÿ±)';
                    if(f === 'two_hour_special' && t === 'All') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ≥ÿßÿπÿ™ŸäŸÜ (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'two_hour_special' && t === 'Manga') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ≥ÿßÿπÿ™ŸäŸÜ (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'two_hour_special' && t === 'Filler') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ≥ÿßÿπÿ™ŸäŸÜ (ŸÅŸêŸÑÿ±)';
                    if(f === 'short_story' && t === 'All') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑŸÇÿµÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ© (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'short_story' && t === 'Manga') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑŸÇÿµÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ© (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'short_story' && t === 'Filler') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑŸÇÿµÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ© (ŸÅŸêŸÑÿ±)';
                    if(f === 'ova' && t === 'All') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿ£ŸàŸÅÿß (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'ova' && t === 'Manga') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿ£ŸàŸÅÿß (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'ova' && t === 'Filler') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿ£ŸàŸÅÿß (ŸÅŸêŸÑÿ±)';
                    if(f === 'movie_special' && t === 'All') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ®ÿßŸÑÿ£ŸÅŸÑÿßŸÖ (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'movie_special' && t === 'Manga') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ®ÿßŸÑÿ£ŸÅŸÑÿßŸÖ (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'movie_special' && t === 'Filler') return 'ÿπÿØÿØ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ®ÿßŸÑÿ£ŸÅŸÑÿßŸÖ (ŸÅŸêŸÑÿ±)';
                    if(f === 'special_release' && t === 'All') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'special_release' && t === 'Manga') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'special_release' && t === 'Filler') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ (ŸÅŸêŸÑÿ±)';
                    if(f === 'magic_kaito' && t === 'All') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'magic_kaito' && t === 'Manga') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'magic_kaito' && t === 'Filler') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà (ŸÅŸêŸÑÿ±)';
                    if(f === 'zero_diaries' && t === 'All') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'zero_diaries' && t === 'Manga') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'zero_diaries' && t === 'Filler') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà (ŸÅŸêŸÑÿ±)';
                    if(f === 'criminal_hanzawa' && t === 'All') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß (ŸÖÿßŸÜÿ∫ÿß + ŸÅŸêŸÑÿ±)';
                    if(f === 'criminal_hanzawa' && t === 'Manga') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß (ŸÖÿßŸÜÿ∫ÿß)';
                    if(f === 'criminal_hanzawa' && t === 'Filler') return 'ÿπÿØÿØ ÿ≠ŸÑŸÇÿßÿ™ ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß (ŸÅŸêŸÑÿ±)';

                    return '';
                },

                filterSignature() {
                    let sig = `${this.selectedFilter}|${this.episodeTypeFilter}`;
                    for (const key of FILTER_STATE_KEYS) {
                        sig += `|${key}:${this[key]}`;
                    }
                    return sig;
                },

                isAnyFilterActive() {
                    if (this.selectedFilter !== 'all' || this.episodeTypeFilter !== 'All') return true;
                    for (const key of FILTER_STATE_KEYS) {
                        if (this[key] !== FILTER_STATE_DEFAULTS[key]) return true;
                    }
                    return false;
                },
                showEpisodeTableCaptureButton() {
                    const isNumberSearchActive = (() => {
                        if (!this.searchFilters?.number) return false;
                        const rawSearchQuery = this.normalizeDigits(String(this.searchQuery || '').trim().toLowerCase());
                        if (!rawSearchQuery) return false;
                        const parsed = this.parseNumberSearchParts(rawSearchQuery);
                        return Array.isArray(parsed?.numberList) && parsed.numberList.length > 0;
                    })();

                    if (isNumberSearchActive) {
                        const rowCount = Number(this.totalEpisodes ?? (Array.isArray(this.filteredEpisodes) ? this.filteredEpisodes.length : 0));
                        if (rowCount < 1 || rowCount > 100) return false;
                        return true;
                    }

                    const allowedCategories = new Set([
                        'movies',
                        'hourly_special',
                        'two_hour_special',
                        'short_story',
                        'ova',
                        'movie_special',
                        'special_release',
                        'magic_kaito',
                        'zero_diaries',
                        'criminal_hanzawa',
                    ]);
                    if (allowedCategories.has(this.selectedFilter)) return true;

                    const allowedToggleKeys = [
                        'filterBlackOrganization',
                        'filterDetectiveBoys',
                        'filterFBI',
                        'filterPSB',
                        'filterPoliceAcademy',
                        'filterScaryEpisodes',
                        'filterSadyEpisodes',
                        'filterRomanceEpisodes',
                        'filterNewCharacter',
                        'filterDevelopmentCharacter',
                        'filterFlashBackEpisodes',
                    ];
                    const characterIds = Object.keys(this.filterUi?.characterLabels || {});
                    const characterBlacklist = new Set([
                        'ConanEdogawa',
                        'RanMouri',
                        'KogoroMouri',
                        'AyumiYoshida',
                        'MitsuhikoTsuburaya',
                        'GentaKojima',
                        'AiHaibara',
                        'SonokoSuzuki',
                        'HiroshiAgasa',
                        'JuzoMegure',
                        'NinzaburoShiratori',
                        'MiwakoSato',
                        'WataruTakagi',
                        'KazunobuChiba',
                    ]);
                    for (const id of characterIds) {
                        if (characterBlacklist.has(id)) continue;
                        allowedToggleKeys.push(this.characterEpisodesKey(id));
                    }
                    return allowedToggleKeys.some((key) => Boolean(this[key]));
                },
            },
                watch: {
                currentPage() {
                    this.comntoVisible = false;
                },
                pageSize() {
                    this.comntoVisible = false;
                },
                selectedFilter() {
                    this.comntoVisible = false;
                },
                commentsHeaderText(newVal) {
                    try {
                        if (this.debugModeCommentsHeader) {
                            console.log('commentsHeaderText:', newVal, 'context:', this.comntoContext, 'topic:', this.comntoTopic, 'episode:', this.selectedEpisode?.EpisodeNumber);
                        }
                    } catch (e) {}
                },
                comntoTopic(newVal) {
                    try {
                        const nextTopic = String(newVal || '');
                        if (this.debugModeComntoTopic) console.log('comntoTopic change:', nextTopic);
                        if (this.lastComntoTopicApplied === nextTopic) return;
                        const el = document.querySelector('#comments');
                        if (el) el.setAttribute('data-topic', nextTopic);
                        if (this.comntoWidget && typeof this.comntoWidget.reload === 'function') {
                            this.comntoWidget.reload({ topic: nextTopic });
                            this.lastComntoTopicApplied = nextTopic;
                            if (this.debugModeComntoTopic) console.log('reload({topic}) applied');
                        } else if (this.comntoWidget && typeof this.comntoWidget.setTopic === 'function') {
                            this.comntoWidget.setTopic(nextTopic);
                            this.lastComntoTopicApplied = nextTopic;
                            if (this.debugModeComntoTopic) console.log('setTopic applied');
                        } else if (this.comntoWidget && typeof this.comntoWidget.update === 'function') {
                            this.comntoWidget.update({ topic: nextTopic });
                            this.lastComntoTopicApplied = nextTopic;
                            if (this.debugModeComntoTopic) console.log('update({topic}) applied');
                        } else if (this.debugModeComntoTopic) {
                            console.warn('No reload/setTopic/update available on comntoWidget');
                        }
                    } catch {}
                },
                selectedEpisode(newVal) {
                    if (newVal) {
                        if (this.debugModeComntoTopic) {
                            console.log('selectedEpisode change:', newVal && newVal.EpisodeNumber);
                        }
                        this.comntoTopic = 'episode-' + newVal.EpisodeNumber;
                        // this.comntoVisible = true; // Let user open it manually
                    } else {
                        this.comntoTopic = 'mainPageCD';
                        this.comntoVisible = false; // Auto-close when leaving episode
                    }
                },
                jumpTargetMode(newVal) {
                    if (newVal === 'page') {
                        this.jumpInputActive = false;
                        this.jumpInput = `${this.displayCurrentPage}/${this.totalPages}`;
                    } else {
                        this.jumpInput = '';
                    }
                },
                currentPage() {
                    if (this.jumpTargetMode === 'page') {
                        if (!this.jumpInputActive) {
                            this.jumpInput = `${this.displayCurrentPage}/${this.totalPages}`;
                        }
                    }
                },
                totalPages() {
                    if (this.jumpTargetMode === 'page') {
                        if (!this.jumpInputActive) {
                            this.jumpInput = `${this.displayCurrentPage}/${this.totalPages}`;
                        }
                    }
                },
                jumpInput(newVal) {
                    const trimmed = String(newVal || '').trim();
                    if (this.jumpTargetMode === 'page') {
                        if (trimmed.endsWith('+') || trimmed.endsWith('=')) {
                            let val = this.normalizeDigits(trimmed.slice(0, -1).trim());
                            let num = parseInt(val, 10);
                            if (isNaN(num)) num = this.displayCurrentPage || 1;
                            if (num < 1) num = 1;
                            if (num > this.totalPages) num = this.totalPages;
                            this.handlePageSelect({ target: { value: num } });
                            this.jumpInput = String(this.displayCurrentPage);
                            return;
                        }
                        if (this.jumpInputActive) {
                            const val = this.normalizeDigits(trimmed);
                            let num = parseInt(val, 10);
                            if (isNaN(num)) return;
                            if (num < 1) num = 1;
                            if (num > this.totalPages) num = this.totalPages;
                            const next = String(num);
                            if (next !== trimmed) this.jumpInput = next;
                        }
                        return;
                    }
                    if (trimmed.endsWith('+') || trimmed.endsWith('=')) {
                        const targetValue = this.normalizeDigits(trimmed.slice(0, -1).trim());
                        if (!targetValue) {
                            this.pendingJumpTarget = null;
                            this.pendingJumpRegex = null;
                            this.pendingJumpOpenModal = false;
                            this.jumpInput = '';
                            return;
                        }
                        let jumpRegex = null;
                        if (trimmed.endsWith('=')) {
                            try {
                                const pattern = this.normalizeText(targetValue);
                                if (pattern) jumpRegex = new RegExp(`^${pattern}$`, 'i');
                            } catch (e) {
                                jumpRegex = null;
                            }
                        }
                        this.pendingJumpTarget = targetValue;
                        this.pendingJumpRegex = jumpRegex;
                        this.pendingJumpOpenModal = trimmed.endsWith('=');
                        this.jumpInput = '';
                        this.executePendingJump();
                        return;
                    }
                },
                episodeSendInProgress(newValue) {
                    if (!newValue) this.handleAutoCloseIfRequested('modal');
                },
                directSendInProgress(newValue) {
                    if (!newValue) this.handleAutoCloseIfRequested('directWindow');
                },
                trailerSendInProgress(newValue) {
                    if (!newValue) this.handleAutoCloseIfRequested('trailer');
                },
                loading(newValue) {
                    if (newValue) {
                        this.$nextTick(() => {
                            const container = document.getElementById('loading-bar-container');
                            if (container && !container.ldBar) {
                                new ldBar(container);
                            }
                            if (container && container.ldBar) {
                                container.ldBar.set(this.loadProgress);
                            }
                        });
                    }
                },
                loadProgress(newValue) {
                    const container = document.getElementById('loading-bar-container');
                    if (container && container.ldBar) {
                        container.ldBar.set(newValue);
                    }
                },
                inputSearchQuery(newVal) {
                    if (this.searchDebounceTimer) clearTimeout(this.searchDebounceTimer);
                    this.searchDebounceTimer = setTimeout(() => {
                        this.searchQuery = newVal;
                    }, 300);
                },
                selectedEpisode() {
                    // When episode changes, recalculate the countdown
                    this.relatedEpisodeMenuOpen = false;
                    this.$nextTick(() => {
                        this.calculateCountdown();
                    });
                },
                loading(newValue) {
                    // Stop zikr rotation when loading finishes
                    if (!newValue && this.intervalZikrId) {
                        clearInterval(this.intervalZikrId);
                        this.intervalZikrId = null;
                    }
                },
                searchQuery(newQuery) {
                    const trimmed = newQuery.trim();

                    if (trimmed.endsWith('+')) {
                        // Normalize digits so quick-jump works for Arabic-Indic/Persian numbers
                        const targetValue = this.normalizeDigits(trimmed.slice(0, -1).trim());

                        if (!targetValue) {
                            this.pendingJumpTarget = null;
                            if (this.searchQuery !== '') this.searchQuery = '';
                            return;
                        }

                        this.pendingJumpTarget = targetValue;
                        this.pendingJumpRegex = null;
                        this.pendingJumpOpenModal = false;
                        if (this.searchQuery !== '') this.searchQuery = '';
                        this.executePendingJump();
                        return;
                    }

                    if (trimmed.endsWith('=')) {
                        const targetValue = this.normalizeDigits(trimmed.slice(0, -1).trim());

                        if (!targetValue) {
                            this.pendingJumpTarget = null;
                            this.pendingJumpRegex = null;
                            this.pendingJumpOpenModal = false;
                            if (this.searchQuery !== '') this.searchQuery = '';
                            return;
                        }

                        let jumpRegex = null;
                        try {
                            const pattern = this.normalizeText(targetValue);
                            if (pattern) {
                                jumpRegex = new RegExp(`^${pattern}$`, 'i');
                            }
                        } catch (e) {
                            jumpRegex = null;
                        }

                        this.pendingJumpTarget = targetValue;
                        this.pendingJumpRegex = jumpRegex;
                        this.pendingJumpOpenModal = true;
                        if (this.searchQuery !== '') this.searchQuery = '';
                        this.executePendingJump();
                        return;
                    }

                    if (trimmed === '' && this.pendingJumpTarget) {
                        return;
                    }

                    if (trimmed === '') {
                        this.currentPage = Math.min(this.lastPage, this.totalPages) || 1;
                    } else {
                        this.currentPage = 1;
                    }
                },

                filterSignature() {
                    this.resetPageToOne();
                },

                jsonUrl() {
                    // Automatically refetch data when jsonUrl changes (only if tab owner)
                    if (this.isTabOwner) {
                        this.loadData();
                    }
                },

                pageSize(newSize) {
                    this.handlePageSizeChange();
                },
                comntoVisible(newVal) {
                    try {
                        const b = document.body;
                        if (!b) return;
                        if (newVal) {
                            b.classList.add('no-scroll');
                        } else {
                            b.classList.remove('no-scroll');
                        }
                    } catch (e) {}
                },
            },
            methods: {
                handleModalScroll(event) {
                    const container = event.target;
                    const label = this.$refs.episodeTitleLabel;
                    if (!container || !label) return;

                    const containerRect = container.getBoundingClientRect();
                    const labelRect = label.getBoundingClientRect();

                    // If the bottom of the label is above the top of the container
                    this.showStickyLabel = labelRect.top <= containerRect.top;
                },
                ensureComntoLoaded(onReady) {
                    if (this.comntoWidget) {
                        try { onReady && onReady(); } catch (e) {}
                        return;
                    }
                    if (this.comntoScriptLoading) {
                        if (onReady) this.comntoLoadingCallbacks.push(onReady);
                        return;
                    }
                    if (!this.comntoScriptLoaded) {
                        this.comntoScriptLoading = true;
                        if (onReady) this.comntoLoadingCallbacks.push(onReady);
                        const script = document.createElement('script');
                        script.src = 'https://comnto.com/embed.js';
                        script.defer = true;
                        script.onload = () => {
                            this.comntoScriptLoaded = true;
                            this.comntoScriptLoading = false;
                            this.initComntoWidget();
                            while (this.comntoLoadingCallbacks.length > 0) {
                                const cb = this.comntoLoadingCallbacks.shift();
                                try { cb && cb(); } catch (e) {}
                            }
                        };
                        document.head.appendChild(script);
                        return;
                    }
                    if (this.comntoScriptLoaded && window.comnto && !this.comntoWidget) {
                        this.initComntoWidget();
                        try { onReady && onReady(); } catch (e) {}
                    }
                },
                initComntoWidget() {
                    try {
                        if (!window.comnto) return;
                        this.comntoWidget = window.comnto({
                            el: '#comments',
                            site: 'dcref',
                            theme: 'auto',
                            locale: 'ar',
                            topic: String(this.comntoTopic || 'mainPageCD'),
                            localization: {
                                ar: {
                                    heading: { title: 'ÿßŸÑÿ™ÿπŸÑŸäŸÇÿßÿ™' }
                                }
                            }
                        });
                        try { this.comntoWidget.setDirection && this.comntoWidget.setDirection('rtl'); } catch (e) {}
                        this.lastComntoTopicApplied = String(this.comntoTopic || 'mainPageCD');
                        if (this.debugModeComntoTopic) {
                            const hasSetTopic = this.comntoWidget && typeof this.comntoWidget.setTopic === 'function';
                            const hasUpdate = this.comntoWidget && typeof this.comntoWidget.update === 'function';
                            console.log('Comnto widget init; setTopic:', hasSetTopic, 'update:', hasUpdate, 'topic:', this.comntoTopic);
                        }
                    } catch (e) {
                        if (this.debugModeComntoTopic) console.error('initComntoWidget error', e);
                    }
                },
                openComments(context) {
                    try {
                        this.comntoContext = context || 'main';
                        const desiredTopic = (this.comntoContext === 'modal' && this.selectedEpisode)
                            ? ('episode-' + this.selectedEpisode.EpisodeNumber)
                            : 'mainPageCD';
                        
                        const topicChanged = (this.comntoTopic !== desiredTopic);
                        if (topicChanged) this.comntoTopic = desiredTopic;

                        // Show immediately so user can close it if they want
                        this.comntoVisible = true;

                        this.ensureComntoLoaded(() => {
                            // Check if user closed the modal while loading
                            if (!this.comntoVisible) return;

                            // Initialize if not exists
                            if (!this.comntoWidget) {
                                this.initComntoWidget();
                                return;
                            }

                            // If topic changed, the watcher will handle the update.
                            // If topic is same, we do nothing (just show existing iframe) to save pageviews.
                        });
                    } catch (e) {
                        this.comntoVisible = true;
                    }
                },
                reinitComntoWidget(newTopic) {
                    try {
                        const topic = String(newTopic || this.comntoTopic || 'mainPageCD');
                        const container = document.getElementById('comments');
                        if (!container) return;
                        try {
                            const iframe = container.querySelector('iframe');
                            if (iframe) iframe.remove();
                            container.innerHTML = '';
                        } catch (e) {}
                        if (window.comnto) {
                            this.comntoWidget = window.comnto({
                                el: '#comments',
                                site: 'dcref',
                                theme: 'auto',
                                locale: 'ar',
                                topic,
                                localization: {
                                    ar: {
                                        heading: { title: 'ÿßŸÑÿ™ÿπŸÑŸäŸÇÿßÿ™' }
                                    }
                                }
                            });
                            try { this.comntoWidget.setDirection && this.comntoWidget.setDirection('rtl'); } catch (e) {}
                            this.lastComntoTopicApplied = topic;
                            if (this.debugModeComntoTopic) console.log('Comnto widget reinitialised with topic:', topic);
                        }
                    } catch (err) {
                        if (this.debugModeComntoTopic) console.error('Failed to reinit Comnto widget', err);
                    }
                },
                onJumpInputFocus() {
                    this.jumpInputActive = true;
                    if (this.jumpTargetMode === 'page') {
                        this.jumpInput = String(this.displayCurrentPage);
                    }
                },
                onJumpInputBlur() {
                    this.jumpInputActive = false;
                    if (this.jumpTargetMode === 'page') {
                        const trimmed = this.normalizeDigits(String(this.jumpInput || '').trim());
                        let num = parseInt(trimmed, 10);
                        if (!isNaN(num)) {
                            if (num < 1) num = 1;
                            if (num > this.totalPages) num = this.totalPages;
                            this.jumpInput = `${num}/${this.totalPages}`;
                        }
                    }
                },
                clearJumpInput() {
                    if (this.jumpTargetMode === 'page') {
                        this.jumpInputActive = false;
                        this.jumpInput = `${this.displayCurrentPage}/${this.totalPages}`;
                    } else {
                        this.jumpInput = '';
                    }
                },
                clearActiveFilterHighlight() {
                    const el = this.activeFilterHighlightedEl;
                    if (!el) return;
                    try {
                        el.classList.remove('bg-yellow-300', 'text-black', 'ring-2', 'ring-yellow-300', 'rounded');
                    } catch (e) {}
                    this.activeFilterHighlightedEl = null;
                },
                escapeMarkdown(text) {
                    return String(text).replace(/[_*[\]()~`>#+\-=|{}.!]/g, '\\$&');
                },
                isProfessionalTranslator(text) {
                    const n = normalizeTranslatorName(text);
                    if (!n) return false;
                    for (const token of PROFESSIONAL_TRANSLATOR_TOKENS) {
                        if (n.includes(token)) return true;
                    }
                    return false;
                },
                onFilterCheckboxChange(key, event) {
                    const checked = Boolean(event && event.target && event.target.checked);
                    this.setByKey(key, checked);
                    if (!checked) this.clearActiveFilterHighlight();
                },
                onFilterRadioChange(key, value) {
                    this.setByKey(key, value);
                    const inactive =
                        (key === 'selectedFilter' && value === 'all') ||
                        (key === 'episodeTypeFilter' && value === 'All');
                    if (inactive) this.clearActiveFilterHighlight();
                },
                cycleActiveFilterFocus() {
                    const list = this.activeFilters;
                    if (!Array.isArray(list) || list.length === 0) return;
                    this.activeFilterCycleIndex = (Number.isInteger(this.activeFilterCycleIndex) ? this.activeFilterCycleIndex : -1) + 1;
                    if (this.activeFilterCycleIndex >= list.length) this.activeFilterCycleIndex = 0;
                    const target = list[this.activeFilterCycleIndex];
                    if (!target || !target.key) return;
                    
                    let selector = `[data-filter-key="${String(target.key)}"]`;
                    if (target.type === 'radio' && target.value != null) {
                        selector += `[data-filter-value="${String(target.value)}"]`;
                    }
                    
                    const root = this.$refs?.emptyPopupRoot || this.$el || document;
                    let elem = null;
                    try {
                        elem = root.querySelector(selector) || document.querySelector(selector);
                    } catch (e) {
                        elem = document.querySelector(selector);
                    }
                    if (!elem) return;
                    
                    this.clearActiveFilterHighlight();
                    
                    try { elem.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) {}
                    try { elem.focus(); } catch (e) {}
                    
                    const label = elem.closest('label') || elem;
                    try {
                        label.classList.add('bg-yellow-300', 'text-black', 'ring-2', 'ring-yellow-300', 'rounded');
                    } catch (e) {}
                    this.activeFilterHighlightedEl = label;
                },
                // InstantDB Methods
                async syncServerTime() {
                    try {
                        const start = performance.now();
                        // Try current origin first (likely to have Date header)
                        // Or use a lightweight HEAD request to a reliable public server if local fails
                        const response = await fetch(window.location.href, { method: 'HEAD', cache: 'no-store' });
                        const dateHeader = response.headers.get('date');
                        
                        if (dateHeader) {
                            const serverTime = new Date(dateHeader).getTime();
                            const end = performance.now();
                            const latency = (end - start) / 2;
                            // Calculate offset: Server Time - (Local Time at request start + latency)
                            // But simpler: Server Time - (Date.now() roughly)
                            // More precise: 
                            // trustedNow = Date.now() + offset
                            // offset = serverTime - Date.now()
                            // We adjust for latency to be slightly more accurate
                            this.serverTimeOffset = serverTime - (Date.now() + latency);
                            this.lastServerSync = Date.now();
                            console.log('Time synced with server. Offset:', this.serverTimeOffset, 'ms');
                        } else {
                            console.warn('No Date header in response, using local time fallback.');
                        }
                    } catch (e) {
                        console.error('Failed to sync time:', e);
                        // Fallback: try worldtimeapi if origin fails (e.g. file://)
                        try {
                             const r = await fetch('https://worldtimeapi.org/api/timezone/Etc/UTC');
                             const data = await r.json();
                             const serverTime = new Date(data.utc_datetime).getTime();
                             this.serverTimeOffset = serverTime - Date.now();
                             console.log('Time synced with WorldTimeAPI. Offset:', this.serverTimeOffset, 'ms');
                        } catch (e2) {
                            console.warn('All time sync failed, defaulting to local time.');
                        }
                    }
                },

                getTrustedDate() {
                    return new Date(Date.now() + this.serverTimeOffset);
                },

                getTrustedTodayISO() {
                    return this.getTrustedDate().toISOString().split('T')[0];
                },

                getTrustedDayStartUtcMs() {
                    const d = this.getTrustedDate();
                    return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0, 0, 0, 0);
                },

                getByKey(key) {
                    if (!key) return undefined;
                    return this[key];
                },

                setByKey(key, value) {
                    if (!key) return;
                    this[key] = value;
                },

                characterEpisodesKey(id) {
                    return `filter${id}Episodes`;
                },

                characterLogicKey(id) {
                    return `filterLogic${id}`;
                },

                characterDetailKey(id, kind) {
                    return `filter${id}${kind}`;
                },

                characterCountKey(id) {
                    return `${id}EpisodesCount`;
                },

                characterDetailCountKey(id, kind) {
                    return `${id}${kind}Count`;
                },

                characterLabel(id) {
                    return (this.filterUi && this.filterUi.characterLabels && this.filterUi.characterLabels[id]) || id;
                },

                isCharacterSimple(id) {
                    const list = this.filterUi && this.filterUi.characterSimpleIds;
                    return Array.isArray(list) && list.includes(id);
                },

                isCharacterAdvanced(id) {
                    return !this.isCharacterSimple(id);
                },

                getCharacterGroupIds(title) {
                    const groups = this.filterUi && this.filterUi.characterGroups;
                    if (!Array.isArray(groups)) return [];
                    const g = groups.find(x => x && x.title === title);
                    return (g && Array.isArray(g.ids)) ? g.ids : [];
                },

                resetCharacterFilters(id) {
                    const episodesKey = this.characterEpisodesKey(id);
                    this[episodesKey] = false;

                    if (this.isCharacterAdvanced(id)) {
                        const logicKey = this.characterLogicKey(id);
                        if (logicKey in this) this[logicKey] = 'All';

                        const details = this.filterUi && this.filterUi.detailOptions;
                        if (Array.isArray(details)) {
                            for (const d of details) {
                                if (!d || !d.kind) continue;
                                const k = this.characterDetailKey(id, d.kind);
                                if (k in this) this[k] = false;
                            }
                        }
                    }
                },

                onCharacterToggle(id, checked) {
                    if (checked) {
                        this[this.characterEpisodesKey(id)] = true;
                        return;
                    }
                    this.clearActiveFilterHighlight();
                    this.resetCharacterFilters(id);
                },

                ...buildResetCharacterMethods(FILTER_UI),

                getDailyLimitStorageKey() {
                    return `dcrefbot-dailyLimitRowId:${String(this.userId)}`;
                },

                isUuidLike(value) {
                    return typeof value === 'string' && /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(value);
                },

                getStoredDailyLimitRowId() {
                    try {
                        const stored = localStorage.getItem(this.getDailyLimitStorageKey());
                        if (this.isUuidLike(stored)) {
                            return stored;
                        }
                        if (stored) {
                            localStorage.removeItem(this.getDailyLimitStorageKey());
                        }
                    } catch (e) {}
                    return null;
                },

                setStoredDailyLimitRowId(id) {
                    if (!this.isUuidLike(id)) return;
                    this.dailyLimitRowId = id;
                    this.dailyLimitRowIdRam = id;
                    try {
                        localStorage.setItem(this.getDailyLimitStorageKey(), id);
                    } catch (e) {}
                },

                startDailyLimitRowIdResync() {
                    if (this.dailyLimitRowIdResyncIntervalId) return;

                    const existing =
                        (this.isUuidLike(this.dailyLimitRowId) && this.dailyLimitRowId) ||
                        (this.isUuidLike(this.dailyLimitRowIdRam) && this.dailyLimitRowIdRam) ||
                        this.getStoredDailyLimitRowId();

                    if (existing) {
                        this.dailyLimitRowId = existing;
                        this.dailyLimitRowIdRam = existing;
                    } else {
                        const created = this.ensureDailyLimitRowId();
                        if (this.isUuidLike(created)) {
                            this.dailyLimitRowId = created;
                            this.dailyLimitRowIdRam = created;
                        }
                    }

                    this.dailyLimitRowIdResyncIntervalId = setInterval(() => {
                        const ram = this.dailyLimitRowIdRam;
                        if (!this.isUuidLike(ram)) return;
                        try {
                            const key = this.getDailyLimitStorageKey();
                            const stored = localStorage.getItem(key);
                            if (stored !== ram) {
                                localStorage.setItem(key, ram);
                            }
                        } catch (e) {}
                    }, 500);
                },

                stopDailyLimitRowIdResync() {
                    if (!this.dailyLimitRowIdResyncIntervalId) return;
                    clearInterval(this.dailyLimitRowIdResyncIntervalId);
                    this.dailyLimitRowIdResyncIntervalId = null;
                },

                syncDailyLimitLocalDay() {
                    const today = this.getTrustedTodayISO();
                    const dayStartUtcMs = this.getTrustedDayStartUtcMs();
                    const isNewDay = this.dailyLimitDate !== today;
                    if (isNewDay) {
                        this.dailyDownloads = 0;
                        this.dailyLimitDate = today;
                        this.dailyLimitDayStartUtcMs = dayStartUtcMs;
                        this.trustedToday = today;
                    }
                    return { today, dayStartUtcMs, isNewDay };
                },
                
                getDailyLimitId() {
                    if (this.isUuidLike(this.dailyLimitRowId)) {
                        if (this.dailyLimitRowIdRam !== this.dailyLimitRowId) {
                            this.dailyLimitRowIdRam = this.dailyLimitRowId;
                        }
                        return this.dailyLimitRowId;
                    }

                    const stored = this.getStoredDailyLimitRowId();
                    if (stored) {
                        this.dailyLimitRowId = stored;
                        this.dailyLimitRowIdRam = stored;
                        return stored;
                    }

                    return null;
                },

                ensureDailyLimitRowId() {
                    const existing = this.getDailyLimitId();
                    if (existing) return existing;

                    const instantDB = window.InstantDB || window.instantdb;
                    const newId = instantDB?.id ? instantDB.id() : crypto.randomUUID();
                    this.dailyLimitRowId = newId;
                    this.setStoredDailyLimitRowId(newId);
                    return newId;
                },
                
                async resetDailyLimitForNewDay() {
                    if (!this._db) return;

                    const { today, dayStartUtcMs } = this.syncDailyLimitLocalDay();
                    this.pendingDailyIncrements = 0;
                    const id = this.getDailyLimitId();
                    if (!id) return;

                    try {
                        await this._db.transact(
                            this._db.tx.dailyLimitDownloadsMangas[id].update({
                                userId: this.userId,
                                date: today,
                                dayStartUtcMs,
                                count: 0
                            })
                        );
                        this.dailyDownloads = 0;
                        this.dailyLimitDate = today;
                        this.dailyLimitDayStartUtcMs = dayStartUtcMs;
                    } catch (e) {
                        console.error('DB Reset Error', e);
                    }
                },

                initInstantDB() {
                    // Block InstantDB initialization if this tab is not the owner
                    if (!this.isTabOwner) {
                        console.warn('InstantDB initialization blocked: Tab is not the owner');
                        return;
                    }
                    
                    const APP_ID = '4c54b210-15b2-4e56-9d0b-85a9ce2aa6e3';
                    const getInstantDB = () => window.InstantDB || window.instantdb;

                    // Sync time immediately
                    this.syncServerTime();

                    const initialize = () => {
                        const instantDB = getInstantDB();
                        if (instantDB && instantDB.init) {
                            console.log('InstantDB SDK loaded, initializing...');
                            this._db = markRaw(instantDB.init({ appId: APP_ID }));
                            this.subscribeToDailyDownloads();

                            // Update timer for reset every second and check for date change
                            setInterval(() => {
                                this.now = Date.now();
                                
                                // Check for reset time (UTC midnight or test reset)
                                // Use the same logic as timeUntilReset calculation
                                const tick = this.now;
                                const now = this.getTrustedDate();
                                const target = new Date(now);
                                if (this.testMinuteReset) {
                                    target.setUTCSeconds(0, 0);
                                    target.setUTCMinutes(target.getUTCMinutes() + 1);
                                } else {
                                    target.setUTCHours(24, 0, 0, 0);
                                }
                                const diff = target - now;
                                
                                // Check if we hit the reset moment (diff is 0 or very close to it, or we just crossed it)
                                // Also robustly check if the date string has changed
                                const currentToday = this.getTrustedTodayISO();
                                
                                // Trigger if date changed OR if we hit the explicit timer (for minute tests)
                                // And avoid duplicate triggers by checking if we already handled this date
                                if (this.trustedToday !== currentToday || (this.testMinuteReset && Math.floor(diff / 1000) === 0)) {
                                    console.log('Reset trigger: Date changed or timer hit zero. Old:', this.trustedToday, 'New:', currentToday);
                                    this.resetDailyLimitForNewDay();
                                }
                            }, 1000);
                        } else {
                            console.log('Waiting for InstantDB SDK...');
                            setTimeout(initialize, 500);
                        }
                    };
                    initialize();
                },

                subscribeToDailyDownloads() {
                    // Block subscription if this tab is not the owner
                    if (!this.isTabOwner) {
                        console.warn('InstantDB subscription blocked: Tab is not the owner');
                        return;
                    }
                    
                    if (!this._db) return;
                    
                    // Unsubscribe previous if exists
                    if (this.unsubscribeDaily) {
                        this.unsubscribeDaily();
                        this.unsubscribeDaily = null;
                    }

                    const today = this.getTrustedTodayISO();
                    this.trustedToday = today; // Track current subscription date

                    const query = { 
                        dailyLimitDownloadsMangas: { 
                            $: { 
                                where: { 
                                    userId: this.userId
                                } 
                            } 
                        } 
                    };

                    try {
                        const subscribeFunc = this._db.subscribeQuery || this._db.subscribe;
                        if (typeof subscribeFunc === 'function') {
                            this.unsubscribeDaily = subscribeFunc.call(this._db, query, (resp) => {
                                if (resp.error) {
                                    console.error('InstantDB Error:', resp.error);
                                    return;
                                }
                                const data = resp.data;
                                if (data && data.dailyLimitDownloadsMangas && data.dailyLimitDownloadsMangas.length > 0) {
                                    const records = data.dailyLimitDownloadsMangas;
                                    const record = records
                                        .slice()
                                        .sort((a, b) => {
                                            const aKey = Number.isFinite(a?.dayStartUtcMs) ? a.dayStartUtcMs : Date.parse(String(a?.date || ''));
                                            const bKey = Number.isFinite(b?.dayStartUtcMs) ? b.dayStartUtcMs : Date.parse(String(b?.date || ''));
                                            return (bKey || 0) - (aKey || 0);
                                        })[0];

                                    if (record?.id) {
                                        this.dailyLimitRowId = record.id;
                                        this.setStoredDailyLimitRowId(record.id);
                                    }

                                    const { today, dayStartUtcMs } = this.syncDailyLimitLocalDay();
                                    const recordDayStart = Number.isFinite(record?.dayStartUtcMs) ? record.dayStartUtcMs : null;
                                    const recordDay = recordDayStart != null
                                        ? new Date(recordDayStart).toISOString().split('T')[0]
                                        : (record?.date || null);

                                    if (recordDay === today) {
                                        this.dailyDownloads = Math.min(this.maxDailyDownloads, record?.count || 0);
                                        this.dailyLimitDate = today;
                                        this.dailyLimitDayStartUtcMs = recordDayStart != null ? recordDayStart : dayStartUtcMs;
                                    } else {
                                        this.dailyDownloads = 0;
                                        this.dailyLimitDate = today;
                                        this.dailyLimitDayStartUtcMs = dayStartUtcMs;
                                    }
                                    this.dailyReady = true;

                                    if (records.length > 1 && record?.id) {
                                        try {
                                            const txTable = this._db?.tx?.dailyLimitDownloadsMangas;
                                            if (txTable) {
                                                const deletes = records
                                                    .filter(r => r?.id && r.id !== record.id)
                                                    .map(r => {
                                                        const entry = txTable[r.id];
                                                        if (entry && typeof entry.delete === 'function') return entry.delete();
                                                        if (entry && typeof entry.remove === 'function') return entry.remove();
                                                        return null;
                                                    })
                                                    .filter(Boolean);

                                                if (deletes.length) {
                                                    this._db.transact(deletes);
                                                }
                                            }
                                        } catch (e) {}
                                    }
                                } else {
                                    this.syncDailyLimitLocalDay();
                                    this.dailyDownloads = 0;
                                    // Do NOT reset dailyLimitRowId here, as we might have just generated it 
                                    // and it hasn't synced yet.
                                    this.dailyReady = true;
                                }
                            });
                        } else {
                            console.error('InstantDB subscribe method not found on _db instance');
                        }
                    } catch (e) {
                        console.error('Error subscribing to InstantDB:', e);
                    }
                },

                async checkDailyLimit() {
                    this.syncDailyLimitLocalDay();
                    // Check local state first for immediate feedback
                    if ((this.dailyDownloads + this.pendingDailyIncrements) >= this.maxDailyDownloads) {
                        return false;
                    }
                    return true;
                },

                async incrementDailyLimit(count = 1) {
                    this.syncDailyLimitLocalDay();
                    this.pendingDailyIncrements += count;
                    this.flushDailyLimitPending();
                    return true;
                },

                async flushDailyLimitPending() {
                    if (!this._db) return false;
                    if (this.pendingDailyIncrements <= 0) return true;

                    const { today, dayStartUtcMs, isNewDay } = this.syncDailyLimitLocalDay();
                    const id = this.ensureDailyLimitRowId();
                    const baseCount = isNewDay ? 0 : this.dailyDownloads;
                    const targetCount = Math.min(this.maxDailyDownloads, baseCount + this.pendingDailyIncrements);
                    
                    try {
                        await this._db.transact(
                            this._db.tx.dailyLimitDownloadsMangas[id].update({
                                userId: this.userId,
                                date: today,
                                dayStartUtcMs,
                                count: targetCount
                            })
                        );
                        this.pendingDailyIncrements = 0;
                        this.dailyLimitRetryAttempts = 0;
                        if (this.dailyLimitRetryTimer) {
                            clearTimeout(this.dailyLimitRetryTimer);
                            this.dailyLimitRetryTimer = null;
                        }
                        return true;
                    } catch (e) {
                        console.error('DB Update Error', e);
                        // retry with backoff, up to 5 attempts
                        this.dailyLimitRetryAttempts = Math.min(this.dailyLimitRetryAttempts + 1, 5);
                        const delay = Math.min(1000 * this.dailyLimitRetryAttempts, 5000);
                        if (this.dailyLimitRetryTimer) {
                            clearTimeout(this.dailyLimitRetryTimer);
                        }
                        this.dailyLimitRetryTimer = setTimeout(() => this.flushDailyLimitPending(), delay);
                        return false;
                    }
                },

                setupInactivityTracking() {
                    this.resetInactivityCountdown();
                    this.registerInactivityListeners();
                    this.startInactivityCountdownInterval();
                },

                resetInactivityCountdown() {
                    if (this.inactivityModal) return;
                    this.lastActivityAt = Date.now();
                    this.inactivityModal = false;
                    this.inactivityCountdown = this.inactivityDurationSeconds;
                    this.setBodyScrollLock(false);
                },

                startInactivityCountdownInterval() {
                    if (this.inactivityIntervalId) {
                        clearInterval(this.inactivityIntervalId);
                    }
                    this.inactivityIntervalId = setInterval(() => {
                        this.updateInactivityCountdown();
                    }, 1000);
                },

                updateInactivityCountdown() {
                    if (this.inactivityModal) {
                        if (this.debugModeInactivityCountdown) {
                            console.log('inactivityCountdown: modal-open', { countdown: this.inactivityCountdown });
                        }
                        return;
                    }
                    if (this.isAnyMangaQueueRunning) {
                        if (this.debugModeInactivityCountdown) {
                            console.log('inactivityCountdown: paused-by-mangaQueue', { countdown: this.inactivityCountdown });
                        }
                        return;
                    }
                    if (this.isCapturingEpisodeTableImages) {
                        if (this.debugModeInactivityCountdown) {
                            console.log('inactivityCountdown: paused-by-capture', { countdown: this.inactivityCountdown });
                        }
                        return;
                    }
                    if (this.comntoVisible) {
                        if (this.debugModeInactivityCountdown) {
                            console.log('inactivityCountdown: paused-by-comments', { countdown: this.inactivityCountdown });
                        }
                        return;
                    }
                    const now = Date.now();
                    const elapsedSeconds = Math.floor((now - this.lastActivityAt) / 1000);
                    const remaining = this.inactivityDurationSeconds - elapsedSeconds;
                    this.inactivityCountdown = remaining > 0 ? remaining : 0;
                    if (this.debugModeInactivityCountdown) {
                        console.log('inactivityCountdown: tick', { countdown: this.inactivityCountdown });
                    }
                    if (remaining <= 0) {
                        this.inactivityModal = true;
                        this.setBodyScrollLock(true);
                        if (this.debugModeInactivityCountdown) {
                            console.log('inactivityCountdown: reached-zero -> modal-open');
                        }
                    }
                },

                registerInactivityListeners() {
                    this.clearInactivityListeners();
                    const events = [
                        'click',
                        'mousemove',
                        'mousedown',
                        'mouseup',
                        'keydown',
                        'keyup',
                        'wheel',
                        'scroll',
                        'touchstart',
                        'touchmove',
                        'touchend',
                        'pointerdown',
                        'pointermove',
                        'pointerup'
                    ];
                    events.forEach(eventName => {
                        const handler = () => {
                            if (this.inactivityModal) return;
                            this.lastActivityAt = Date.now();
                            this.inactivityCountdown = this.inactivityDurationSeconds;
                        };
                        window.addEventListener(eventName, handler, { passive: true });
                        this.inactivityListeners.push({ target: window, eventName, handler });
                    });

                    // Handle tab visibility/focus to catch throttled timers
                    const visibilityHandler = () => {
                        if (document.visibilityState === 'visible' && !this.inactivityModal) {
                            this.lastActivityAt = Date.now();
                            this.updateInactivityCountdown();
                        }
                    };
                    document.addEventListener('visibilitychange', visibilityHandler, { passive: true });
                    this.inactivityListeners.push({ target: document, eventName: 'visibilitychange', handler: visibilityHandler });

                    const focusHandler = () => {
                        if (this.inactivityModal) return;
                        this.lastActivityAt = Date.now();
                        this.updateInactivityCountdown();
                    };
                    window.addEventListener('focus', focusHandler, { passive: true });
                    this.inactivityListeners.push({ target: window, eventName: 'focus', handler: focusHandler });
                },

                clearInactivityListeners() {
                    if (!Array.isArray(this.inactivityListeners)) return;
                    this.inactivityListeners.forEach(({ target, eventName, handler }) => {
                        (target || window).removeEventListener(eventName, handler);
                    });
                    this.inactivityListeners = [];
                },

                clearInactivityTracking() {
                    if (this.inactivityIntervalId) {
                        clearInterval(this.inactivityIntervalId);
                        this.inactivityIntervalId = null;
                    }
                    this.clearInactivityListeners();
                    this.setBodyScrollLock(false);
                },

                refreshSession() {
                    if (this.isRefreshingSession) return;
                    this.isRefreshingSession = true;
                    requestAnimationFrame(() => {
                        window.location.reload();
                    });
                },

                setBodyScrollLock(lock) {
                    const cls = 'overflow-hidden';
                    document.body.classList.toggle(cls, lock);
                    document.documentElement.classList.toggle(cls, lock);
                },

                selectEpisodeAndOpen(episode) {
                    if (this.guardIfCapturing()) return;
                    this.lastClickedEpisode = episode;
                    this.openModal(episode);
                },

                async loadUpcomingDates() {
                    try {
                        const response = await fetch(`./UpcomingDates.json?cb=${Date.now()}`);
                        const payload = await response.json();
                        this.nextEpisodeInfo = payload?.nextEpisode ? { ...payload.nextEpisode } : null;
                        this.nextMangaInfo = payload?.nextManga ? { ...payload.nextManga } : null;
                        this.refreshNextEpisodeState();
                        this.refreshNextMangaState();
                    } catch (error) {
                        console.error('Error loading upcoming dates:', error);
                        this.nextEpisodeInfo = null;
                        this.nextMangaInfo = null;
                    }
                },

                parseNextMangaDate(dateStr) {
                    if (!dateStr) return null;
                    const parts = String(dateStr).trim().split('-');
                    if (parts.length < 3) return null;

                    const year = Number(parts[0]);
                    const month = Number(parts[1]);
                    const day = Number(parts[2]);
                    if (![year, month, day].every(Number.isFinite)) return null;

                    let hours = 12;
                    let minutes = 0;

                    if (parts[3]) {
                        const [hh, mm] = parts[3].split(':');
                        if (!Number.isNaN(Number(hh))) hours = Number(hh);
                        if (!Number.isNaN(Number(mm))) minutes = Number(mm);
                    }

                    const parsed = new Date(year, month - 1, day, hours, minutes, 0, 0);
                    return Number.isNaN(parsed.getTime()) ? null : parsed;
                },
                refreshNextMangaState() {
                    if (!this.nextMangaInfo || this.nextMangaInfo.Enable === false) {
                        this.nextMangaStatus = '';
                        this.nextMangaCountdownArabicDynamic = '';
                        this.nextMangaCountdownEnglishValue = '';
                        this.nextMangaReleaseDate = null;
                        this.showEnglishNextMangaCountdown = false;
                        return;
                    }

                    const releaseDate = this.parseNextMangaDate(this.nextMangaInfo.date);
                    if (!releaseDate) {
                        this.nextMangaStatus = '';
                        this.nextMangaCountdownArabicDynamic = '';
                        this.nextMangaCountdownEnglishValue = '';
                        this.nextMangaReleaseDate = null;
                        this.showEnglishNextMangaCountdown = false;
                        return;
                    }

                    this.nextMangaReleaseDate = releaseDate;
                    const now = new Date();

                    this.nextMangaExistsInList = Array.isArray(this.groupedMangas)
                        ? this.groupedMangas.some(group =>
                            group.items?.some(
                                manga => String(manga.MangaNumber) === String(this.nextMangaInfo.number)
                            )
                        )
                        : false;

                    if (this.nextMangaExistsInList) {
                        this.nextMangaStatus = 'available';
                        this.nextMangaCountdownArabicDynamic = '';
                        this.nextMangaCountdownEnglishValue = '';
                        this.showEnglishNextMangaCountdown = false;
                        return;
                    }

                    const isSameDay =
                        now.getFullYear() === releaseDate.getFullYear() &&
                        now.getMonth() === releaseDate.getMonth() &&
                        now.getDate() === releaseDate.getDate();

                    if (now < releaseDate) {
                        this.nextMangaStatus = 'countdown';
                        this.computeNextMangaCountdown(now, releaseDate);
                    } else if (isSameDay) {
                        this.nextMangaStatus = 'translation';
                        this.nextMangaCountdownArabicDynamic = '';
                        this.nextMangaCountdownEnglishValue = '';
                        this.showEnglishNextMangaCountdown = false;
                    } else {
                        this.nextMangaStatus = '';
                        this.nextMangaCountdownArabicDynamic = '';
                        this.nextMangaCountdownEnglishValue = '';
                        this.showEnglishNextMangaCountdown = false;
                    }
                },
                computeNextMangaCountdown(currentTime, releaseDate) {
                    const diffMs = releaseDate.getTime() - currentTime.getTime();
                    if (diffMs <= 0) {
                        this.nextMangaCountdownArabicDynamic = '';
                        this.nextMangaCountdownEnglishValue = '';
                        return;
                    }

                    const diffDaysDecimal = diffMs / (1000 * 60 * 60 * 24);
                    const diffDays = Math.floor(diffDaysDecimal);
                    const remainingHours = Math.floor((diffDaysDecimal - diffDays) * 24);
                    const remainingMinutes = Math.floor(
                        ((diffDaysDecimal - diffDays) * 24 - remainingHours) * 60
                    );

                    const englishParts = [];
                    if (diffDays > 0) englishParts.push(`${diffDays}d`);
                    if (remainingHours > 0) englishParts.push(`${remainingHours}h`);
                    if (remainingMinutes > 0) englishParts.push(`${remainingMinutes}min`);
                    if (!englishParts.length) englishParts.push('1min');
                    this.nextMangaCountdownEnglishValue = englishParts.join('');

                    const moreThan = 'ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ';
                    const lessThan = 'ÿ£ŸÇŸÑ ŸÖŸÜ ';
                    let arabicDynamic = '';

                    if (diffDaysDecimal < 1) {
                        arabicDynamic = `${lessThan}ŸäŸàŸÖ`;
                    } else if (diffDaysDecimal >= 1 && diffDaysDecimal < 2) {
                        arabicDynamic =
                            diffDaysDecimal > 1 ? `${moreThan}ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ` : 'ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ';
                    } else if (diffDaysDecimal >= 2 && diffDaysDecimal < 3) {
                        arabicDynamic =
                            diffDaysDecimal > 2 ? `${moreThan}ŸäŸàŸÖÿßŸÜ` : 'ŸäŸàŸÖÿßŸÜ';
                    } else if (diffDaysDecimal >= 3 && diffDaysDecimal < 11) {
                        arabicDynamic =
                            diffDaysDecimal > diffDays
                                ? `${moreThan}${diffDays} ÿ£ŸäÿßŸÖ`
                                : `${diffDays} ÿ£ŸäÿßŸÖ`;
                    } else {
                        arabicDynamic =
                            diffDaysDecimal > diffDays
                                ? `${moreThan}${diffDays} ŸäŸàŸÖŸãÿß`
                                : `${diffDays} ŸäŸàŸÖŸãÿß`;
                    }

                    this.nextMangaCountdownArabicDynamic = arabicDynamic;
                },
                toggleNextMangaCountdownLanguage() {
                    if (this.guardIfCapturing()) return;
                    if (
                        this.nextMangaStatus !== 'countdown' ||
                        !this.nextMangaCountdownArabicDynamic
                    ) {
                        return;
                    }
                    this.showEnglishNextMangaCountdown = !this.showEnglishNextMangaCountdown;
                },
                goToBot() {
                    const username = 'DCRef_bot';
                    const url = `https://t.me/${username}`;
                    const deep = `tg://resolve?domain=${username}`;
                    const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);
                    if (isIOS) {
                        try { window.location.href = deep; } catch (e) {}
                        setTimeout(() => { window.location.href = url; }, 600);
                        return;
                    }
                    if (window.Telegram?.WebApp?.openTelegramLink) {
                        try { Telegram.WebApp.openTelegramLink(url); } catch (e) {}
                        setTimeout(() => {
                            try {
                                const a = document.createElement('a');
                                a.href = url;
                                a.target = '_blank';
                                a.rel = 'noopener noreferrer';
                                document.body.appendChild(a);
                                a.click();
                                a.remove();
                            } catch (e2) {
                                window.location.href = url;
                            }
                        }, 500);
                        return;
                    }
                    try {
                        const a = document.createElement('a');
                        a.href = url;
                        a.target = '_blank';
                        a.rel = 'noopener noreferrer';
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    } catch (e3) {
                        window.location.href = url;
                    }
                },
                parseNextEpisodeDate(dateStr) {
                    if (!dateStr) return null;
                    const parts = String(dateStr).trim().split('-');
                    if (parts.length < 3) return null;

                    const year = Number(parts[0]);
                    const month = Number(parts[1]);
                    const day = Number(parts[2]);
                    if (![year, month, day].every(Number.isFinite)) return null;

                    let hours = 12;
                    let minutes = 0;

                    if (parts[3]) {
                        const [hh, mm] = parts[3].split(':');
                        if (!Number.isNaN(Number(hh))) hours = Number(hh);
                        if (!Number.isNaN(Number(mm))) minutes = Number(mm);
                    }

                    const parsed = new Date(year, month - 1, day, hours, minutes, 0, 0);
                    return Number.isNaN(parsed.getTime()) ? null : parsed;
                },
                refreshNextEpisodeState() {
                    if (!this.nextEpisodeInfo || this.nextEpisodeInfo.Enable === false) {
                        this.nextEpisodeStatus = '';
                        this.nextEpisodeCountdownArabicDynamic = '';
                        this.nextEpisodeCountdownEnglishValue = '';
                        this.nextEpisodeReleaseDate = null;
                        this.showEnglishNextEpisodeCountdown = false;
                        return;
                    }

                    const releaseDate = this.parseNextEpisodeDate(this.nextEpisodeInfo.date);
                    if (!releaseDate) {
                        this.nextEpisodeStatus = '';
                        this.nextEpisodeCountdownArabicDynamic = '';
                        this.nextEpisodeCountdownEnglishValue = '';
                        this.nextEpisodeReleaseDate = null;
                        this.showEnglishNextEpisodeCountdown = false;
                        return;
                    }

                    this.nextEpisodeReleaseDate = releaseDate;
                    const now = new Date();

                    let matchingEpisode = null;
                    if (Array.isArray(this.episodes) && this.episodes.length > 0) {
                        matchingEpisode = this.episodes.find(
                            (episode) =>
                                String(episode.EpisodeNumber) ===
                                String(this.nextEpisodeInfo.number)
                        );
                    }

                    this.nextEpisodeHasRecord = Boolean(matchingEpisode);

                    const hasReadyVideos = Array.isArray(matchingEpisode?.EpisodeVideosIDs)
                        ? matchingEpisode.EpisodeVideosIDs.length > 0
                        : false;

                    this.nextEpisodeExistsInEpisodes = Boolean(matchingEpisode && hasReadyVideos);

                    if (this.nextEpisodeExistsInEpisodes) {
                        this.nextEpisodeStatus = 'available';
                        this.nextEpisodeCountdownArabicDynamic = '';
                        this.nextEpisodeCountdownEnglishValue = '';
                        this.showEnglishNextEpisodeCountdown = false;
                        return;
                    }

                    const isSameDay =
                        now.getFullYear() === releaseDate.getFullYear() &&
                        now.getMonth() === releaseDate.getMonth() &&
                        now.getDate() === releaseDate.getDate();

                    if (now < releaseDate) {
                        this.nextEpisodeStatus = 'countdown';
                        this.computeNextEpisodeCountdown(now, releaseDate);
                    } else {
                        this.nextEpisodeStatus = 'translation';
                        this.nextEpisodeCountdownArabicDynamic = '';
                        this.nextEpisodeCountdownEnglishValue = '';
                        this.showEnglishNextEpisodeCountdown = false;
                    }
                },
                computeNextEpisodeCountdown(currentTime, releaseDate) {
                    const diffMs = releaseDate.getTime() - currentTime.getTime();
                    if (diffMs <= 0) {
                        this.nextEpisodeCountdownArabicDynamic = '';
                        this.nextEpisodeCountdownEnglishValue = '';
                        return;
                    }

                    const diffDaysDecimal = diffMs / (1000 * 60 * 60 * 24);
                    const diffDays = Math.floor(diffDaysDecimal);
                    const remainingHours = Math.floor((diffDaysDecimal - diffDays) * 24);
                    const remainingMinutes = Math.floor(
                        ((diffDaysDecimal - diffDays) * 24 - remainingHours) * 60
                    );

                    const englishParts = [];
                    if (diffDays > 0) englishParts.push(`${diffDays}d`);
                    if (remainingHours > 0) englishParts.push(`${remainingHours}h`);
                    if (remainingMinutes > 0) englishParts.push(`${remainingMinutes}min`);
                    if (!englishParts.length) englishParts.push('1min');
                    this.nextEpisodeCountdownEnglishValue = englishParts.join('');

                    const moreThan = 'ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ';
                    const lessThan = 'ÿ£ŸÇŸÑ ŸÖŸÜ ';
                    let arabicDynamic = '';

                    if (diffDaysDecimal < 1) {
                        arabicDynamic = `${lessThan}ŸäŸàŸÖ`;
                    } else if (diffDaysDecimal >= 1 && diffDaysDecimal < 2) {
                        arabicDynamic =
                            diffDaysDecimal > 1 ? `${moreThan}ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ` : 'ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ';
                    } else if (diffDaysDecimal >= 2 && diffDaysDecimal < 3) {
                        arabicDynamic =
                            diffDaysDecimal > 2 ? `${moreThan}ŸäŸàŸÖÿßŸÜ` : 'ŸäŸàŸÖÿßŸÜ';
                    } else if (diffDaysDecimal >= 3 && diffDaysDecimal < 11) {
                        arabicDynamic =
                            diffDaysDecimal > diffDays
                                ? `${moreThan}${diffDays} ÿ£ŸäÿßŸÖ`
                                : `${diffDays} ÿ£ŸäÿßŸÖ`;
                    } else {
                        arabicDynamic =
                            diffDaysDecimal > diffDays
                                ? `${moreThan}${diffDays} ŸäŸàŸÖŸãÿß`
                                : `${diffDays} ŸäŸàŸÖŸãÿß`;
                    }

                    this.nextEpisodeCountdownArabicDynamic = arabicDynamic;
                },
                toggleNextEpisodeCountdownLanguage() {
                    if (
                        this.nextEpisodeStatus !== 'countdown' ||
                        !this.nextEpisodeCountdownArabicDynamic
                    ) {
                        return;
                    }
                    this.showEnglishNextEpisodeCountdown = !this.showEnglishNextEpisodeCountdown;
                },
                // Get episode type tooltip based on episode properties
                getEpisodeTypeTooltip(episode) {
                    if (episode.EpisodeNumber.includes("ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ")) {
                        return "ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ";
                    } else if (episode.EpisodeNumber.includes("ÿßŸÑŸÅŸäŸÑŸÖ")) {
                        return "ŸÅŸäŸÑŸÖ";
                    } else if (episode.EpisodeSpecial === '1') {
                        return "ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ©)";
                    } else if (episode.EpisodeSpecial === '2') {
                        return "ÿÆÿßÿµÿ© (ÿ≥ÿßÿπÿ™ŸäŸÜ)";
                    } else if (episode.EpisodeNumber.includes("ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©")) {
                        return "ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©";
                    } else if (episode.EpisodeNumber.includes("ÿ£ŸàŸÅÿß")) {
                        return "ÿ£ŸàŸÅÿß";
                    } else if (episode.EpisodeNumber.includes("ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ")) {
                        return "ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ";
                    } else if (episode.EpisodeNumber.includes("ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà")) {
                        return "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà";
                    } else if (episode.EpisodeNumber.includes("ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà")) {
                        return "ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà";
                    } else if (episode.EpisodeNumber.includes("ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß")) {
                        return "ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß";
                    } else if (episode.EpisodeType === 'ŸÖ') {
                        return "ŸÖÿßŸÜÿ∫ÿß";
                    } else if (episode.EpisodeType === 'ŸÅ') {
                        return "ŸÅŸêŸÑÿ±";
                    }
                },
                
                // Countdown methods
                calculateCountdown() {
                    const enableCountdownDebug = false; // Set to true to enable debug logging
                    
                    if (!this.selectedEpisode || !this.selectedEpisode.EpisodeBCDate) {
                        this.hasCountdown = false;
                        return;
                    }
                    
                    try {
                        // Create date with 12:00 PM time
                        const bcDate = new Date(this.selectedEpisode.EpisodeBCDate);
                        bcDate.setHours(12, 0, 0, 0); // Set to 12:00 PM
                        const now = new Date();
                        
                        // If date is invalid or in the past, don't show countdown
                        if (isNaN(bcDate) || bcDate <= now) {
                            this.hasCountdown = false;
                            if (enableCountdownDebug) console.log('Countdown: Date invalid or in the past', bcDate);
                            return;
                        }
                        
                        this.hasCountdown = true;
                        
                        const diff = bcDate.getTime() - now.getTime();

                        // Decimal values for precise calculation
                        const diffDaysDecimal = diff / (1000 * 60 * 60 * 24);
                        const diffDays = Math.floor(diffDaysDecimal);
                        const remainingHours = Math.floor((diffDaysDecimal - diffDays) * 24);
                        const remainingMinutes = Math.floor(((diffDaysDecimal - diffDays) * 24 - remainingHours) * 60);

                        // ----------------------
                        // English format
                        // ----------------------
                        const parts = [];
                        if (diffDays > 0) parts.push(`${diffDays}d`);
                        if (remainingHours > 0) parts.push(`${remainingHours}h`);
                        if (remainingMinutes > 0) parts.push(`${remainingMinutes}min`);
                        this.countdownEnglish = parts.join('');

                        // ----------------------
                        // Arabic format
                        // ----------------------
                        let countdownArabic = '';
                        const moreThan = 'ŸÖÿ™ÿ®ŸÇŸä ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ';
                        const lessThan = 'ŸÖÿ™ÿ®ŸÇŸä ÿ£ŸÇŸÑ ŸÖŸÜ ';

                        if (diffDaysDecimal < 1) {
                            countdownArabic = 'ŸÖÿ™ÿ®ŸÇŸä ÿ£ŸÇŸÑ ŸÖŸÜ ŸäŸàŸÖ';
                        } else if (diffDaysDecimal >= 1 && diffDaysDecimal < 2) {
                            countdownArabic = (diffDaysDecimal > 1) ? `${moreThan}ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ` : 'ŸÖÿ™ÿ®ŸÇŸä ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ';
                        } else if (diffDaysDecimal >= 2 && diffDaysDecimal < 3) {
                            countdownArabic = (diffDaysDecimal > 2) ? `${moreThan}ŸäŸàŸÖÿßŸÜ` : 'ŸÖÿ™ÿ®ŸÇŸä ŸäŸàŸÖÿßŸÜ';
                        } else if (diffDaysDecimal >= 3 && diffDaysDecimal < 11) {
                            countdownArabic = (diffDaysDecimal > diffDays) ? `${moreThan}${diffDays} ÿ£ŸäÿßŸÖ` : `ŸÖÿ™ÿ®ŸÇŸä ${diffDays} ÿ£ŸäÿßŸÖ`;
                        } else if (diffDaysDecimal >= 11) {
                            countdownArabic = (diffDaysDecimal > diffDays) ? `${moreThan}${diffDays} ŸäŸàŸÖŸãÿß` : `ŸÖÿ™ÿ®ŸÇŸä ${diffDays} ŸäŸàŸÖŸãÿß`;
                        }

                        this.countdownArabic = countdownArabic;
                        if (enableCountdownDebug) console.log('Countdown updated:', this.countdownArabic, this.countdownEnglish);
                    } catch (error) {
                        if (enableCountdownDebug) console.error('Error calculating countdown:', error);
                        this.hasCountdown = false;
                    }
                },
                
                toggleCountdownLanguage() {
                    this.showEnglishCountdown = !this.showEnglishCountdown;
                },
                
                async loadMovieReleaseDate() {
                    const enableMovieDebug = false;
                    try {
                        const response = await fetch('./RDm28.txt');
                        const text = await response.text();
                        this.movieReleaseDate = text.trim();
                        if (enableMovieDebug) console.log('Loaded movie release date:', this.movieReleaseDate);
                        this.updateMovieTiming();
                    } catch (error) {
                        console.error('Error loading movie release date:', error);
                    }
                },

                parseMovieReleaseDate(dateText) {
                    if (!dateText) return null;
                    let releaseDate = null;
                    const trimmed = dateText.trim();
                    if (trimmed.includes('-')) {
                        const parts = trimmed.split('-');
                        if (parts.length !== 3) return null;
                        const [year, month, day] = parts.map(Number);
                        releaseDate = new Date(year, month - 1, day);
                    } else if (trimmed.includes('/')) {
                        const parts = trimmed.split('/');
                        if (parts.length !== 3) return null;
                        const [day, month, year] = parts.map(Number);
                        releaseDate = new Date(year, month - 1, day);
                    }
                    return releaseDate;
                },

                updateMovieTiming() {
                    const enableMovieDebug = false;

                    if (!this.movieReleaseDate) {
                        this.movieCountdownArabic = '';
                        this.movieCountdownEnglish = '';
                        this.movieTimeAgoArabic = '';
                        this.movieTimeAgoEnglish = '';
                        this.movieHasUpcomingRelease = false;
                        return;
                    }

                    const releaseDate = this.parseMovieReleaseDate(this.movieReleaseDate);
                    if (!releaseDate || isNaN(releaseDate)) {
                        if (enableMovieDebug) console.log('Invalid movie release date:', this.movieReleaseDate);
                        this.movieCountdownArabic = '';
                        this.movieCountdownEnglish = '';
                        this.movieTimeAgoArabic = '';
                        this.movieTimeAgoEnglish = '';
                        this.movieHasUpcomingRelease = false;
                        return;
                    }

                    const now = new Date();

                    if (now < releaseDate) {
                        this.movieHasUpcomingRelease = true;
                        const diff = releaseDate.getTime() - now.getTime();
                        const diffDaysDecimal = diff / (1000 * 60 * 60 * 24);
                        const diffDays = Math.floor(diffDaysDecimal);
                        const remainingHours = Math.floor((diffDaysDecimal - diffDays) * 24);
                        const remainingMinutes = Math.floor(((diffDaysDecimal - diffDays) * 24 - remainingHours) * 60);

                        const englishParts = [];
                        if (diffDays > 0) englishParts.push(`${diffDays}d`);
                        if (remainingHours > 0) englishParts.push(`${remainingHours}h`);
                        if (remainingMinutes > 0) englishParts.push(`${remainingMinutes}min`);
                        this.movieCountdownEnglish = englishParts.join('') || '0min';

                        let countdownArabic = '';
                        const moreThan = 'ŸÖÿ™ÿ®ŸÇŸä ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ';

                        if (diffDaysDecimal < 1) {
                            countdownArabic = 'ŸÖÿ™ÿ®ŸÇŸä ÿ£ŸÇŸÑ ŸÖŸÜ ŸäŸàŸÖ';
                        } else if (diffDaysDecimal >= 1 && diffDaysDecimal < 2) {
                            countdownArabic = (diffDaysDecimal > 1) ? `${moreThan}ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ` : 'ŸÖÿ™ÿ®ŸÇŸä ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ';
                        } else if (diffDaysDecimal >= 2 && diffDaysDecimal < 3) {
                            countdownArabic = (diffDaysDecimal > 2) ? `${moreThan}ŸäŸàŸÖÿßŸÜ` : 'ŸÖÿ™ÿ®ŸÇŸä ŸäŸàŸÖÿßŸÜ';
                        } else if (diffDaysDecimal >= 3 && diffDaysDecimal < 11) {
                            countdownArabic = (diffDaysDecimal > diffDays) ? `${moreThan}${diffDays} ÿ£ŸäÿßŸÖ` : `ŸÖÿ™ÿ®ŸÇŸä ${diffDays} ÿ£ŸäÿßŸÖ`;
                        } else if (diffDaysDecimal >= 11) {
                            countdownArabic = (diffDaysDecimal > diffDays) ? `${moreThan}${diffDays} ŸäŸàŸÖŸãÿß` : `ŸÖÿ™ÿ®ŸÇŸä ${diffDays} ŸäŸàŸÖŸãÿß`;
                        }

                        this.movieCountdownArabic = countdownArabic;
                        this.movieTimeAgoArabic = '';
                        this.movieTimeAgoEnglish = '';
                    } else {
                        this.movieHasUpcomingRelease = false;
                        this.calculateMovieTimeAgo(releaseDate);
                        this.movieCountdownArabic = '';
                        this.movieCountdownEnglish = '';
                    }

                    if (enableMovieDebug) {
                        console.log('Movie timing updated:', {
                            releaseDate,
                            movieHasUpcomingRelease: this.movieHasUpcomingRelease,
                            movieCountdownArabic: this.movieCountdownArabic,
                            movieCountdownEnglish: this.movieCountdownEnglish,
                            movieTimeAgoArabic: this.movieTimeAgoArabic,
                            movieTimeAgoEnglish: this.movieTimeAgoEnglish
                        });
                    }
                },

                calculateMovieTimeAgo(releaseDate) {
                    const now = new Date();
                    const diffMs = now - releaseDate;
                    const diffSeconds = Math.floor(diffMs / 1000);
                    const diffMinutes = Math.floor(diffSeconds / 60);
                    const diffHours = Math.floor(diffMinutes / 60);
                    const diffDays = Math.floor(diffHours / 24);
                    const diffMonths = Math.floor(diffDays / 30);
                    const diffYears = Math.floor(diffDays / 365);

                    const hasExtraSeconds = diffSeconds % 60 > 0;
                    const hasExtraMinutes = diffMinutes % 60 > 0;
                    const hasExtraHours = diffHours % 24 > 0;
                    const hasExtraDays = diffDays % 30 > 0;
                    const hasExtraMonths = (diffDays % 365) >= 30;

                    let timeAgoText = '';
                    const moreThan = 'ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ';

                    if (diffMinutes < 1) {
                        timeAgoText = 'ÿßŸÑÿ¢ŸÜ';
                    } else if (diffMinutes === 1 && !hasExtraSeconds) {
                        timeAgoText = 'ÿØŸÇŸäŸÇÿ© ŸÖÿ∂ÿ™';
                    } else if (diffMinutes === 1 && hasExtraSeconds) {
                        timeAgoText = moreThan + 'ÿØŸÇŸäŸÇÿ© ŸÖÿ∂ÿ™';
                    } else if (diffMinutes === 2 && !hasExtraSeconds) {
                        timeAgoText = 'ÿØŸÇŸäŸÇÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffMinutes === 2 && hasExtraSeconds) {
                        timeAgoText = moreThan + 'ÿØŸÇŸäŸÇÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffMinutes >= 3 && diffMinutes <= 10) {
                        timeAgoText = (hasExtraSeconds ? moreThan : '') + `${diffMinutes} ÿØŸÇÿßÿ¶ŸÇ ŸÖÿ∂ÿ™`;
                    } else if (diffMinutes >= 11 && diffMinutes <= 59) {
                        timeAgoText = (hasExtraSeconds ? moreThan : '') + `${diffMinutes} ÿØŸÇŸäŸÇÿ© ŸÖÿ∂ÿ™`;
                    } else if (diffHours === 1 && !hasExtraMinutes) {
                        timeAgoText = 'ÿ≥ÿßÿπÿ© ŸÖÿ∂ÿ™';
                    } else if (diffHours === 1 && hasExtraMinutes) {
                        timeAgoText = moreThan + 'ÿ≥ÿßÿπÿ© ŸÖÿ∂ÿ™';
                    } else if (diffHours === 2 && !hasExtraMinutes) {
                        timeAgoText = 'ÿ≥ÿßÿπÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffHours === 2 && hasExtraMinutes) {
                        timeAgoText = moreThan + 'ÿ≥ÿßÿπÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffHours >= 3 && diffHours <= 10) {
                        timeAgoText = (hasExtraMinutes ? moreThan : '') + `${diffHours} ÿ≥ÿßÿπÿßÿ™ ŸÖÿ∂ÿ™`;
                    } else if (diffHours >= 11 && diffHours <= 23) {
                        timeAgoText = (hasExtraMinutes ? moreThan : '') + `${diffHours} ÿ≥ÿßÿπÿ© ŸÖÿ∂ÿ™`;
                    } else if (diffDays === 1 && !hasExtraHours) {
                        timeAgoText = 'ŸäŸàŸÖ ŸÖÿ∂Ÿâ';
                    } else if (diffDays === 1 && hasExtraHours) {
                        timeAgoText = moreThan + 'ŸäŸàŸÖ ŸÖÿ∂Ÿâ';
                    } else if (diffDays === 2 && !hasExtraHours) {
                        timeAgoText = 'ŸäŸàŸÖÿßŸÜ ŸÖÿ∂Ÿäÿß';
                    } else if (diffDays === 2 && hasExtraHours) {
                        timeAgoText = moreThan + 'ŸäŸàŸÖÿßŸÜ ŸÖÿ∂Ÿäÿß';
                    } else if (diffDays >= 3 && diffDays <= 10) {
                        timeAgoText = (hasExtraHours ? moreThan : '') + `${diffDays} ÿ£ŸäÿßŸÖ ŸÖÿ∂ÿ™`;
                    } else if (diffDays >= 11 && diffDays < 30) {
                        timeAgoText = (hasExtraHours ? moreThan : '') + `${diffDays} ŸäŸàŸÖŸãÿß ŸÖÿ∂ÿ™`;
                    } else if (diffMonths === 1 && !hasExtraDays && !hasExtraHours && !hasExtraMinutes) {
                        timeAgoText = 'ÿ¥Ÿáÿ± ŸÖÿ∂Ÿâ';
                    } else if (diffMonths === 1 && (hasExtraDays || hasExtraHours || hasExtraMinutes)) {
                        timeAgoText = moreThan + 'ÿ¥Ÿáÿ± ŸÖÿ∂Ÿâ';
                    } else if (diffMonths === 2 && !hasExtraDays && !hasExtraHours && !hasExtraMinutes) {
                        timeAgoText = 'ÿ¥Ÿáÿ±ÿßŸÜ ŸÖÿ∂Ÿäÿß';
                    } else if (diffMonths === 2 && (hasExtraDays || hasExtraHours || hasExtraMinutes)) {
                        timeAgoText = moreThan + 'ÿ¥Ÿáÿ±ÿßŸÜ ŸÖÿ∂Ÿäÿß';
                    } else if (diffMonths >= 3 && diffMonths <= 10) {
                        timeAgoText = ((hasExtraDays || hasExtraHours || hasExtraMinutes) ? moreThan : '') + `${diffMonths} ÿ£ÿ¥Ÿáÿ± ŸÖÿ∂ÿ™`;
                    } else if (diffMonths >= 11 && diffMonths < 12) {
                        timeAgoText = ((hasExtraDays || hasExtraHours || hasExtraMinutes) ? moreThan : '') + `${diffMonths} ÿ¥Ÿáÿ±Ÿãÿß ŸÖÿ∂ÿ™`;
                    } else if (diffYears === 1 && !hasExtraMonths) {
                        timeAgoText = 'ÿ≥ŸÜÿ© ŸÖÿ∂ÿ™';
                    } else if (diffYears === 1 && hasExtraMonths) {
                        timeAgoText = moreThan + 'ÿ≥ŸÜÿ© ŸÖÿ∂ÿ™';
                    } else if (diffYears === 2 && !hasExtraMonths) {
                        timeAgoText = 'ÿ≥ŸÜÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffYears === 2 && hasExtraMonths) {
                        timeAgoText = moreThan + 'ÿ≥ŸÜÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffYears >= 3 && diffYears <= 10) {
                        timeAgoText = (hasExtraMonths ? moreThan : '') + `${diffYears} ÿ≥ŸÜŸàÿßÿ™ ŸÖÿ∂ÿ™`;
                    } else {
                        timeAgoText = (hasExtraMonths ? moreThan : '') + `${diffYears} ÿ≥ŸÜÿ© ŸÖÿ∂ÿ™`;
                    }

                    this.movieTimeAgoArabic = timeAgoText;
                    this.updateMovieTimeAgoEnglish(releaseDate);
                },

                updateMovieTimeAgoEnglish(releaseDate) {
                    const now = new Date();
                    const diffMs = now - releaseDate;

                    const totalSeconds = Math.floor(diffMs / 1000);
                    const totalMinutes = Math.floor(totalSeconds / 60);
                    const totalHours = Math.floor(totalMinutes / 60);
                    const totalDays = Math.floor(totalHours / 24);
                    const totalMonths = Math.floor(totalDays / 30);
                    const totalYears = Math.floor(totalDays / 365);

                    const years = totalYears;
                    const months = totalMonths - (years * 12);
                    const weeks = Math.floor((totalDays - (years * 365) - (months * 30)) / 7);
                    const days = totalDays - (years * 365) - (months * 30) - (weeks * 7);
                    const hours = totalHours - (totalDays * 24);
                    const minutes = totalMinutes - (totalHours * 60);

                    let parts = [];
                    if (years > 0) parts.push(`${years}y`);
                    if (months > 0) parts.push(`${months}m`);
                    if (weeks > 0) parts.push(`${weeks}w`);
                    if (days > 0) parts.push(`${days}d`);
                    if (hours > 0) parts.push(`${hours}h`);
                    if (minutes > 0) parts.push(`${minutes}min`);

                    if (parts.length === 0) {
                        const seconds = totalSeconds;
                        parts.push(`${seconds}s`);
                    }

                    this.movieTimeAgoEnglish = parts.join('');
                },

                toggleMovieTimeFormat() {
                    const enableMovieDebug = false;
                    if (!(this.movieCountdownArabic || this.movieTimeAgoArabic)) {
                        return;
                    }
                    this.showEnglishMovieTimeFormat = !this.showEnglishMovieTimeFormat;
                    if (enableMovieDebug) console.log('Toggled movie time format:', this.showEnglishMovieTimeFormat);
                },
                
                shuffleZikr() {
                    // If all zikrs have been shown, refill the pool
                    if (this.remainingAdhkar.length === 0) {
                        this.remainingAdhkar = [...this.adhkar];
                    }
                    
                    // Pick a random zikr from the remaining ones
                    const randomIndex = Math.floor(Math.random() * this.remainingAdhkar.length);
                    this.currentZikr = this.remainingAdhkar[randomIndex];
                    
                    // Remove the shown zikr from the pool
                    this.remainingAdhkar.splice(randomIndex, 1);
                },
                updateEpisodeTimeAgo() {
				    const enableTimeAgoDebug = false;
				    
				    if (enableTimeAgoDebug) console.log('updateEpisodeTimeAgo called - episodeOfWeek:', this.episodeOfWeek);
				    
				    if (!this.episodeOfWeek) {
				        if (enableTimeAgoDebug) console.log('No episodeOfWeek found');
				        this.episodeOfWeekTimeAgo = '';
				        return;
				    }
				    
				    if (!this.episodeOfWeek.EpisodeBCDate) {
				        if (enableTimeAgoDebug) console.log('No EpisodeBCDate in episode:', this.episodeOfWeek);
				        this.episodeOfWeekTimeAgo = '';
				        return;
				    }
				
				    const bcDate = this.episodeOfWeek.EpisodeBCDate;
				    if (enableTimeAgoDebug) console.log('Processing EpisodeBCDate:', bcDate);
				    
				    let episodeDate;
				
				    // YYYY-MM-DD
				    if (bcDate.includes('-')) {
				        const dateParts = bcDate.split('-');
				        if (dateParts.length !== 3) {
				            this.episodeOfWeekTimeAgo = '';
				            return;
				        }
				        const [year, month, day] = dateParts.map(Number);
				        episodeDate = new Date(year, month - 1, day);
				
				        // FIXED: set to 12:00 PM
				        episodeDate.setHours(12, 0, 0, 0);
				
				    } 
				    // DD/MM/YYYY
				    else if (bcDate.includes('/')) {
				        const dateParts = bcDate.split('/');
				        if (dateParts.length !== 3) {
				            this.episodeOfWeekTimeAgo = '';
				            return;
				        }
				        const [day, month, year] = dateParts.map(Number);
				        episodeDate = new Date(year, month - 1, day);
				
				        // FIXED: set to 12:00 PM
				        episodeDate.setHours(12, 0, 0, 0);
				
				    } 
				    else {
				        this.episodeOfWeekTimeAgo = '';
				        return;
				    }
				
				    const now = new Date();
				    const diffMs = now - episodeDate;
				    const diffSeconds = Math.floor(diffMs / 1000);
				    const diffMinutes = Math.floor(diffMs / (1000 * 60));
				    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
				    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
				    const diffMonths = Math.floor(diffDays / 30);
				    const diffYears = Math.floor(diffDays / 365);
				
				    const hasExtraSeconds = diffSeconds % 60 > 0;
				    const hasExtraMinutes = diffMinutes % 60 > 0;
				    const hasExtraHours = diffHours % 24 > 0;
				    const hasExtraDays = diffDays % 30 > 0;
				    const hasExtraMonths = (diffDays % 365) >= 30;
				
				    let timeAgoText = '';
				    const moreThan = 'ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ';
				
				    if (diffMinutes < 1) {
				        timeAgoText = 'ÿßŸÑÿ¢ŸÜ';
				    } else if (diffMinutes === 1 && !hasExtraSeconds) {
				        timeAgoText = 'ÿØŸÇŸäŸÇÿ© ŸÖÿ∂ÿ™';
				    } else if (diffMinutes === 1 && hasExtraSeconds) {
				        timeAgoText = moreThan + 'ÿØŸÇŸäŸÇÿ© ŸÖÿ∂ÿ™';
				    } else if (diffMinutes === 2 && !hasExtraSeconds) {
				        timeAgoText = 'ÿØŸÇŸäŸÇÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
				    } else if (diffMinutes === 2 && hasExtraSeconds) {
				        timeAgoText = moreThan + 'ÿØŸÇŸäŸÇÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
				    } else if (diffMinutes >= 3 && diffMinutes <= 10) {
				        timeAgoText = (hasExtraSeconds ? moreThan : '') + `${diffMinutes} ÿØŸÇÿßÿ¶ŸÇ ŸÖÿ∂ÿ™`;
				    } else if (diffMinutes >= 11 && diffMinutes <= 59) {
				        timeAgoText = (hasExtraSeconds ? moreThan : '') + `${diffMinutes} ÿØŸÇŸäŸÇÿ© ŸÖÿ∂ÿ™`;
				    } else if (diffHours === 1 && !hasExtraMinutes) {
				        timeAgoText = 'ÿ≥ÿßÿπÿ© ŸÖÿ∂ÿ™';
				    } else if (diffHours === 1 && hasExtraMinutes) {
				        timeAgoText = moreThan + 'ÿ≥ÿßÿπÿ© ŸÖÿ∂ÿ™';
				    } else if (diffHours === 2 && !hasExtraMinutes) {
				        timeAgoText = 'ÿ≥ÿßÿπÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
				    } else if (diffHours === 2 && hasExtraMinutes) {
				        timeAgoText = moreThan + 'ÿ≥ÿßÿπÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
				    } else if (diffHours >= 3 && diffHours <= 10) {
				        timeAgoText = (hasExtraMinutes ? moreThan : '') + `${diffHours} ÿ≥ÿßÿπÿßÿ™ ŸÖÿ∂ÿ™`;
				    } else if (diffHours >= 11 && diffHours <= 23) {
				        timeAgoText = (hasExtraMinutes ? moreThan : '') + `${diffHours} ÿ≥ÿßÿπÿ© ŸÖÿ∂ÿ™`;
				    } else if (diffDays === 1 && !hasExtraHours) {
				        timeAgoText = 'ŸäŸàŸÖ ŸÖÿ∂Ÿâ';
				    } else if (diffDays === 1 && hasExtraHours) {
				        timeAgoText = moreThan + 'ŸäŸàŸÖ ŸÖÿ∂Ÿâ';
				    } else if (diffDays === 2 && !hasExtraHours) {
				        timeAgoText = 'ŸäŸàŸÖÿßŸÜ ŸÖÿ∂Ÿäÿß';
				    } else if (diffDays === 2 && hasExtraHours) {
				        timeAgoText = moreThan + 'ŸäŸàŸÖÿßŸÜ ŸÖÿ∂Ÿäÿß';
				    } else if (diffDays >= 3 && diffDays <= 10) {
				        timeAgoText = (hasExtraHours ? moreThan : '') + `${diffDays} ÿ£ŸäÿßŸÖ ŸÖÿ∂ÿ™`;
				    } else if (diffDays >= 11 && diffDays < 30) {
				        timeAgoText = (hasExtraHours ? moreThan : '') + `${diffDays} ŸäŸàŸÖŸãÿß ŸÖÿ∂ÿ™`;
				    } else if (diffMonths === 1 && !hasExtraDays && !hasExtraHours && !hasExtraMinutes) {
				        timeAgoText = 'ÿ¥Ÿáÿ± ŸÖÿ∂Ÿâ';
				    } else if (diffMonths === 1 && (hasExtraDays || hasExtraHours || hasExtraMinutes)) {
				        timeAgoText = moreThan + 'ÿ¥Ÿáÿ± ŸÖÿ∂Ÿâ';
				    } else if (diffMonths === 2 && !hasExtraDays && !hasExtraHours && !hasExtraMinutes) {
				        timeAgoText = 'ÿ¥Ÿáÿ±ÿßŸÜ ŸÖÿ∂Ÿäÿß';
				    } else if (diffMonths === 2 && (hasExtraDays || hasExtraHours || hasExtraMinutes)) {
				        timeAgoText = moreThan + 'ÿ¥Ÿáÿ±ÿßŸÜ ŸÖÿ∂Ÿäÿß';
				    } else if (diffMonths >= 3 && diffMonths <= 10) {
				        timeAgoText = ((hasExtraDays || hasExtraHours || hasExtraMinutes) ? moreThan : '') + `${diffMonths} ÿ£ÿ¥Ÿáÿ± ŸÖÿ∂ÿ™`;
				    } else if (diffMonths >= 11 && diffMonths < 12) {
				        timeAgoText = ((hasExtraDays || hasExtraHours || hasExtraMinutes) ? moreThan : '') + `${diffMonths} ÿ¥Ÿáÿ±Ÿãÿß ŸÖÿ∂ÿ™`;
				    } else if (diffYears === 1 && !hasExtraMonths) {
				        timeAgoText = 'ÿ≥ŸÜÿ© ŸÖÿ∂ÿ™';
				    } else if (diffYears === 1 && hasExtraMonths) {
				        timeAgoText = moreThan + 'ÿ≥ŸÜÿ© ŸÖÿ∂ÿ™';
				    } else if (diffYears === 2 && !hasExtraMonths) {
				        timeAgoText = 'ÿ≥ŸÜÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
				    } else if (diffYears === 2 && hasExtraMonths) {
				        timeAgoText = moreThan + 'ÿ≥ŸÜÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
				    } else if (diffYears >= 3 && diffYears <= 10) {
				        timeAgoText = (hasExtraMonths ? moreThan : '') + `${diffYears} ÿ≥ŸÜŸàÿßÿ™ ŸÖÿ∂ÿ™`;
				    } else {
				        timeAgoText = (hasExtraMonths ? moreThan : '') + `${diffYears} ÿ≥ŸÜÿ© ŸÖÿ∂ÿ™`;
				    }
				
				    this.episodeOfWeekTimeAgo = timeAgoText;
				
				    this.updateEpisodeTimeAgoEnglish(episodeDate);
				},
				
				updateEpisodeTimeAgoEnglish(episodeDate) {
				    const enableTimeAgoDebug = false;
				    const now = new Date();
				    const diffMs = now - episodeDate;
				
				    const totalSeconds = Math.floor(diffMs / 1000);
				    const totalMinutes = Math.floor(totalSeconds / 60);
				    const totalHours = Math.floor(totalMinutes / 60);
				    const totalDays = Math.floor(totalHours / 24);
				    const totalMonths = Math.floor(totalDays / 30);
				    const totalYears = Math.floor(totalDays / 365);
				
				    const years = totalYears;
				    const months = totalMonths - (years * 12);
				    const weeks = Math.floor((totalDays - (years * 365) - (months * 30)) / 7);
				    const days = totalDays - (years * 365) - (months * 30) - (weeks * 7);
				    const hours = totalHours - (totalDays * 24);
				    const minutes = totalMinutes - (totalHours * 60);
				
				    let parts = [];
				    if (years > 0) parts.push(`${years}y`);
				    if (months > 0) parts.push(`${months}m`);
				    if (weeks > 0) parts.push(`${weeks}w`);
				    if (days > 0) parts.push(`${days}d`);
				    if (hours > 0) parts.push(`${hours}h`);
				    if (minutes > 0) parts.push(`${minutes}min`);
				
				    if (parts.length === 0) {
				        const seconds = totalSeconds;
				        parts.push(`${seconds}s`);
				    }
				
				    this.episodeOfWeekTimeAgoEnglish = parts.join('');
				},

                toggleTimeFormat() {
                    const enableTimeAgoDebug = false; // Set to true to enable debug logging
                    this.showEnglishTimeFormat = !this.showEnglishTimeFormat;
                    if (enableTimeAgoDebug) console.log('Toggled time format, showEnglish:', this.showEnglishTimeFormat);
                },
                
                toggleTimeFormatManga() {
                    const enableTimeAgoDebug = false; // Set to true to enable debug logging
                    this.showEnglishTimeFormatManga = !this.showEnglishTimeFormatManga;
                    if (enableTimeAgoDebug) console.log('Toggled manga time format, showEnglish:', this.showEnglishTimeFormatManga);
                },

                async loadMangaUpdateDate() {
                    const enableTimeAgoDebug = false; // Set to true to enable debug logging
                    try {
                        const response = await fetch('./lmcud.txt');
                        const text = await response.text();
                        this.mangaUpdateDate = text.trim();
                        if (enableTimeAgoDebug) console.log('Loaded manga update date:', this.mangaUpdateDate);
                        this.updateMangaTimeAgo();
                    } catch (error) {
                        console.error('Error loading manga update date:', error);
                    }
                },

                updateMangaTimeAgo() {
                    const enableTimeAgoDebug = false; // Set to true to enable debug logging
                    
                    if (enableTimeAgoDebug) console.log('updateMangaTimeAgo called - mangaUpdateDate:', this.mangaUpdateDate);
                    
                    if (!this.mangaUpdateDate) {
                        if (enableTimeAgoDebug) console.log('No mangaUpdateDate found');
                        this.mangaOfWeekTimeAgo = '';
                        return;
                    }

                    const dateText = this.mangaUpdateDate;
                    if (enableTimeAgoDebug) console.log('Processing manga date:', dateText);
                    
                    let mangaDate;
                    
                    // Check if date format is YYYY-MM-DD (with dashes)
                    if (dateText.includes('-')) {
                        const dateParts = dateText.split('-');
                        if (dateParts.length !== 3) {
                            if (enableTimeAgoDebug) console.log('Invalid date format with dashes:', dateText);
                            this.mangaOfWeekTimeAgo = '';
                            return;
                        }
                        const [year, month, day] = dateParts.map(Number);
                        mangaDate = new Date(year, month - 1, day);
                        if (enableTimeAgoDebug) console.log('Parsed manga date (YYYY-MM-DD):', mangaDate);
                    } 
                    // Check if date format is DD/MM/YYYY (with slashes)
                    else if (dateText.includes('/')) {
                        const dateParts = dateText.split('/');
                        if (dateParts.length !== 3) {
                            if (enableTimeAgoDebug) console.log('Invalid date format with slashes:', dateText);
                            this.mangaOfWeekTimeAgo = '';
                            return;
                        }
                        const [day, month, year] = dateParts.map(Number);
                        mangaDate = new Date(year, month - 1, day);
                        if (enableTimeAgoDebug) console.log('Parsed manga date (DD/MM/YYYY):', mangaDate);
                    } 
                    else {
                        if (enableTimeAgoDebug) console.log('Unknown date format:', dateText);
                        this.mangaOfWeekTimeAgo = '';
                        return;
                    }
                    
                    const now = new Date();
                    const diffMs = now - mangaDate;
                    const diffSeconds = Math.floor(diffMs / 1000);
                    const diffMinutes = Math.floor(diffMs / (1000 * 60));
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                    const diffMonths = Math.floor(diffDays / 30);
                    const diffYears = Math.floor(diffDays / 365);

                    // Check for remainders to determine if we need "ÿ£ŸÉÿ´ÿ± ŸÖŸÜ"
                    const hasExtraSeconds = diffSeconds % 60 > 0;
                    const hasExtraMinutes = diffMinutes % 60 > 0;
                    const hasExtraHours = diffHours % 24 > 0;
                    const hasExtraDays = diffDays % 30 > 0;
                    const hasExtraMonths = (diffDays % 365) >= 30;

                    let timeAgoText = '';
                    const moreThan = 'ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ';

                    if (diffMinutes < 1) {
                        timeAgoText = 'ÿßŸÑÿ¢ŸÜ';
                    } else if (diffMinutes === 1 && !hasExtraSeconds) {
                        timeAgoText = 'ÿØŸÇŸäŸÇÿ© ŸÖÿ∂ÿ™';
                    } else if (diffMinutes === 1 && hasExtraSeconds) {
                        timeAgoText = moreThan + 'ÿØŸÇŸäŸÇÿ© ŸÖÿ∂ÿ™';
                    } else if (diffMinutes === 2 && !hasExtraSeconds) {
                        timeAgoText = 'ÿØŸÇŸäŸÇÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffMinutes === 2 && hasExtraSeconds) {
                        timeAgoText = moreThan + 'ÿØŸÇŸäŸÇÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffMinutes >= 3 && diffMinutes <= 10) {
                        timeAgoText = (hasExtraSeconds ? moreThan : '') + `${diffMinutes} ÿØŸÇÿßÿ¶ŸÇ ŸÖÿ∂ÿ™`;
                    } else if (diffMinutes >= 11 && diffMinutes <= 59) {
                        timeAgoText = (hasExtraSeconds ? moreThan : '') + `${diffMinutes} ÿØŸÇŸäŸÇÿ© ŸÖÿ∂ÿ™`;
                    } else if (diffHours === 1 && !hasExtraMinutes) {
                        timeAgoText = 'ÿ≥ÿßÿπÿ© ŸÖÿ∂ÿ™';
                    } else if (diffHours === 1 && hasExtraMinutes) {
                        timeAgoText = moreThan + 'ÿ≥ÿßÿπÿ© ŸÖÿ∂ÿ™';
                    } else if (diffHours === 2 && !hasExtraMinutes) {
                        timeAgoText = 'ÿ≥ÿßÿπÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffHours === 2 && hasExtraMinutes) {
                        timeAgoText = moreThan + 'ÿ≥ÿßÿπÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffHours >= 3 && diffHours <= 10) {
                        timeAgoText = (hasExtraMinutes ? moreThan : '') + `${diffHours} ÿ≥ÿßÿπÿßÿ™ ŸÖÿ∂ÿ™`;
                    } else if (diffHours >= 11 && diffHours <= 23) {
                        timeAgoText = (hasExtraMinutes ? moreThan : '') + `${diffHours} ÿ≥ÿßÿπÿ© ŸÖÿ∂ÿ™`;
                    } else if (diffDays === 1 && !hasExtraHours) {
                        timeAgoText = 'ŸäŸàŸÖ ŸÖÿ∂Ÿâ';
                    } else if (diffDays === 1 && hasExtraHours) {
                        timeAgoText = moreThan + 'ŸäŸàŸÖ ŸÖÿ∂Ÿâ';
                    } else if (diffDays === 2 && !hasExtraHours) {
                        timeAgoText = 'ŸäŸàŸÖÿßŸÜ ŸÖÿ∂Ÿäÿß';
                    } else if (diffDays === 2 && hasExtraHours) {
                        timeAgoText = moreThan + 'ŸäŸàŸÖÿßŸÜ ŸÖÿ∂Ÿäÿß';
                    } else if (diffDays >= 3 && diffDays <= 10) {
                        timeAgoText = (hasExtraHours ? moreThan : '') + `${diffDays} ÿ£ŸäÿßŸÖ ŸÖÿ∂ÿ™`;
                    } else if (diffDays >= 11 && diffDays < 30) {
                        timeAgoText = (hasExtraHours ? moreThan : '') + `${diffDays} ŸäŸàŸÖŸãÿß ŸÖÿ∂ÿ™`;
                    } else if (diffMonths === 1 && !hasExtraDays && !hasExtraHours && !hasExtraMinutes) {
                        timeAgoText = 'ÿ¥Ÿáÿ± ŸÖÿ∂Ÿâ';
                    } else if (diffMonths === 1 && (hasExtraDays || hasExtraHours || hasExtraMinutes)) {
                        timeAgoText = moreThan + 'ÿ¥Ÿáÿ± ŸÖÿ∂Ÿâ';
                    } else if (diffMonths === 2 && !hasExtraDays && !hasExtraHours && !hasExtraMinutes) {
                        timeAgoText = 'ÿ¥Ÿáÿ±ÿßŸÜ ŸÖÿ∂Ÿäÿß';
                    } else if (diffMonths === 2 && (hasExtraDays || hasExtraHours || hasExtraMinutes)) {
                        timeAgoText = moreThan + 'ÿ¥Ÿáÿ±ÿßŸÜ ŸÖÿ∂Ÿäÿß';
                    } else if (diffMonths >= 3 && diffMonths <= 10) {
                        timeAgoText = ((hasExtraDays || hasExtraHours || hasExtraMinutes) ? moreThan : '') + `${diffMonths} ÿ£ÿ¥Ÿáÿ± ŸÖÿ∂ÿ™`;
                    } else if (diffMonths >= 11 && diffMonths < 12) {
                        timeAgoText = ((hasExtraDays || hasExtraHours || hasExtraMinutes) ? moreThan : '') + `${diffMonths} ÿ¥Ÿáÿ±Ÿãÿß ŸÖÿ∂ÿ™`;
                    } else if (diffYears === 1 && !hasExtraMonths) {
                        timeAgoText = 'ÿ≥ŸÜÿ© ŸÖÿ∂ÿ™';
                    } else if (diffYears === 1 && hasExtraMonths) {
                        timeAgoText = moreThan + 'ÿ≥ŸÜÿ© ŸÖÿ∂ÿ™';
                    } else if (diffYears === 2 && !hasExtraMonths) {
                        timeAgoText = 'ÿ≥ŸÜÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffYears === 2 && hasExtraMonths) {
                        timeAgoText = moreThan + 'ÿ≥ŸÜÿ™ÿßŸÜ ŸÖÿ∂ÿ™ÿß';
                    } else if (diffYears >= 3 && diffYears <= 10) {
                        timeAgoText = (hasExtraMonths ? moreThan : '') + `${diffYears} ÿ≥ŸÜŸàÿßÿ™ ŸÖÿ∂ÿ™`;
                    } else {
                        timeAgoText = (hasExtraMonths ? moreThan : '') + `${diffYears} ÿ≥ŸÜÿ© ŸÖÿ∂ÿ™`;
                    }

                    this.mangaOfWeekTimeAgo = timeAgoText;
                    if (enableTimeAgoDebug) console.log('Final manga timeAgoText:', timeAgoText, 'mangaOfWeekTimeAgo:', this.mangaOfWeekTimeAgo);
                    
                    // Also calculate English format
                    this.updateMangaTimeAgoEnglish(mangaDate);
                },

                updateMangaTimeAgoEnglish(mangaDate) {
                    const enableTimeAgoDebug = false; // Set to true to enable debug logging
                    const now = new Date();
                    const diffMs = now - mangaDate;
                    
                    // Calculate each time unit
                    const totalSeconds = Math.floor(diffMs / 1000);
                    const totalMinutes = Math.floor(totalSeconds / 60);
                    const totalHours = Math.floor(totalMinutes / 60);
                    const totalDays = Math.floor(totalHours / 24);
                    const totalMonths = Math.floor(totalDays / 30);
                    const totalYears = Math.floor(totalDays / 365);
                    
                    // Calculate remainders
                    const years = totalYears;
                    const months = totalMonths - (years * 12);
                    const weeks = Math.floor((totalDays - (totalYears * 365) - (months * 30)) / 7);
                    const days = totalDays - (years * 365) - (months * 30) - (weeks * 7);
                    const hours = totalHours - (totalDays * 24);
                    const minutes = totalMinutes - (totalHours * 60);
                    
                    // Build compact format string
                    let parts = [];
                    if (years > 0) parts.push(`${years}y`);
                    if (months > 0) parts.push(`${months}m`);
                    if (weeks > 0) parts.push(`${weeks}w`);
                    if (days > 0) parts.push(`${days}d`);
                    if (hours > 0) parts.push(`${hours}h`);
                    if (minutes > 0) parts.push(`${minutes}min`);
                    
                    // If less than a minute, show seconds
                    if (parts.length === 0) {
                        const seconds = totalSeconds;
                        parts.push(`${seconds}s`);
                    }
                    
                    this.mangaOfWeekTimeAgoEnglish = parts.join('');
                    if (enableTimeAgoDebug) console.log('Manga English format:', this.mangaOfWeekTimeAgoEnglish);
                },

                nextPage() {
                    this.comntoVisible = false;
                    this.clearJumpHighlight();
                    if (this.currentPage < this.totalPages) {
                        this.currentPage++;
                        this.trackLastPage();
                    }
                },
                prevPage() {
                    this.comntoVisible = false;
                    this.clearJumpHighlight();
                    if (this.currentPage > 1) {
                        this.currentPage--;
                        this.trackLastPage();
                    }
                },
                goToPage(page) {
                    this.comntoVisible = false;
                    this.clearJumpHighlight();
                    if (page >= 1 && page <= this.totalPages) {
                        this.currentPage = page;
                        this.trackLastPage();
                    }
                },
                trackLastPage() {
                    this.lastPage = this.currentPage;
                },
                goToFirstPage() {
                    this.comntoVisible = false;
                    this.clearJumpHighlight();
                    this.currentPage = 1;
                    this.trackLastPage();
                },
                goToLastPage() {
                    this.comntoVisible = false;
                    this.clearJumpHighlight();
                    this.currentPage = this.totalPages;
                    this.trackLastPage();
                },
                clearJumpHighlight() {
                    this.jumpHighlightIdentifier = null;
                },
                isJumpHighlighted(episode) {
                    if (!episode || !this.jumpHighlightIdentifier) return false;
                    return (
                        this.normalizeEpisodeIdentifier(episode.EpisodeNumber) === this.jumpHighlightIdentifier
                    );
                },
                handlePageSelect(event) {
                    this.comntoVisible = false;
                    this.clearJumpHighlight();
                    let pageInput = event.target.value;

                    // If the value is empty or invalid, set it to 1
                    if (isNaN(parseInt(pageInput, 10))) {
                        pageInput = 1;
                    }

                    let pageNumber = parseInt(pageInput, 10);

                    // Ensure the page number is within the valid range
                    if (pageNumber < 1) {
                        pageNumber = 1;
                    } else if (pageNumber > this.totalPages) {
                        pageNumber = this.totalPages;
                    }

                    // Update the current page and adjust the select value
                    this.currentPage = pageNumber;
                    event.target.value = pageNumber; // Reset the value of the dropdown to the corrected page number
                    this.trackLastPage();
                },

                getMaxForPrefix(prefix) {
                    const p = String(prefix || '').trim();
                    if (!p) return 0;
                    const escaped = this.escapeRegExpLiteral(p);
                    const rx = new RegExp(`^${escaped}\\s*(\\d+(?:\\.\\d+)?)$`, 'i');
                    let max = 0;
                    for (const ep of this.episodes || []) {
                        const s = this.normalizeDigits(String(ep?.EpisodeNumber || '')).trim();
                        const m = rx.exec(s);
                        if (m) {
                            const n = parseFloat(m[1]);
                            if (!isNaN(n) && n > max) max = n;
                        }
                    }
                    return max;
                },
                getMaxNumericEpisode() {
                    let max = -Infinity;
                    let maxStr = '';
                    for (const ep of this.episodes || []) {
                        const s = this.normalizeDigits(String(ep?.EpisodeNumber || '')).trim();
                        if (/^\d+(\.\d+)?$/.test(s)) {
                            const n = parseFloat(s);
                            if (!isNaN(n) && n > max) {
                                max = n;
                                maxStr = s;
                            }
                        }
                    }
                    return maxStr || '1';
                },
                normalizeMagicKaitoBraces(input) {
                    let raw = this.normalizeDigits(String(input || '')).toLowerCase();
                    const quickMatch = raw.match(/^\s*quick-jump\s+target\s+"([^"]+)"\s+was\s+not\s+found\.\s*$/i);
                    if (quickMatch) {
                        raw = this.normalizeDigits(quickMatch[1]).toLowerCase();
                    }
                    if (raw.includes('ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà')) {
                        const hasJ1 = /\{\s*ÿ¨\s*1\s*\}/.test(raw) || /\(\s*ÿ¨\s*1\s*\)/.test(raw);
                        const hasJ2 = /\{\s*ÿ¨\s*2\s*\}/.test(raw) || /\(\s*ÿ¨\s*2\s*\)/.test(raw);
                        if (hasJ1) {
                            raw = raw.replace(/\{\s*ÿ¨\s*1\s*\}/g, '').replace(/\(\s*ÿ¨\s*1\s*\)/g, '').replace(/ŸÖÿßÿ¨ŸäŸÉ\s+ŸÉÿßŸäÿ™Ÿà/g, 'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1');
                        } else if (hasJ2) {
                            raw = raw.replace(/\{\s*ÿ¨\s*2\s*\}/g, '').replace(/\(\s*ÿ¨\s*2\s*\)/g, '').replace(/ŸÖÿßÿ¨ŸäŸÉ\s+ŸÉÿßŸäÿ™Ÿà/g, 'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2');
                        }
                    }
                    return raw;
                },
                buildEpisodeJumpTarget(rawInput) {
                    let s = this.normalizeMagicKaitoBraces(rawInput).trim();
                    if (!s) return '';
                    if (/^\d+(\.\d+)?$/.test(s)) {
                        const maxStr = this.getMaxNumericEpisode();
                        const maxNum = parseFloat(maxStr);
                        let num = parseFloat(s);
                        if (isNaN(num)) num = 1;
                        if (!isNaN(maxNum)) {
                            if (num > maxNum) s = maxStr;
                            else if (num < 1) s = '1';
                            else s = String(s);
                        }
                        return s;
                    }
                    const prefixes = [
                        'ŸÅŸäŸÑŸÖ ÿ™ÿπÿßŸàŸÜŸä',
                        'ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©',
                        'ÿ£ŸàŸÅÿß',
                        'ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ',
                        'ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ',
                        'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1',
                        'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2',
                        'ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà',
                        'ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß',
                        'ÿßŸÑŸÅŸäŸÑŸÖ'
                    ];
                    let matchedPrefix = '';
                    for (const p of prefixes) {
                        const rx = new RegExp(`^\\s*${this.escapeRegExpLiteral(p)}(?=$|[\\sÿå,.])`, 'i');
                        if (rx.test(s)) {
                            matchedPrefix = p;
                            break;
                        }
                    }
                    if (matchedPrefix) {
                        const prefixEndIndex = s.search(new RegExp(`${this.escapeRegExpLiteral(matchedPrefix)}(?=$|[\\sÿå,.])`, 'i')) + matchedPrefix.length;
                        const afterPrefix = s.slice(prefixEndIndex).trim();
                        const numMatch = afterPrefix.match(/^(\d+(?:\.\d+)?)/);
                        let n = numMatch ? parseFloat(numMatch[1]) : NaN;
                        if (isNaN(n)) {
                            const text = this.normalizeDigits(s).toLowerCase();
                            for (let i = 50; i >= 1; i--) {
                                try {
                                    const pattern = this.buildReplacementPatternForKey(String(i));
                                    if (pattern) {
                                        const rx = new RegExp(`(^|[\\sÿå,])${pattern}(?=$|[\\sÿå,])`, 'i');
                                        if (rx.test(text)) {
                                            n = i;
                                            break;
                                        }
                                    }
                                } catch (e) {}
                            }
                            if (isNaN(n)) n = 1;
                        }
                        if (isNaN(n)) n = 1;
                        const max = this.getMaxForPrefix(matchedPrefix);
                        if (max > 0) {
                            if (n > max) n = max;
                            if (n < 1) n = 1;
                        }
                        return `${matchedPrefix} ${String(n)}`;
                    }
                    return s;
                },
                executeJumpValue() {
                    this.resetFilters();
                    this.clearSearch();
                    this.comntoVisible = false;
                    const raw = String(this.jumpInput || '').trim();
                    if (this.jumpTargetMode === 'episode') {
                        if (!raw) {
                            this.toggleSearch();
                            return;
                        }
                    }
                    if (this.jumpTargetMode === 'page') {
                        let val = this.normalizeDigits(raw).trim();
                        let num = parseInt(val, 10);
                        if (isNaN(num)) num = 1;
                        if (num < 1) num = 1;
                        if (num > this.totalPages) num = this.totalPages;
                        if (num === this.currentPage) {
                            this.toggleSearch();
                            return;
                        }
                        this.handlePageSelect({ target: { value: num } });
                        return;
                    }

                    const normalizedInput = this.normalizeDigits(raw).toLowerCase().trim();
                    const normalizedNoBraces = normalizedInput.replace(/\{\s*ÿ¨\s*[12]\s*\}/g, '').replace(/\(\s*ÿ¨\s*[12]\s*\)/g, '').trim();
                    const dataset = Array.isArray(this.filteredEpisodes) ? this.filteredEpisodes : [];

                    // Film cycling: ÿßŸÑŸÅŸäŸÑŸÖ/ŸÅŸäŸÑŸÖ/ÿßŸÑŸÅŸÑŸÖ/ŸÅŸÑŸÖ/ÿßŸÑŸÅŸÑŸäŸÖ/ŸÅŸÑŸäŸÖ
                    const filmMatch = normalizedNoBraces.match(/^(?:ÿßŸÑŸÅŸäŸÑŸÖ|ŸÅŸäŸÑŸÖ|ÿßŸÑŸÅŸÑŸÖ|ŸÅŸÑŸÖ|ÿßŸÑŸÅŸÑŸäŸÖ|ŸÅŸÑŸäŸÖ)(?:\s+(\d+(?:\.\d+)?))?$/i);
                    if (filmMatch) {
                        const movieEpisodes = dataset
                            .filter(ep => {
                                const num = String(ep?.EpisodeNumber || '');
                                return num.includes('ÿßŸÑŸÅŸäŸÑŸÖ') && !num.includes('ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ');
                            })
                            .slice()
                            .sort((a, b) => {
                                const an = parseFloat(String(a.EpisodeNumber || '').match(/\d+\.?\d*$/)?.[0] || '0');
                                const bn = parseFloat(String(b.EpisodeNumber || '').match(/\d+\.?\d*$/)?.[0] || '0');
                                return an - bn;
                            });
                        let queue = movieEpisodes.map(ep => this.normalizeEpisodeIdentifier(ep.EpisodeNumber));
                        const nStr = filmMatch[1] ? String(filmMatch[1]) : null;
                        if (nStr) {
                            const startIdx = queue.findIndex(id => id.endsWith(' ' + nStr));
                            if (startIdx > -1) {
                                queue = queue.slice(startIdx).concat(queue.slice(0, startIdx));
                            } else {
                                // If specific movie number not found, keep queue as is
                            }
                        }
                        if (queue.length) {
                            const key = nStr ? `ÿßŸÑŸÅŸäŸÑŸÖ ${nStr}` : 'ÿßŸÑŸÅŸäŸÑŸÖ';
                            if (this.jumpCycleState && this.jumpCycleState.query === key && Array.isArray(this.jumpCycleState.queue) && this.jumpCycleState.queue.length) {
                                this.jumpCycleState.index = (this.jumpCycleState.index + 1) % this.jumpCycleState.queue.length;
                            } else {
                                this.jumpCycleState = { query: key, queue, index: 0 };
                            }
                            this.pendingJumpTarget = this.jumpCycleState.queue[this.jumpCycleState.index];
                            this.pendingJumpOpenModal = false;
                            this.executePendingJump();
                            return;
                        }
                    }

                    // Magic Kaito cycling: ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà / ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà n
                    const mkMatch = normalizedNoBraces.match(/^\s*ŸÖÿßÿ¨ŸäŸÉ\s+ŸÉÿßŸäÿ™Ÿà(?:\s+(\d+(?:\.\d+)?))?$/i);
                    if (mkMatch) {
                        const nStr = mkMatch[1] ? String(mkMatch[1]) : null;
                        let queue = [];
                        if (nStr) {
                            const candidates = [`ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1 ${nStr}`, `ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2 ${nStr}`].map(id => this.normalizeEpisodeIdentifier(id));
                            queue = candidates.filter(id => dataset.some(ep => this.normalizeEpisodeIdentifier(ep.EpisodeNumber) === id));
                        } else {
                            const mk1 = (this.relatedEpisodeGroups || []).find(g => String(g.title || '').toLowerCase().includes('ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà 1'));
                            const mk2 = (this.relatedEpisodeGroups || []).find(g => String(g.title || '').toLowerCase().includes('ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà 2'));
                            const eps = []
                                .concat(Array.isArray(mk1?.episodes) ? mk1.episodes : [])
                                .concat(Array.isArray(mk2?.episodes) ? mk2.episodes : []);
                            queue = eps
                                .map(e => this.normalizeEpisodeIdentifier(e))
                                .filter(id => dataset.some(ep => this.normalizeEpisodeIdentifier(ep.EpisodeNumber) === id));
                        }
                        if (queue.length) {
                            const key = nStr ? `ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà ${nStr}` : 'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà';
                            if (this.jumpCycleState && this.jumpCycleState.query === key && Array.isArray(this.jumpCycleState.queue) && this.jumpCycleState.queue.length) {
                                this.jumpCycleState.index = (this.jumpCycleState.index + 1) % this.jumpCycleState.queue.length;
                            } else {
                                this.jumpCycleState = { query: key, queue, index: 0 };
                            }
                            this.pendingJumpTarget = this.jumpCycleState.queue[this.jumpCycleState.index];
                            this.pendingJumpOpenModal = false;
                            this.executePendingJump();
                            return;
                        }
                    }

                    // Default behavior with cycling across multiple exact matches
                    const target = this.buildEpisodeJumpTarget(raw);
                    if (!target) return;
                    const normalizedTarget = this.normalizeEpisodeIdentifier(target);
                    const matches = dataset.filter(episode => {
                        const episodeNumberRaw = this.normalizeDigits(String(episode?.EpisodeNumber || '')).toLowerCase();
                        try {
                            const pattern = this.normalizeText(normalizedTarget);
                            if (pattern) {
                                const rx = new RegExp(`^${pattern}$`, 'i');
                                if (rx.test(episodeNumberRaw)) return true;
                            }
                        } catch (e) {}
                        const normalizedEpisodeNumber = this.normalizeEpisodeIdentifier(episode.EpisodeNumber);
                        return normalizedEpisodeNumber === normalizedTarget;
                    });
                    if (matches.length > 1) {
                        const queue = matches.map(ep => this.normalizeEpisodeIdentifier(ep.EpisodeNumber));
                        const key = normalizedTarget;
                        if (this.jumpCycleState && this.jumpCycleState.query === key && Array.isArray(this.jumpCycleState.queue) && this.jumpCycleState.queue.length) {
                            this.jumpCycleState.index = (this.jumpCycleState.index + 1) % this.jumpCycleState.queue.length;
                        } else {
                            this.jumpCycleState = { query: key, queue, index: 0 };
                        }
                        this.pendingJumpTarget = this.jumpCycleState.queue[this.jumpCycleState.index];
                        this.pendingJumpOpenModal = false;
                        this.executePendingJump();
                        return;
                    }
                    this.pendingJumpTarget = target;
                    this.pendingJumpOpenModal = false;
                    this.executePendingJump();
                },
                // Update page size and recalculate total pages
                handlePageSizeChange() {
                    const startIndex = (this.currentPage - 1) * this.oldPageSize;
                    this.currentPage = Math.floor(startIndex / this.pageSize) + 1;

                    if (this.currentPage > this.totalPages) {
                        this.currentPage = this.totalPages;
                    }
                    if (this.currentPage < 1) {
                        this.currentPage = 1;
                    }
                    
                    this.oldPageSize = this.pageSize;
                    this.trackLastPage();
                },

                // Convert Eastern-Arabic / Persian numerals to Western numerals
                normalizeDigits(text) {
                    if (!text) return '';
                    const digitMap = {
                        'Ÿ†': '0', 'Ÿ°': '1', 'Ÿ¢': '2', 'Ÿ£': '3', 'Ÿ§': '4',
                        'Ÿ•': '5', 'Ÿ¶': '6', 'Ÿß': '7', 'Ÿ®': '8', 'Ÿ©': '9',
                        '€∞': '0', '€±': '1', '€≤': '2', '€≥': '3', '€¥': '4',
                        '€µ': '5', '€∂': '6', '€∑': '7', '€∏': '8', '€π': '9',
                    };
                    return String(text).replace(/[Ÿ†-Ÿ©€∞-€π]/g, (digit) => digitMap[digit] || digit);
                },

                normalizeText(text) {
                    let raw = this.normalizeDigits(text).toLowerCase();
                    if (!raw) return '';
                    const quickMatch = raw.match(/^\s*quick-jump\s+target\s+"([^"]+)"\s+was\s+not\s+found\.\s*$/i);
                    if (quickMatch) {
                        raw = this.normalizeDigits(quickMatch[1]).toLowerCase();
                    }

                    if (raw.includes('ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà')) {
                        const hasJ1 = /\{\s*ÿ¨\s*1\s*\}/.test(raw) || /\(\s*ÿ¨\s*1\s*\)/.test(raw);
                        const hasJ2 = /\{\s*ÿ¨\s*2\s*\}/.test(raw) || /\(\s*ÿ¨\s*2\s*\)/.test(raw);
                        if (hasJ1) {
                            raw = raw.replace(/\{\s*ÿ¨\s*1\s*\}/g, '').replace(/\(\s*ÿ¨\s*1\s*\)/g, '').replace(/ŸÖÿßÿ¨ŸäŸÉ\s+ŸÉÿßŸäÿ™Ÿà/g, 'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1');
                        } else if (hasJ2) {
                            raw = raw.replace(/\{\s*ÿ¨\s*2\s*\}/g, '').replace(/\(\s*ÿ¨\s*2\s*\)/g, '').replace(/ŸÖÿßÿ¨ŸäŸÉ\s+ŸÉÿßŸäÿ™Ÿà/g, 'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2');
                        }
                    }

                    if (!this._replacementMatcher) {
                        const keys = Object.keys(this.replacementDict || {})
                            .filter(key => typeof key === 'string' && (key.length >= 2 || /^\d+$/.test(key)))
                            .sort((a, b) => b.length - a.length);

                        const alternation = keys.map(key => this.escapeRegExpLiteral(key)).join('|');
                        this._replacementMatcher = alternation
                            ? new RegExp(`(^|[\\sÿå,])(${alternation})(?=$|[\\sÿå,])`, 'g')
                            : null;
                    }

                    let out = '';
                    let lastIndex = 0;
                    const matcher = this._replacementMatcher;

                    if (matcher) {
                        matcher.lastIndex = 0;
                        let match;
                        while ((match = matcher.exec(raw)) !== null) {
                            out += this.expandFreeTextToPattern(raw.slice(lastIndex, match.index));
                            out += this.expandFreeTextToPattern(match[1] || '');
                            out += this.buildReplacementPatternForKey(match[2] || '');
                            lastIndex = match.index + match[0].length;
                        }
                    }

                    out += this.expandFreeTextToPattern(raw.slice(lastIndex));
                    return out;
                },
                escapeRegExpLiteral(text) {
                    return String(text).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                },
                expandArabicCharToPattern(ch) {
                    if (ch === 'ÿß' || ch === 'ÿ£' || ch === 'ÿ•') return '[ÿßÿ£ÿ•]';
                    if (ch === 'Ÿá' || ch === 'ÿ©') return '[Ÿáÿ©]';
                    if (ch === 'ÿ≥' || ch === 'ÿ¥') return '[ÿ≥ÿ¥]';
                    return this.escapeRegExpLiteral(ch);
                },
                expandFreeTextToPattern(text) {
                    const input = String(text || '');
                    if (!input) return '';
                    let out = '';
                    for (let i = 0; i < input.length; i++) {
                        const ch = input[i];
                        if (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r' || ch === 'ÿå' || ch === ',') {
                            out += '\\s+';
                            while (i + 1 < input.length) {
                                const next = input[i + 1];
                                if (next === ' ' || next === '\t' || next === '\n' || next === '\r' || next === 'ÿå' || next === ',') {
                                    i++;
                                    continue;
                                }
                                break;
                            }
                            continue;
                        }
                        out += this.expandArabicCharToPattern(ch);
                    }
                    return out;
                },
                buildReplacementPatternForKey(key) {
                    const normalizedKey = String(key || '').toLowerCase();
                    if (!normalizedKey) return '';
                    const values = this.replacementDict ? this.replacementDict[normalizedKey] : null;
                    const alternativesRaw = Array.isArray(values) ? [normalizedKey, ...values] : [normalizedKey];

                    const alternatives = [];
                    for (const value of alternativesRaw) {
                        const normalizedValue = String(value || '').toLowerCase();
                        if (!normalizedValue) continue;
                        if (!alternatives.includes(normalizedValue)) {
                            alternatives.push(normalizedValue);
                        }
                    }

                    const patterns = alternatives.map(value => this.expandFreeTextToPattern(value));
                    const uniquePatterns = Array.from(new Set(patterns));

                    if (uniquePatterns.length === 1) return uniquePatterns[0];
                    return `(?:${uniquePatterns.join('|')})`;
                },
                normalizeEpisodeIdentifier(value) {
                    return this.normalizeDigits(String(value || ''))
                        .replace(/\s+/g, ' ')
                        .trim()
                        .toLowerCase();
                },
                parseNumberSearchParts(rawSearchQuery) {
                    const numberList = [];
                    const textFragments = [];
                    const parts = String(rawSearchQuery || '').split(/[ÿå,]/);

                    for (let part of parts) {
                        part = String(part || '').trim();
                        if (!part) continue;

                        const normalizedPart = this.normalizeDigits(part);

                        if (normalizedPart.includes('-') && !normalizedPart.match(/^\d+\.\d+-/)) {
                            const [start, end] = normalizedPart.split('-').map(num => parseFloat(String(num || '').trim()));
                            if (!isNaN(start) && !isNaN(end) && start <= end) {
                                if (Number.isInteger(start) && Number.isInteger(end)) {
                                    for (let i = start; i <= end; i++) {
                                        numberList.push(i.toString());
                                    }
                                } else {
                                    numberList.push(start.toString());
                                    numberList.push(end.toString());
                                }
                            }
                        } else {
                            const num = parseFloat(normalizedPart);
                            if (!isNaN(num)) {
                                numberList.push(num.toString());
                            } else {
                                textFragments.push(normalizedPart);
                            }
                        }
                    }

                    const textFragmentRegexes = textFragments.map(fragment => {
                        try {
                            const pattern = this.normalizeText(fragment);
                            if (!pattern) return null;
                            return new RegExp(pattern, 'i');
                        } catch (e) {
                            return null;
                        }
                    });

                    return { numberList, textFragments, textFragmentRegexes };
                },

                async loadRelatedEpisodesData() {
                    const baseUrl = new URL(window.location.href);
                    const relatedUrl = new URL('relatedEpisodes.json', baseUrl).toString();
                    this.relatedEpisodesDataUrl = relatedUrl;

                    try {
                        const response = await fetch(`${relatedUrl}?t=${Date.now()}`, { cache: 'no-store' });
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        const data = await response.json();

                        const groups = Array.isArray(data?.groups) ? data.groups : [];
                        const byId = {};
                        const byEpisodeKey = {};

                        for (const group of groups) {
                            if (!group || !group.id) continue;
                            const episodes = Array.isArray(group.episodes) ? group.episodes : [];
                            byId[group.id] = { ...group, episodes };
                            for (const epNumber of episodes) {
                                const key = this.normalizeEpisodeIdentifier(epNumber);
                                if (!key) continue;
                                byEpisodeKey[key] = group.id;
                            }
                        }

                        this.relatedEpisodeGroups = groups;
                        this.relatedEpisodeGroupById = byId;
                        this.relatedEpisodeGroupIdByEpisodeKey = byEpisodeKey;
                    } catch (e) {
                        this.relatedEpisodeGroups = [];
                        this.relatedEpisodeGroupById = {};
                        this.relatedEpisodeGroupIdByEpisodeKey = {};
                    }
                },

                rebuildEpisodesByKey() {
                    const map = {};
                    for (const episode of this.episodes || []) {
                        const key = this.normalizeEpisodeIdentifier(episode?.EpisodeNumber);
                        if (!key) continue;
                        map[key] = episode;
                    }
                    this.episodesByEpisodeKey = map;
                },

                getRelatedEpisodeGroup(episode) {
                    const key = this.normalizeEpisodeIdentifier(episode?.EpisodeNumber);
                    const groupId = key ? this.relatedEpisodeGroupIdByEpisodeKey[key] : null;
                    if (!groupId) return null;
                    return this.relatedEpisodeGroupById[groupId] || null;
                },

                getRelatedEpisodesForEpisode(episode) {
                    const group = this.getRelatedEpisodeGroup(episode);
                    if (!group) return [];
                    const episodeNumbers = Array.isArray(group.episodes) ? group.episodes : [];
                    const result = [];
                    for (const epNumber of episodeNumbers) {
                        const key = this.normalizeEpisodeIdentifier(epNumber);
                        const resolved = this.episodesByEpisodeKey[key];
                        if (resolved) {
                            result.push(resolved);
                        } else if (key) {
                            result.push({ EpisodeNumber: String(epNumber), EpisodeTitle: String(epNumber), _relatedMissing: true });
                        }
                    }
                    return result;
                },

                hasRelatedEpisodesForEpisode(episode) {
                    const group = this.getRelatedEpisodeGroup(episode);
                    const episodeNumbers = Array.isArray(group?.episodes) ? group.episodes : [];
                    return episodeNumbers.length > 1;
                },

                isEpisodeSwitchBlocked(episode) {
                    const videosBusy = episode?.EpisodeVideosIDs?.some(video => video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending');
                    const mangasBusy = episode?.EpisodeMangasIDs?.some(manga => manga.status === 'success' || manga.status === 'ratelimiting' || manga.status === 'sending');
                    return !!(videosBusy || mangasBusy);
                },

                toggleRelatedEpisodeMenu() {
                    if (!this.selectedEpisode) return;
                    if (this.isEpisodeSwitchBlocked(this.selectedEpisode)) return;
                    if (!this.hasRelatedEpisodesForEpisode(this.selectedEpisode)) return;
                    this.relatedEpisodeMenuOpen = !this.relatedEpisodeMenuOpen;
                },

                openRelatedEpisode(episode) {
                    if (!episode) return;
                    if (episode._relatedMissing) return;
                    if (this.isEpisodeSwitchBlocked(this.selectedEpisode)) return;
                    if (this.normalizeEpisodeIdentifier(episode.EpisodeNumber) === this.normalizeEpisodeIdentifier(this.selectedEpisode?.EpisodeNumber)) {
                        this.relatedEpisodeMenuOpen = false;
                        return;
                    }
                    this.resetStatusForEpisodeManga();
                    this.relatedEpisodeMenuOpen = false;
                    this.openModal(episode);
                },

                executePendingJump() {
                    if (!this.pendingJumpTarget) return;

                    const targetValue = this.pendingJumpTarget;
                    const openModalAfterJump = !!this.pendingJumpOpenModal;
                    const jumpRegex = this.pendingJumpRegex instanceof RegExp ? this.pendingJumpRegex : null;

                    this.$nextTick(() => {
                        const dataset = Array.isArray(this.filteredEpisodes) ? this.filteredEpisodes : [];
                        const normalizedTarget = this.normalizeEpisodeIdentifier(targetValue);
                        this.jumpHighlightIdentifier = null;

                        if (!dataset.length) {
                            this.pendingJumpTarget = null;
                            return;
                        }

                        const searchTitle = !!(this.searchFilters && this.searchFilters.title);
                        const searchNumber = !(this.searchFilters && this.searchFilters.number === false);
                        const fallbackNumber = !searchTitle && !searchNumber;

                        const matchIndex = dataset.findIndex((episode) => {
                            if (jumpRegex) {
                                const episodeNumberRaw = this.normalizeDigits(String(episode?.EpisodeNumber || '')).toLowerCase();
                                if (jumpRegex.test(episodeNumberRaw)) return true;
                                return false;
                            }

                            if (searchNumber || fallbackNumber) {
                                const episodeNumberRaw = this.normalizeDigits(String(episode?.EpisodeNumber || '')).toLowerCase();
                                try {
                                    const pattern = this.normalizeText(normalizedTarget);
                                    if (pattern) {
                                        const rx = new RegExp(`^${pattern}$`, 'i');
                                        if (rx.test(episodeNumberRaw)) return true;
                                    }
                                } catch (e) {}
                                const normalizedEpisodeNumber = this.normalizeEpisodeIdentifier(episode.EpisodeNumber);
                                if (normalizedEpisodeNumber === normalizedTarget) return true;
                            }

                            if (searchTitle) {
                                const titleRaw = this.normalizeDigits(String(episode?.EpisodeTitle || '')).toLowerCase();
                                try {
                                    const pattern = this.normalizeText(normalizedTarget);
                                    if (pattern) {
                                        const rx = new RegExp(pattern, 'i');
                                        if (rx.test(titleRaw)) return true;
                                    }
                                } catch (e) {}
                                const normalizedEpisodeTitle = this.normalizeEpisodeIdentifier(episode.EpisodeTitle);
                                if (normalizedEpisodeTitle.includes(normalizedTarget)) return true;
                            }

                            return false;
                        });

                        this.pendingJumpTarget = null;
                        this.pendingJumpRegex = null;
                        this.pendingJumpOpenModal = false;

                        if (matchIndex === -1) {
                            console.warn(`Quick-jump target "${targetValue}" was not found.`);
                            return;
                        }

                        const matchedEpisode = dataset[matchIndex];
                        this.jumpHighlightIdentifier = this.normalizeEpisodeIdentifier(matchedEpisode.EpisodeNumber);
                        const targetPage = Math.floor(matchIndex / this.pageSize) + 1;
                        this.currentPage = targetPage;
                        this.trackLastPage();
                        this.searchOpen = false;
                        this.$nextTick(() => {
                            const targetId = 'ep-' + this.jumpHighlightIdentifier;
                            const el = document.getElementById(targetId);
                            if (el && typeof el.scrollIntoView === 'function') {
                                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                            if (openModalAfterJump) {
                                this.openModal(matchedEpisode);
                            }
                        });
                    });
                },

                    // Reset the current page to 1
                resetPageToOne() {
                    this.currentPage = 1; // Reset the page number to 1
                    this.handlePageSelect({ target: { value: 1 } }); // Call handlePageSelect to update
                },

                // IDB Helper
                getDB() {
                    return new Promise((resolve, reject) => {
                        try {
                            const request = indexedDB.open('DCRDB', 1);
                            request.onerror = () => reject('IDB Error');
                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains('store')) {
                                    db.createObjectStore('store');
                                }
                            };
                            request.onsuccess = (event) => resolve(event.target.result);
                        } catch (e) {
                            reject('IDB Error');
                        }
                    });
                },
                saveToIDB(key, data) {
                    return this.getDB().then(db => {
                        return new Promise((resolve, reject) => {
                            try {
                                const tx = db.transaction('store', 'readwrite');
                                const store = tx.objectStore('store');
                                store.put(data, key);
                                tx.oncomplete = () => resolve();
                                tx.onerror = () => reject('IDB Save Error');
                            } catch (e) {
                                reject('IDB Save Error');
                            }
                        });
                    });
                },
                loadFromIDB(key) {
                    return this.getDB().then(db => {
                        return new Promise((resolve, reject) => {
                            try {
                                const tx = db.transaction('store', 'readonly');
                                const store = tx.objectStore('store');
                                const request = store.get(key);
                                request.onsuccess = () => resolve(request.result);
                                request.onerror = () => reject('IDB Load Error');
                            } catch (e) {
                                reject('IDB Load Error');
                            }
                        });
                    });
                },
                // Method to load data version metadata
                async checkDataVersion() {
                    try {
                        const url = `./version.json?t=${Date.now()}`;
                        const response = await fetch(url, { cache: 'no-store' });
                        if (!response.ok) return null;
                        return await response.json();
                    } catch (e) {
                        return null;
                    }
                },
                isVersionUpToDate(localVer, remoteVer) {
                    try {
                        if (!localVer || !remoteVer) return false;
                        const lv = String(localVer.version || '').trim();
                        const rv = String(remoteVer.version || '').trim();
                        const ld = String(localVer.date || '').trim();
                        const rd = String(remoteVer.date || '').trim();
                        return !!lv && !!rv && lv === rv && !!ld && !!rd && ld === rd;
                    } catch (e) {
                        return false;
                    }
                },
                validateDataset(payload) {
                    try {
                        return payload && Array.isArray(payload.Episodes) && Array.isArray(payload.Mangas);
                    } catch (e) {
                        return false;
                    }
                },
                hasCachedDataset() {
                    return this.loadFromIDB('dataset-cache')
                        .then(data => !!this.validateDataset(data))
                        .catch(() => false);
                },

                // Method to load data from JSON
                loadData(force = false) {
                    return new Promise(async (resolve, reject) => {
                        if (this.loading && !force) {
                            console.warn('loadData blocked: Already loading');
                            resolve();
                            return;
                        }
                        if (!this.isTabOwner) {
                            console.warn('loadData blocked: Tab is not the owner');
                            reject('Tab is not the owner');
                            return;
                        }
                        this.loadProgress = 0;

                        if (this.userJoined) {
                            // Try cache-first using IndexedDB if version matches
                            this.error = null;
                            let remoteVersion = null;
                            try { remoteVersion = await this.checkDataVersion(); } catch (e) { remoteVersion = null; }
                            let localVersion = null;
                            try {
                                const raw = localStorage.getItem('dcrdb-version-state');
                                localVersion = raw ? JSON.parse(raw) : null;
                            } catch (e) {
                                localVersion = null;
                            }
                            const versionOk = this.isVersionUpToDate(localVersion, remoteVersion);
                            if (versionOk) {
                                this.loadingFromCache = true;
                                try {
                                    const cached = await this.loadFromIDB('dataset-cache');
                                    if (this.validateDataset(cached)) {
                                        if (this.isTabOwner) {
                                            this.episodes = cached.Episodes || [];
                                            this.mangas = cached.Mangas || [];
                                            this.rebuildEpisodesByKey();
                                            this.updateEpisodeTimeAgo();
                                            this.loading = false;
                                            this.loadProgress = 100;
                                            localStorage.removeItem('waitTime');
                                            this.loadingFromCache = false;
                                        }
                                        resolve();
                                        return;
                                    }
                                } catch (e) {
                                    console.warn('IDB load failed, falling back to network', e);
                                } finally {
                                    this.loadingFromCache = false;
                                }
                            }
                            // Reset states before attempting to fetch
                            this.loadingFromCache = false;
                            this.episodes = [];
                            this.mangas = [];
                            this.error = null;
                            this.loading = true;

                            // Check if a rate-limit countdown is stored
                            const storedWaitTime = localStorage.getItem('waitTime');
                            if (storedWaitTime) {
                                this.waitTime = parseInt(storedWaitTime, 10);
                                this.error = `ŸÑŸÇÿØ ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá ŸÖŸÜ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™. ŸäŸèÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ${this.waitTime} ÿ´ÿßŸÜŸäÿ©.`;
                                this.startTimer(); // Continue the countdown
                                clearInterval(this.progressInterval); // Stop progress animation
                                this.loadProgress = 0; // Reset progress
                                reject('Rate limit exceeded');
                                return;
                            }

                            // Append a cache-busting query parameter
                            const urlWithCacheBust = `${this.jsonUrl}?t=${new Date().getTime()}`;

                            fetch(urlWithCacheBust, { cache: 'no-store' })
                                .then(async response => {
                                    if (response.status === 429) {
                                        const data = await response.json();
                                        if (this.isTabOwner) {
                                            this.loading = false;
                                        }
                                        this.loadProgress = 0;
                                        if (data.error === "User blocked") {
                                            this.error = "ŸÑŸÇÿØ ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá ŸÖŸÜ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÑŸáÿ∞ÿß ÿßŸÑŸäŸàŸÖ.";
                                            reject('User blocked');
                                            return;
                                        }
                                        const resetTime = data.resetTime || Date.now() + 60000;
                                        this.waitTime = Math.max(0, Math.floor((resetTime - Date.now()) / 1000));
                                        this.error = `ŸÑŸÇÿØ ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá ŸÖŸÜ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™. ŸäŸèÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ${this.waitTime} ÿ´ÿßŸÜŸäÿ©.`;
                                        localStorage.setItem('waitTime', this.waitTime);
                                        this.startTimer();
                                        reject('Rate limit exceeded');
                                        return;
                                    }
                                    if (!response.ok) {
                                        throw new Error(`HTTP error! status: ${response.status}`);
                                    }
                                    const reader = response.body.getReader();
                                    const contentLength = +response.headers.get('Content-Length');
                                    let receivedLength = 0;
                                    const chunks = [];
                                    while(true) {
                                        const {done, value} = await reader.read();
                                        if (done) break;
                                        chunks.push(value);
                                        receivedLength += value.length;
                                        if (contentLength) {
                                            this.loadProgress = Math.min(100, Math.round((receivedLength / contentLength) * 100));
                                        } else {
                                            this.loadProgress = Math.min(99, this.loadProgress + 1);
                                        }
                                    }
                                    const allChunks = new Uint8Array(receivedLength);
                                    let position = 0;
                                    for(let chunk of chunks) {
                                        allChunks.set(chunk, position);
                                        position += chunk.length;
                                    }
                                    const resultString = new TextDecoder("utf-8").decode(allChunks);
                                    return JSON.parse(resultString);
                                })
                                .then(async data => {
                                    if (data) {
                                        // Data fetched successfully
                                        clearInterval(this.progressInterval); // Stop progress animation
                                        this.loadProgress = 100; // Set progress to 100%
                                        
                                        // Persist cache and version metadata
                                        try {
                                            await this.saveToIDB('dataset-cache', data);
                                        } catch (e) {
                                            console.warn('Failed to cache dataset in IDB', e);
                                        }
                                        try {
                                            if (remoteVersion && remoteVersion.version) {
                                                localStorage.setItem('dcrdb-version-state', JSON.stringify({
                                                    version: remoteVersion.version,
                                                    date: remoteVersion.date
                                                }));
                                            }
                                        } catch (e) {}

                                        setTimeout(() => {
                                            // Only update data and set loading = false if this tab is the owner
                                            if (this.isTabOwner) {
                                                this.episodes = data.Episodes || [];
                                                this.mangas = data.Mangas || [];
                                                this.rebuildEpisodesByKey();
                                                this.loading = false;
                                                localStorage.removeItem('waitTime');
                                                
                                                // Update episode time ago after data loads
                                                this.updateEpisodeTimeAgo();
                                            }
                                            
                                            resolve();
                                        }, 300); // Delay to show 100% progress
                                    }
                                })
                                .catch(async error => {
                                    clearInterval(this.progressInterval); // Stop progress animation
                                    this.loadProgress = 0; // Reset progress
                                    // Only set loading = false if this tab is the owner
                                    if (this.isTabOwner) {
                                        this.loading = false;
                                    }

                                    // Fallback: try using cached dataset even if version mismatched
                                    try {
                                        const cached = await this.loadFromIDB('dataset-cache');
                                        if (this.validateDataset(cached)) {
                                            if (this.isTabOwner) {
                                                this.episodes = cached.Episodes || [];
                                                this.mangas = cached.Mangas || [];
                                                this.rebuildEpisodesByKey();
                                                this.updateEpisodeTimeAgo();
                                                this.loading = false;
                                                this.loadProgress = 100;
                                                localStorage.removeItem('waitTime');
                                                this.error = null;
                                            }
                                            resolve();
                                            return;
                                        }
                                    } catch (e) {}

                                    if (!this.error && this.isTabOwner) {
                                        this.error = 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. ŸÇÿØ ÿ™ŸÉŸàŸÜ ŸáŸÜÿßŸÉ ŸÖÿ¥ŸÉŸÑÿ© ŸÖÿ§ŸÇÿ™ÿ© ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ£Ÿà ÿßŸÑÿÆÿßÿØŸÖ. ŸäŸèÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑŸÉ ÿ®ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™ ÿ£Ÿà ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ VPN ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.';
                                    }
                                    reject(error);
                                });
                        } else {
                            clearInterval(this.progressInterval); // Stop progress animation
                            this.loadProgress = 0; // Reset progress
                            // Only set loading = false if this tab is the owner
                            if (this.isTabOwner) {
                                this.loading = false;
                            }
                            console.log("User not joined, not loading data.");
                            reject('User not joined to the channel');
                        }        
                    });
                },
                startTimer() {
                    if (this.waitTime > 0) {
                        const timerInterval = setInterval(() => {
                            if (this.waitTime > 0) {
                                this.waitTime -= 1;
                                // Update the error message with the remaining wait time
                                this.error = `ŸÑŸÇÿØ ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá ŸÖŸÜ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™. ŸäŸèÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ${this.waitTime} ÿ´ÿßŸÜŸäÿ©.`;
                                
                                // Update the stored waitTime in localStorage
                                localStorage.setItem('waitTime', this.waitTime);
                            } else {
                                clearInterval(timerInterval); // Stop the timer when waitTime reaches 0
                                this.error = ''; // Reset the error message
                                this.loadData(); // Retry fetching data
                                localStorage.removeItem('waitTime'); // Clear stored waitTime after retry
                                this.reloadPage(); // Refresh the page after countdown ends
                            }
                        }, 1000); // Update every second
                    }
                },

                reloadPage() {
                    location.reload(); // Reloads the page
                    //localStorage.clear();
                    localStorage.removeItem('waitTime');
                },

                getBackgroundColor(episode) {
                        if ((this.selectedFilter === 'all' || this.selectedFilter === 'anime') && this.episodeTypeFilter === 'All') {
                        // Check for special cases first
                        if (episode.EpisodeNumber.includes("ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ")) {
                            return 'bg-cyan-500';
                        } else if (episode.EpisodeNumber.includes("ÿßŸÑŸÅŸäŸÑŸÖ")) {
                            return 'bg-amber-800';
                        } else if (episode.EpisodeSpecial === '1') {
                            return 'bg-sky-800';
                        } else if (episode.EpisodeSpecial === '2') {
                            return 'bg-orange-600';
                        } else if (episode.EpisodeNumber.includes("ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©")) {
                            return 'bg-green-600';
                        } else if (episode.EpisodeNumber.includes("ÿ£ŸàŸÅÿß")) {
                            return 'bg-yellow-600';
                        } else if (episode.EpisodeNumber.includes("ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ")) {
                            return 'bg-purple-500';
                        } else if (episode.EpisodeNumber.includes("ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà")) {
                            return 'bg-indigo-600';
                        } else if (episode.EpisodeNumber.includes("ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà")) {
                            return 'bg-pink-600';
                        } else if (episode.EpisodeNumber.includes("ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß")) {
                            return 'bg-stone-600';
                        }

                        // Check for EpisodeType after exceptions
                        if (episode.EpisodeType === 'ŸÖ' || episode.EpisodeType === 'ÿ´') {
                            return 'bg-teal-900';
                        } else if (episode.EpisodeType === 'ŸÅ') {
                            return 'bg-red-900';
                        }
                    } else if (this.selectedFilter === 'all' && (this.episodeTypeFilter === 'Manga' || this.episodeTypeFilter === 'Filler')) {
                        // Check for special cases first
                        if (episode.EpisodeNumber.includes("ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ")) {
                            return 'bg-cyan-500';
                        } else if (episode.EpisodeNumber.includes("ÿßŸÑŸÅŸäŸÑŸÖ")) {
                            return 'bg-amber-800';
                        } else if (episode.EpisodeSpecial === '1') {
                            return 'bg-sky-800';
                        } else if (episode.EpisodeSpecial === '2') {
                            return 'bg-orange-600';
                        } else if (episode.EpisodeNumber.includes("ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©")) {
                            return 'bg-green-600';
                        } else if (episode.EpisodeNumber.includes("ÿ£ŸàŸÅÿß")) {
                            return 'bg-yellow-600';
                        } else if (episode.EpisodeNumber.includes("ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ")) {
                            return 'bg-purple-500';
                        } else if (episode.EpisodeNumber.includes("ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà")) {
                            return 'bg-indigo-600';
                        } else if (episode.EpisodeNumber.includes("ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà")) {
                            return 'bg-pink-600';
                        } else if (episode.EpisodeNumber.includes("ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß")) {
                            return 'bg-stone-600';
                        }
                    } else if (this.selectedFilter === 'anime' && (this.episodeTypeFilter === 'Manga' || this.episodeTypeFilter === 'Filler')) {
                        // Check for special cases first
                        if (episode.EpisodeSpecial === '1') {
                            return 'bg-sky-800';
                        } else if (episode.EpisodeSpecial === '2') {
                            return 'bg-orange-600';
                        }
                    } else if (this.selectedFilter === 'movies' && this.episodeTypeFilter === 'All') {
                        // Check for special cases first
                        if (episode.EpisodeType === 'ŸÖ' || episode.EpisodeType === 'ÿ´') {
                            return 'bg-teal-900';
                        } else if (episode.EpisodeType === 'ŸÅ') {
                            return 'bg-red-900';
                        }
                    } else if ((this.selectedFilter === 'hourly_special' || this.selectedFilter === 'two_hour_special') && this.episodeTypeFilter === 'All') {
                        // Check for special cases first
                        if (episode.EpisodeType === 'ŸÖ' || episode.EpisodeType === 'ÿ´') {
                            return 'bg-teal-900';
                        } else if (episode.EpisodeType === 'ŸÅ') {
                            return 'bg-red-900';
                        }
                    }
                    return ''; // Default case
                },
                openModal(episode) { 
                    this.selectedEpisode = episode;
                    this.comntoVisible = false;
                    this.showModal = true;
                    document.body.style.overflow = 'hidden'; // Block background scrolling

                    const currentIndex = this.episodes.findIndex(
                        (ep) => ep.EpisodeNumber === episode.EpisodeNumber
                    );

                    // Check if there are more episodes with the same EpisodeParts
                    if (episode.EpisodeParts) {
                        // Check for next episode existence
                        this.nextEpisodeExists = this.episodes.some(
                            (ep, index) =>
                                index > currentIndex &&
                                ep.EpisodeParts === episode.EpisodeParts
                        );

                        // Check for previous episode existence
                        this.previousEpisodeExists = this.episodes.some(
                            (ep, index) =>
                                index < currentIndex &&
                                ep.EpisodeParts === episode.EpisodeParts
                        );
                    } else {
                        this.nextEpisodeExists = false; // Hide button if EpisodeParts is null/undefined
                        this.previousEpisodeExists = false;
                    }

                    // Check for next/previous episode by number order
                    this.nextEpisodeByNumberExists = currentIndex < this.episodes.length - 1;
                    this.previousEpisodeByNumberExists = currentIndex > 0;
                },
                closeModal() {
                    if (this.episodeSendInProgress) {
                        this.pendingCloseTarget = 'modal';
                        this.showSendInProgressConfirmation = true;
                        return;
                    }
                    this.forceCloseModal();
                },

                forceCloseModal() {
                    this.dismissSuccessHint();
                    this.forceCloseTrailerModal();
                    this.showModal = false;
                    this.comntoVisible = false;
                    document.body.style.overflow = '';
                    
                    if (this.selectedEpisode) {
                        if (this.selectedEpisode.EpisodeVideosIDs) {
                            this.selectedEpisode.EpisodeVideosIDs.forEach((video, index) => {
                                if (video.countdownInterval) {
                                    clearInterval(video.countdownInterval);
                                    video.countdownInterval = null;
                                }
                                video.countdown = undefined;
                                this.selectedEpisode.EpisodeVideosIDs[index].status = null;
                            });
                        }
                        
                        if (this.selectedEpisode.EpisodeMangasIDs) {
                            this.selectedEpisode.EpisodeMangasIDs.forEach((manga, index) => {
                                if (manga.countdownInterval) {
                                    clearInterval(manga.countdownInterval);
                                    manga.countdownInterval = null;
                                }
                                manga.countdown = undefined;
                                this.selectedEpisode.EpisodeMangasIDs[index].status = null;
                            });
                        }
                    }
                    
                    this.ratelimiting = false;
                    this.errorMessage = "";
                    
                    const tempEpisode = this.selectedEpisode;
                    if (!this.preserveSelectedEpisodeOnModalClose) {
                        this.selectedEpisode = null;
                    }
                    this.spoilerVisible = false;
                    
                    setTimeout(() => {
                        if (tempEpisode) {
                            if (tempEpisode.EpisodeVideosIDs) {
                                tempEpisode.EpisodeVideosIDs.forEach(video => {
                                    if (video.countdownInterval) {
                                        clearInterval(video.countdownInterval);
                                        video.countdownInterval = null;
                                    }
                                });
                            }
                            if (tempEpisode.EpisodeMangasIDs) {
                                tempEpisode.EpisodeMangasIDs.forEach(manga => {
                                    if (manga.countdownInterval) {
                                        clearInterval(manga.countdownInterval);
                                        manga.countdownInterval = null;
                                    }
                                });
                            }
                        }
                    }, 0);
                    this.preserveSelectedEpisodeOnModalClose = false;
                },

                openTrailerModal() {
                    if (!this.episodeTrailers.length) return;
                    this.showTrailerModal = true;
                    const firstGroup = this.groupedTrailers[0];
                    this.selectedTrailerGroupKey = firstGroup ? firstGroup.key : null;
                    const firstProvider = this.activeTrailerProviders[0];
                    this.selectedTrailerProviderKey = firstProvider ? firstProvider.key : null;
                    const firstTrailer = this.activeTrailerProviderTrailers[0] || null;
                    this.selectedTrailer = firstTrailer;
                    this.isTrailerIframeLoading = Boolean(firstTrailer && !this.isActiveTrailerProviderTelegram);
                    this.trailerIframeSrc = firstTrailer && !this.isActiveTrailerProviderTelegram
                        ? this.buildTrailerIframeSrc(firstTrailer.Provider, firstTrailer.TrailerID)
                        : '';
                },

                closeTrailerModal() {
                    if (this.trailerSendInProgress) {
                        this.pendingCloseTarget = 'trailer';
                        this.showSendInProgressConfirmation = true;
                        return;
                    }
                    this.forceCloseTrailerModal();
                },

                forceCloseTrailerModal() {
                    this.showTrailerModal = false;
                    this.selectedTrailerGroupKey = null;
                    this.selectedTrailerProviderKey = null;
                    this.selectedTrailer = null;
                    this.trailerIframeSrc = '';
                    this.isTrailerIframeLoading = false;
                },

                handleAutoCloseIfRequested(target) {
                    if (!this.showSendInProgressConfirmation && !this.pendingCloseTarget) return;

                    if (this.pendingCloseTarget !== target) {
                        if (this.pendingCloseTarget == null) {
                            this.showSendInProgressConfirmation = false;
                        }
                        return;
                    }

                    if (target === 'modal' && this.episodeSendInProgress) return;
                    if (target === 'directWindow' && this.directSendInProgress) return;
                    if (target === 'trailer' && this.trailerSendInProgress) return;

                    this.showSendInProgressConfirmation = false;
                    this.pendingCloseTarget = null;

                    if (target === 'modal' && this.showModal) {
                        this.forceCloseModal();
                        return;
                    }
                    if (target === 'directWindow' && this.showDirectWindow) {
                        this.forceCloseDirectWindow();
                        return;
                    }
                    if (target === 'trailer' && this.showTrailerModal) {
                        this.forceCloseTrailerModal();
                        return;
                    }
                },

                confirmCancelSend() {
                    this.sendCancelGeneration += 1;

                    const target =
                        this.pendingCloseTarget ||
                        (this.showModal ? 'modal' : (this.showDirectWindow ? 'directWindow' : (this.showTrailerModal ? 'trailer' : null)));

                    this.showSendInProgressConfirmation = false;
                    this.pendingCloseTarget = null;

                    if (target === 'modal' && this.showModal) {
                        this.forceCloseModal();
                        return;
                    }
                    if (target === 'directWindow' && this.showDirectWindow) {
                        this.forceCloseDirectWindow();
                        return;
                    }
                    if (target === 'trailer' && this.showTrailerModal) {
                        this.forceCloseTrailerModal();
                        return;
                    }
                },

                cancelSendInProgressClose() {
                    this.showSendInProgressConfirmation = false;
                    this.pendingCloseTarget = null;
                },

                openCaptureCancelConfirmation() {
                    if (!this.isCapturingEpisodeTableImages) return;
                    this.showCaptureInProgressConfirmation = true;
                },

                guardIfCapturing() {
                    if (!this.isCapturingEpisodeTableImages) return false;
                    this.openCaptureCancelConfirmation();
                    return true;
                },

                guardEventIfCapturing(event) {
                    if (!this.isCapturingEpisodeTableImages) return false;
                    try {
                        if (event && typeof event.preventDefault === 'function') event.preventDefault();
                        if (event && typeof event.stopPropagation === 'function') event.stopPropagation();
                    } catch (e) {}
                    this.openCaptureCancelConfirmation();
                    return true;
                },

                confirmCancelCapture() {
                    this.captureCancelRequested = true;
                    this.showCaptureInProgressConfirmation = false;
                },

                cancelCaptureInProgressClose() {
                    this.showCaptureInProgressConfirmation = false;
                },

                selectTrailerGroup(groupKey) {
                    this.selectedTrailerGroupKey = groupKey;
                    const firstProvider = this.activeTrailerProviders[0];
                    this.selectedTrailerProviderKey = firstProvider ? firstProvider.key : null;
                    const firstTrailer = this.activeTrailerProviderTrailers[0] || null;
                    this.selectedTrailer = firstTrailer;
                    this.isTrailerIframeLoading = Boolean(firstTrailer && !this.isActiveTrailerProviderTelegram);
                    this.trailerIframeSrc = firstTrailer && !this.isActiveTrailerProviderTelegram
                        ? this.buildTrailerIframeSrc(firstTrailer.Provider, firstTrailer.TrailerID)
                        : '';
                },

                selectTrailerProvider(providerKey) {
                    this.selectedTrailerProviderKey = providerKey;
                    const firstTrailer = this.activeTrailerProviderTrailers[0] || null;
                    this.selectedTrailer = firstTrailer;
                    this.isTrailerIframeLoading = Boolean(firstTrailer && !this.isActiveTrailerProviderTelegram);
                    this.trailerIframeSrc = firstTrailer && !this.isActiveTrailerProviderTelegram
                        ? this.buildTrailerIframeSrc(firstTrailer.Provider, firstTrailer.TrailerID)
                        : '';
                },

                handleTrailerIframeLoad() {
                    this.isTrailerIframeLoading = false;
                },

                handleTrailerIframeError() {
                    this.isTrailerIframeLoading = false;
                },

                buildTrailerIframeSrc(provider, trailerId) {
                    const id = trailerId == null ? '' : String(trailerId).trim();
                    if (!id) return '';

                    if (/^https?:\/\//i.test(id)) return id;

                    const p = (provider == null ? '' : String(provider)).toLowerCase();
                    if (p === 'tg' || p.includes('telegram')) return '';
                    if (p.includes('mega')) return `https://mega.nz/embed/${encodeURIComponent(id)}`;
                    if (p.includes('gdrive') || p.includes('google') || p.includes('drive')) return `https://drive.google.com/file/d/${encodeURIComponent(id)}/preview`;
                    return id;
                },

                buildTrailerExternalUrl(provider, trailerId) {
                    const idRaw = trailerId == null ? '' : String(trailerId).trim();
                    if (!idRaw) return '';

                    const p = (provider == null ? '' : String(provider)).toLowerCase();
                    const isHttp = /^https?:\/\//i.test(idRaw);

                    if (isHttp) {
                        if (idRaw.includes('drive.google.com') && idRaw.endsWith('/preview')) {
                            return idRaw.replace(/\/preview$/, '/view');
                        }
                        if (idRaw.includes('mega.nz') && idRaw.includes('/embed/')) {
                            return idRaw.replace('/embed/', '/file/');
                        }
                        return idRaw;
                    }

                    if (p.includes('gdrive') || p.includes('google') || p.includes('drive')) {
                        return `https://drive.google.com/file/d/${encodeURIComponent(idRaw)}/view`;
                    }
                    if (p.includes('mega')) {
                        return `https://mega.nz/file/${idRaw}`;
                    }
                    return idRaw;
                },

                openTrailerInBrowser() {
                    const url = this.trailerExternalUrl;
                    if (!url) return;
                    if (webApp && typeof webApp.openLink === 'function') {
                        webApp.openLink(url);
                        return;
                    }
                    window.open(url, '_blank', 'noopener,noreferrer');
                },

                async sendTrailerWrapper(trailer) {
                    this.handleMediaSend({
                        type: 'trailer',
                        fileId: trailer.TrailerID,
                        resolution: trailer.Resolution,
                        size: trailer.Size,
                        trailerItem: trailer
                    });
                },

                openEmptyPopup() {
                    if (this.guardIfCapturing()) return;
                    this.showEmptyPopup = true; // Show the popup
                    document.body.style.overflow = 'hidden'; // Block background scrolling
                    this.comntoVisible = false;
                },
                closeEmptyPopup() {
                    this.showEmptyPopup = false; // Hide the popup
                    document.body.style.overflow = ''; // Restore background scrolling
                    this.clearActiveFilterHighlight();
                },

                resetFilters() {
                    this.episodeTypeFilter = 'All';
                    this.selectedFilter = 'all';
                    for (const [key, value] of Object.entries(FILTER_STATE_DEFAULTS)) {
                        this[key] = value;
                    }
                    this.activeFilterCycleIndex = -1;
                    this.clearActiveFilterHighlight();
                },

                toggleSpoiler() {
                    this.spoilerVisible = !this.spoilerVisible; // Toggle visibility
                },

                highlightSpoilerText() {
                    const text = this.spoilerVisible ? "ÿ•ÿÆŸÅÿßÿ° ÿßŸÑŸÖŸÑÿÆÿµ" : "ÿßŸÑŸÖŸÑÿÆÿµ (ÿ≠ÿ±ŸÇ)";
                    
                    // Highlight "ÿ≠ÿ±ŸÇ" in red
                    return text.replace('ÿ≠ÿ±ŸÇ', '<span class="text-red-500 font-bold">ÿ≠ÿ±ŸÇ</span>');
                },

                fetchNextEpisode() {
                    this.spoilerVisible = false;
                    // Find the current episode's index
                    const currentIndex = this.episodes.findIndex(
                        (ep) => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber
                    );

                    // Find the next episode with the same EpisodeParts
                    const nextEpisode = this.episodes.find(
                        (ep, index) =>
                            index > currentIndex &&
                            ep.EpisodeParts === this.selectedEpisode.EpisodeParts
                    );

                    if (nextEpisode) {
                        this.openModal(nextEpisode); // Open the modal for the next episode
                    } else {
                        this.nextEpisodeExists = false; // Hide the button
                    }
                },

                fetchPreviousEpisode() {
                    this.spoilerVisible = false;
                    // Find the current episode's index
                    const currentIndex = this.episodes.findIndex(
                        (ep) => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber
                    );

                    // Find the previous episode with the same EpisodeParts
                    const previousEpisode = [...this.episodes].reverse().find(
                        (ep, index) =>
                            index > this.episodes.length - 1 - currentIndex &&
                            ep.EpisodeParts === this.selectedEpisode.EpisodeParts
                    );

                    if (previousEpisode) {
                        this.openModal(previousEpisode); // Open the modal for the previous episode
                    } else {
                        this.previousEpisodeExists = false; // Hide the button
                    }
                },

                fetchNextEpisodeByNumber() {
                    this.spoilerVisible = false;
                    // Get the filtered episodes based on current filter
                    const filteredEps = this.filteredEpisodes;
                    
                    // Find the current episode's index in the filtered array
                    const currentIndex = filteredEps.findIndex(
                        (ep) => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber
                    );

                    // Find the next episode by filtered array order
                    const nextEpisode = filteredEps[currentIndex + 1];

                    if (nextEpisode) {
                        this.openModal(nextEpisode); // Open the modal for the next episode
                    } else {
                        this.nextEpisodeByNumberExists = false; // Hide the button
                    }
                },

                fetchPreviousEpisodeByNumber() {
                    this.spoilerVisible = false;
                    // Get the filtered episodes based on current filter
                    const filteredEps = this.filteredEpisodes;
                    
                    // Find the current episode's index in the filtered array
                    const currentIndex = filteredEps.findIndex(
                        (ep) => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber
                    );

                    // Find the previous episode by filtered array order
                    const previousEpisode = filteredEps[currentIndex - 1];

                    if (previousEpisode) {
                        this.openModal(previousEpisode); // Open the modal for the previous episode
                    } else {
                        this.previousEpisodeByNumberExists = false; // Hide the button
                    }
                },

                getEpisodeNumberSortValue(episode) {
                    const raw = this.normalizeDigits(String(episode?.EpisodeNumber ?? ''));
                    const match = raw.match(/\d+/);
                    if (!match) return 0;
                    const parsed = parseInt(match[0], 10);
                    return isNaN(parsed) ? 0 : parsed;
                },

                getEpisodePartsGroupEpisodes(episode) {
                    const key = episode?.EpisodeParts;
                    if (!key) return [];
                    const all = Array.isArray(this.episodes) ? this.episodes : [];
                    return all.filter((ep) => ep && ep.EpisodeParts === key);
                },

                getArabicOrdinalNumberText(n) {
                    const map = {
                        1: 'ÿßŸÑÿ£ŸàŸÑ',
                        2: 'ÿßŸÑÿ´ÿßŸÜŸä',
                        3: 'ÿßŸÑÿ´ÿßŸÑÿ´',
                        4: 'ÿßŸÑÿ±ÿßÿ®ÿπ',
                        5: 'ÿßŸÑÿÆÿßŸÖÿ≥',
                        6: 'ÿßŸÑÿ≥ÿßÿØÿ≥',
                        7: 'ÿßŸÑÿ≥ÿßÿ®ÿπ',
                        8: 'ÿßŸÑÿ´ÿßŸÖŸÜ',
                        9: 'ÿßŸÑÿ™ÿßÿ≥ÿπ',
                        10: 'ÿßŸÑÿπÿßÿ¥ÿ±',
                        11: 'ÿßŸÑÿ≠ÿßÿØŸä ÿπÿ¥ÿ±',
                        12: 'ÿßŸÑÿ´ÿßŸÜŸä ÿπÿ¥ÿ±',
                        13: 'ÿßŸÑÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±',
                        14: 'ÿßŸÑÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±',
                        15: 'ÿßŸÑÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±',
                        16: 'ÿßŸÑÿ≥ÿßÿØÿ≥ ÿπÿ¥ÿ±',
                        17: 'ÿßŸÑÿ≥ÿßÿ®ÿπ ÿπÿ¥ÿ±',
                        18: 'ÿßŸÑÿ´ÿßŸÖŸÜ ÿπÿ¥ÿ±',
                        19: 'ÿßŸÑÿ™ÿßÿ≥ÿπ ÿπÿ¥ÿ±',
                        20: 'ÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        21: 'ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        22: 'ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        23: 'ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        24: 'ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        25: 'ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        26: 'ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        27: 'ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        28: 'ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        29: 'ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿπÿ¥ÿ±ŸàŸÜ',
                        30: 'ÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        31: 'ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        32: 'ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        33: 'ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        34: 'ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        35: 'ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        36: 'ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        37: 'ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        38: 'ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        39: 'ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ´ŸÑÿßÿ´ŸàŸÜ',
                        40: 'ÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        41: 'ÿßŸÑÿ≠ÿßÿØŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        42: 'ÿßŸÑÿ´ÿßŸÜŸä ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        43: 'ÿßŸÑÿ´ÿßŸÑÿ´ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        44: 'ÿßŸÑÿ±ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        45: 'ÿßŸÑÿÆÿßŸÖÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        46: 'ÿßŸÑÿ≥ÿßÿØÿ≥ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        47: 'ÿßŸÑÿ≥ÿßÿ®ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        48: 'ÿßŸÑÿ´ÿßŸÖŸÜ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        49: 'ÿßŸÑÿ™ÿßÿ≥ÿπ ŸàÿßŸÑÿ£ÿ±ÿ®ÿπŸàŸÜ',
                        50: 'ÿßŸÑÿÆŸÖÿ≥ŸàŸÜ'
                    };
                    return map[n] || String(n);
                },

                buildEpisodePartsReplyMarkup(episode) {
                    if (!episode?.EpisodeParts) return null;
                    const group = this.getEpisodePartsGroupEpisodes(episode);
                    if (!group || group.length <= 1) return null;

                    const normalizedCurrent = this.normalizeEpisodeIdentifier(episode.EpisodeNumber);
                    const sorted = group.slice().sort((a, b) => this.getEpisodeNumberSortValue(a) - this.getEpisodeNumberSortValue(b));

                    const inline_keyboard = sorted.map((ep, idx) => {
                        const partNumber = idx + 1;
                        const ordinal = this.getArabicOrdinalNumberText(partNumber);
                        const isCurrent = this.normalizeEpisodeIdentifier(ep.EpisodeNumber) === normalizedCurrent;
                        const text = `ÿßŸÑÿ¨ÿ≤ÿ° ${ordinal}${isCurrent ? ' ‚úÖ' : ''}`;
                        const code = this.normalizeEpisodeIdentifier(ep?.EpisodeNumber);
                        return [{
                            text,
                            web_app: { url: `${WEB_APP_URL}?code=${encodeURIComponent(code)}` }
                        }];
                    });

                    return { inline_keyboard };
                },

                parseEpisodeLabel(episodeNumber) {
                    let label = "ÿ±ŸÇŸÖ ÿßŸÑÿ≠ŸÑŸÇÿ©:";
                    let num = episodeNumber;
                    let suffix = "";
                    
                    const rules = [
                        { key: "ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÅŸäŸÑŸÖ", label: "ÿ±ŸÇŸÖ ÿßŸÑÿ≠ŸÑŸÇÿ© ÿßŸÑÿÆÿßÿµÿ©:" },
                        { key: "ÿßŸÑŸÅŸäŸÑŸÖ", label: "ÿ±ŸÇŸÖ ÿßŸÑŸÅŸäŸÑŸÖ:" },
                        { key: "ŸÇÿµÿ© ŸÇÿµŸäÿ±ÿ©", label: "ÿ±ŸÇŸÖ ÿßŸÑŸÇÿµÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ©:" },
                        { key: "ÿ£ŸàŸÅÿß3", label: "ÿ±ŸÇŸÖ ÿßŸÑÿ£ŸàŸÅÿß ÿßŸÑÿ´ÿßŸÑÿ´ÿ©:" },
                        { key: "ÿ£ŸàŸÅÿß2", label: "ÿ±ŸÇŸÖ ÿßŸÑÿ£ŸàŸÅÿß ÿßŸÑÿ´ÿßŸÜŸäÿ©:" },
                        { key: "ÿ£ŸàŸÅÿß", label: "ÿ±ŸÇŸÖ ÿßŸÑÿ£ŸàŸÅÿß:" },
                        { key: "ÿ•ÿµÿØÿßÿ± ÿÆÿßÿµ", label: "ÿ±ŸÇŸÖ ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑÿÆÿßÿµ:" },
                        { key: "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1", label: "ÿ±ŸÇŸÖ ÿ≠ŸÑŸÇÿ© ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà:", suffix: " (ÿ¨1)" },
                        { key: "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2", label: "ÿ±ŸÇŸÖ ÿ≠ŸÑŸÇÿ© ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà:", suffix: " (ÿ¨2)" },
                        { key: "ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà", label: "ÿ±ŸÇŸÖ ÿ≠ŸÑŸÇÿ© ŸäŸàŸÖŸäÿßÿ™ ÿ≤Ÿäÿ±Ÿà:" },
                        { key: "ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß", label: "ÿ±ŸÇŸÖ ÿ≠ŸÑŸÇÿ© ÿßŸÑŸÖÿ¨ÿ±ŸÖ ŸáÿßŸÜÿ≤ÿßŸàÿß:" },
                        { key: "ŸÅŸäŸÑŸÖ ÿ™ÿπÿßŸàŸÜŸä", label: "ÿ±ŸÇŸÖ ÿßŸÑŸÅŸäŸÑŸÖ ÿßŸÑÿ™ÿπÿßŸàŸÜŸä:" }
                    ];

                    for (const rule of rules) {
                        if (num.includes(rule.key)) {
                            if (rule.label) label = rule.label;
                            num = num.replace(rule.key, "");
                            if (rule.suffix) suffix = rule.suffix;
                            
                            num = num.trim();
                            break;
                        }
                    }
                    return { cleanNum: num + suffix, cleanLabel: label };
                },
                
                formatEpisodeNumber(episodeNumber) {
                    const s = String(episodeNumber || "");
                    if (s.includes("ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà1") || s.includes("ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2")) {
                        const { cleanNum } = this.parseEpisodeLabel(s);
                        return "ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà " + cleanNum;
                    }
                    return s;
                },

                async sendTelegramMedia(payloadData) {
                    // Block API request if this tab is not the owner
                    if (!this.isTabOwner) {
                        console.warn('sendTelegramMedia blocked: Tab is not the owner');
                        throw new Error('This tab is not the active tab. Please close other tabs and refresh.');
                    }
                    
                    const payload = new URLSearchParams();
                    payload.append("chat_id", webApp?.initDataUnsafe?.user?.id);
                    payload.append("parse_mode", "MarkdownV2");
                    
                    for (const [key, value] of Object.entries(payloadData)) {
                        if (value !== undefined && value !== null) {
                            if (typeof value === 'object' && (key === 'reply_markup' || key === 'videoDetails')) {
                                payload.append(key, JSON.stringify(value));
                            } else {
                                payload.append(key, value);
                            }
                        }
                    }

                    try {
                        const response = await fetch(`${this.jsonUrl}/send`, {
                            method: "POST",
                            headers: { "Content-Type": "application/x-www-form-urlencoded" },
                            body: payload.toString(),
                        });

                        const text = await response.text();
                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (e) {
                            throw new Error("Invalid JSON response from Worker:\n" + text);
                        }

                        if (!response.ok) {
                            const status = data?.status || response.status;
                            throw new Error(`Telegram Error: (${status}) ` + (data.description || text) + ` (${webApp?.initDataUnsafe?.user?.id})`);
                        }

                    } catch (error) {
                        console.error(error);
                        throw new Error(error.message);
                    }
                },

                async handleMediaSend({ type, fileId, index, label, size, resolution, videoDetails, isDirectManga, trailerItem }) {
                    if (!this.isTabOwner) {
                        console.warn(`${type} send blocked: Tab is not the owner`);
                        throw new Error('This tab is not the active tab. Please close other tabs and refresh.');
                    }

                    const episodeRef = this.selectedEpisode;
                    let itemRef = null;
                    let parentRefForRateLimit = episodeRef;

                    if (type === 'video') {
                        if (!episodeRef?.EpisodeNumber) return;
                        itemRef = episodeRef?.EpisodeVideosIDs?.[index];
                    } else if (type === 'manga') {
                        if (isDirectManga) {
                            itemRef = this.selectedManga;
                            if (!itemRef?.MangaNumber) return;
                        } else {
                            if (!episodeRef?.EpisodeNumber) return;
                            itemRef = episodeRef?.EpisodeMangasIDs?.[index];
                        }
                    } else if (type === 'trailer') {
                        if (!episodeRef?.EpisodeNumber) return;
                        itemRef = trailerItem;
                    }

                    if (!itemRef) return;

                    const sendGen = this.sendCancelGeneration;

                    // Resolve size if not provided
                    let mediaSize = size;
                    if (!mediaSize) {
                        if (type === 'video') mediaSize = itemRef.Size;
                        else if (type === 'manga') mediaSize = itemRef.MangaFileSize;
                        else if (type === 'trailer') mediaSize = itemRef.Size;
                    }

                    this.ratelimiting = true;
                    if (type === 'trailer') {
                        const trailersRef = Array.isArray(this.activeTrailerProviderTrailers) ? this.activeTrailerProviderTrailers : [];
                        trailersRef.forEach((t) => {
                            if (t && t !== itemRef) t.status = 'ratelimiting';
                        });
                    } else {
                        if (parentRefForRateLimit?.EpisodeVideosIDs) {
                            parentRefForRateLimit.EpisodeVideosIDs.forEach((video, i) => {
                                if (type === 'video' && i === index) return;
                                video.status = 'ratelimiting';
                            });
                        }
                        if (parentRefForRateLimit?.EpisodeMangasIDs) {
                            parentRefForRateLimit.EpisodeMangasIDs.forEach((manga, i) => {
                                if (type === 'manga' && !isDirectManga && i === index) return;
                                manga.status = 'ratelimiting';
                            });
                        }
                    }

                    let caption = '';
                    
                    function escapeMarkdown(text) {
                        return String(text).replace(/[_*[\]()~`>#+\-=|{}.!]/g, '\\$&');
                    }

                    if (type === 'manga') {
                        caption = `*ÿßŸÑŸÅÿµŸÑ: ${escapeMarkdown(label)}\nÿßŸÑÿ≠ÿ¨ŸÖ: ${escapeMarkdown(this.formatFileSize(mediaSize, true))}*`;
                    } else if (type === 'trailer') {
                        let episodeNumber = String(episodeRef.EpisodeNumber);
                        const isMovie = episodeNumber.includes("ÿßŸÑŸÅŸäŸÑŸÖ");

                        if (isMovie) {
                            episodeNumber = episodeNumber.replace("ÿßŸÑŸÅŸäŸÑŸÖ", "").trim();
                        }

                        const trailerNumberRaw = itemRef.TrailerNumber == null ? '' : String(itemRef.TrailerNumber).trim();
                        const trailerNumberText = trailerNumberRaw ? ` ${trailerNumberRaw}` : '';
                        const titleLine = isMovie
                            ? `ÿ•ÿπŸÑÿßŸÜ${trailerNumberText} ŸÑŸÑŸÅŸäŸÑŸÖ ${episodeNumber}`
                            : `ÿ•ÿπŸÑÿßŸÜ${trailerNumberText} ŸÑŸÑÿ≠ŸÑŸÇÿ© ${episodeNumber}`;

                        caption = `*${escapeMarkdown(titleLine)}\nÿßŸÑÿ¨ŸàÿØÿ©: ${escapeMarkdown(resolution)}\nÿßŸÑÿ≠ÿ¨ŸÖ: ${escapeMarkdown(this.formatFileSize(mediaSize, true))}*`;
                    } else {
                        const { cleanNum, cleanLabel } = this.parseEpisodeLabel(episodeRef.EpisodeNumber);
                        
                        let details = "";
                        if (videoDetails) {
                             const fields = [
                                 { key: 'introductionTime', label: 'ÿßŸÑŸÖŸÇÿØŸÖÿ©' },
                                 { key: 'startStoryTime', label: 'ÿ®ÿØÿßŸäÿ© ÿßŸÑŸÇÿµÿ©' },
                                 { key: 'episodeSuspenseTime', label: 'ÿ™ÿ¥ŸàŸäŸÇ ÿßŸÑÿ≠ŸÑŸÇÿ©' },
                                 { key: 'startSongTime', label: 'ÿ£ÿ∫ŸÜŸäÿ© ÿßŸÑÿ®ÿØÿßŸäÿ©' },
                                 { key: 'chapterOneTime', label: 'ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ£ŸàŸÑ' },
                                 { key: 'chapterTwoTime', label: 'ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ´ÿßŸÜŸä' },
                                 { key: 'endSongTime', label: 'ÿ£ÿ∫ŸÜŸäÿ© ÿßŸÑŸÜŸáÿßŸäÿ©' },
                                 { key: 'chapterThreeTime', label: 'ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ´ÿßŸÑÿ´' },
                                 { key: 'nextEpisodeTeaserTime', label: 'ÿ™ÿ¥ŸàŸäŸÇ ÿßŸÑÿ≠ŸÑŸÇÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©' },
                                 { key: 'nextEpisodeHintTime', label: 'ÿ™ŸÑŸÖŸäÿ≠ ÿßŸÑÿ≠ŸÑŸÇÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©' }
                             ];
                             fields.forEach(f => {
                                 if (videoDetails[f.key]) details += `\n*${f.label}:* ${escapeMarkdown(videoDetails[f.key])}`;
                             });
                        }

                        caption = `*${escapeMarkdown(cleanLabel)} ${escapeMarkdown(cleanNum)}\nÿßŸÑÿπŸÜŸàÿßŸÜ: ${escapeMarkdown(episodeRef.EpisodeTitle || '')}\nÿßŸÑÿ¨ŸàÿØÿ©: ${escapeMarkdown(resolution)}\nÿßŸÑÿ≠ÿ¨ŸÖ: ${escapeMarkdown(this.formatFileSize(mediaSize, true))}*`;
                        if (details) caption += `\n\n*‚ú¶‚ú¶‚Äî ŸÖÿ≠ÿ™ŸàŸäÿßÿ™ ÿßŸÑÿ≠ŸÑŸÇÿ© ‚Äî‚ú¶‚ú¶*${details}`;
                    }

                    itemRef.status = 'sending';

                    try {
                        if (type === 'video') {
                            const replyMarkup = this.buildEpisodePartsReplyMarkup(episodeRef);
                            await this.sendTelegramMedia({
                                method: "sendVideo",
                                file_id: fileId,
                                caption: caption,
                                cover: "AgACAgQAAxkBAAI39mewS5AKaNozUttDedMhI3xOcZdzAAJ7xzEb4AyBUdi6fgZXlnXYAQADAgADdwADNgQ",
                                reply_markup: replyMarkup
                            });
                        } else if (type === 'trailer') {
                            await this.sendTelegramMedia({
                                method: "sendVideo",
                                file_id: fileId,
                                caption: caption,
                                cover: "AgACAgQAAxkBAAI39mewS5AKaNozUttDedMhI3xOcZdzAAJ7xzEb4AyBUdi6fgZXlnXYAQADAgADdwADNgQ"
                            });
                        } else {
                            await this.sendTelegramMedia({
                                method: "sendDocument",
                                file_id: fileId,
                                caption: caption
                            });
                        }

                        if (this.sendCancelGeneration !== sendGen) return;
                        
                        itemRef.status = 'success';
                        
                        if (type === 'video') {
                            const isMovie = String(episodeRef?.EpisodeNumber ?? '').includes('ÿßŸÑŸÅŸäŸÑŸÖ');
                            this.movie.status = isMovie ? 'success' : null;
                            this.episode.status = isMovie ? null : 'success';
                            this.showSuccessHint(isMovie ? 'ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäŸÑŸÖ ŸÑŸÑÿÆÿßÿµ' : 'ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ≠ŸÑŸÇÿ© ŸÑŸÑÿÆÿßÿµ');
                            if (this.selectedEpisode === episodeRef) {
                                this.startCountdown(index);
                            }
                        } else if (type === 'trailer') {
                            this.showSuccessHint('ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿπŸÑÿßŸÜ ŸÑŸÑÿÆÿßÿµ');
                            this.startCountdownForTrailer(itemRef);
                        } else {
                            this.showSuccessHint('ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅÿµŸÑ ŸÑŸÑÿÆÿßÿµ');
                            if (isDirectManga) {
                                if (this.selectedManga === itemRef) this.startCountdownForMangaD();
                            } else {
                                if (this.selectedEpisode === episodeRef) this.startCountdownForManga(index);
                            }
                        }
                        this.errorMessage = "";

                    } catch (error) {
                        if (this.sendCancelGeneration !== sendGen) return;
                        itemRef.status = 'error';
                        this.errorMessage = error?.message || String(error);
                        
                        if (type === 'trailer') return;

                        const group = type === 'video' ? episodeRef?.EpisodeVideosIDs : episodeRef?.EpisodeMangasIDs;
                        if (Array.isArray(group) && group.some(item => item.status === "error")) {
                             return;
                        }
                    }

                    setTimeout(() => {
                        if (this.sendCancelGeneration !== sendGen) return;
                        
                        if (itemRef) {
                             if (itemRef.countdownInterval) {
                                clearInterval(itemRef.countdownInterval);
                                itemRef.countdownInterval = null;
                            }
                            itemRef.countdown = undefined;
                            itemRef.status = null;
                        }

                        if (type === 'trailer') {
                            const trailersRef = Array.isArray(this.activeTrailerProviderTrailers) ? this.activeTrailerProviderTrailers : [];
                            trailersRef.forEach((t) => {
                                if (!t || t === itemRef) return;
                                t.status = null;
                            });
                        }

                        this.ratelimiting = false;

                        if (type !== 'trailer') {
                            if (episodeRef?.EpisodeVideosIDs) {
                                episodeRef.EpisodeVideosIDs.forEach((video) => {
                                    if (video.status === 'ratelimiting') video.status = null;
                                    if (video.countdownInterval) {
                                        clearInterval(video.countdownInterval);
                                        video.countdownInterval = null;
                                    }
                                    video.countdown = undefined;
                                });
                            }
                            if (episodeRef?.EpisodeMangasIDs) {
                                episodeRef.EpisodeMangasIDs.forEach((manga) => {
                                    if (manga.status === 'ratelimiting') manga.status = null;
                                    if (manga.countdownInterval) {
                                        clearInterval(manga.countdownInterval);
                                        manga.countdownInterval = null;
                                    }
                                    manga.countdown = undefined;
                                });
                            }
                        }
                        
                        if (type === 'video') {
                             this.episode.status = null;
                             this.movie.status = null;
                        }
                    }, this.statusClearTimeout);
                },

                async sendEpisodeToBot(videoID, resolution, size, index, introductionTime, startStoryTime, episodeSuspenseTime, startSongTime, chapterOneTime, chapterTwoTime, endSongTime, chapterThreeTime, nextEpisodeTeaserTime, nextEpisodeHintTime) {
                    this.handleMediaSend({
                        type: 'video',
                        fileId: videoID,
                        index,
                        size,
                        resolution,
                        videoDetails: {
                            introductionTime, startStoryTime, episodeSuspenseTime, startSongTime, 
                            chapterOneTime, chapterTwoTime, endSongTime, chapterThreeTime, 
                            nextEpisodeTeaserTime, nextEpisodeHintTime
                        }
                    });
                },

                sleep(ms) {
                    const n = Number(ms || 0);
                    return new Promise((resolve) => setTimeout(resolve, Math.max(0, n)));
                },

                async sleepWithCountdown(ms) {
                    const total = Math.max(0, Number(ms || 0));
                    if (!total) {
                        this.captureEpisodeTableDelayRemainingMs = 0;
                        return true;
                    }

                    const tickMs = 250;
                    const start = Date.now();
                    this.captureEpisodeTableDelayRemainingMs = total;

                    while (true) {
                        if (this.captureCancelRequested) {
                            this.captureEpisodeTableDelayRemainingMs = 0;
                            return false;
                        }

                        const elapsed = Date.now() - start;
                        const remaining = Math.max(0, total - elapsed);
                        this.captureEpisodeTableDelayRemainingMs = remaining;
                        if (remaining <= 0) break;
                        await this.sleep(Math.min(tickMs, remaining));
                    }

                    this.captureEpisodeTableDelayRemainingMs = 0;
                    return true;
                },

                sanitizeFilenamePart(text) {
                    return String(text || '')
                        .replace(/[\\/:*?"<>|]/g, '_')
                        .replace(/\s+/g, '_')
                        .replace(/_+/g, '_')
                        .replace(/^_+|_+$/g, '');
                },

                getCaptureEnabledFilterLabels() {
                    const labels = [];
                    const add = (v) => {
                        const s = String(v || '').trim();
                        if (s) labels.push(s);
                    };

                    add(this.selectedFilterLabel);
                    if (this.episodeTypeFilter && this.episodeTypeFilter !== 'All') add(this.episodeTypeFilterLabel);

                    const ui = this.filterUi || {};
                    const toggleLists = [ui.groupOptions, ui.sceneOptions];
                    for (const list of toggleLists) {
                        if (!Array.isArray(list)) continue;
                        for (const opt of list) {
                            if (!opt || !opt.modelKey) continue;
                            if (this[opt.modelKey]) add(opt.label);
                        }
                    }

                    const characterLabels = ui.characterLabels || {};
                    const selectedCharacterLabels = [];
                    for (const id of Object.keys(characterLabels)) {
                        const key = typeof this.characterEpisodesKey === 'function' ? this.characterEpisodesKey(id) : `filter${id}Episodes`;
                        if (this[key]) selectedCharacterLabels.push(characterLabels[id]);
                    }
                    if (selectedCharacterLabels.length === 1) {
                        add(selectedCharacterLabels[0]);
                    } else if (selectedCharacterLabels.length > 1) {
                        add(selectedCharacterLabels.join(' Ÿà '));
                    }
                    return labels;
                },

                async sendPhotoResponse(photoBlob, filename, caption) {
                    if (!this.isTabOwner) {
                        console.warn('sendPhotoResponse blocked: Tab is not the owner');
                        throw new Error('This tab is not the active tab. Please close other tabs and refresh.');
                    }

                    const fd = new FormData();
                    fd.append('method', 'sendPhoto');
                    fd.append('chat_id', webApp?.initDataUnsafe?.user?.id);
                    fd.append('caption', caption || '');
                    fd.append('parse_mode', 'MarkdownV2');

                    const safeName = String(filename || 'image.png');
                    const file = new File([photoBlob], safeName, { type: photoBlob.type || 'image/png' });
                    fd.append('photo', file);

                    try {
                        const response = await fetch(`${this.jsonUrl}/send`, {
                            method: 'POST',
                            body: fd,
                        });

                        const text = await response.text();
                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (e) {
                            throw new Error('Invalid JSON response from Worker:\n' + text);
                        }

                        if (!response.ok) {
                            const status = data?.status || response.status;
                            throw new Error(`Telegram Error: (${status}) ` + (data.description || text) + ` (${webApp?.initDataUnsafe?.user?.id})`);
                        }
                    } catch (error) {
                        console.error(error);
                        throw new Error(error.message);
                    }
                },

                buildEpisodeTableCaptureNode(episodes, headerNumber, headerTitle, captureTitleText, footerLine1, footerLine2) {
                    const wrapper = document.createElement('div');
                    wrapper.style.position = 'fixed';
                    wrapper.style.left = '0';
                    wrapper.style.top = '0';
                    wrapper.style.transform = 'none';
                    wrapper.style.opacity = '0';
                    wrapper.style.pointerEvents = 'none';
                    wrapper.style.setProperty('--tw-bg-opacity', '1');
                    wrapper.style.backgroundColor = 'rgb(31 41 55 / var(--tw-bg-opacity, 1))';
                    wrapper.style.padding = '15px 0px';
                    wrapper.style.width = '1024px';
                    wrapper.style.boxSizing = 'border-box';
                    wrapper.style.direction = 'rtl';
                    wrapper.style.fontFamily = '"Expo Arabic Light", Arial, sans-serif';

                    const fontStyle = document.createElement('style');
                    fontStyle.textContent = "@font-face { font-family: 'Expo Arabic Light'; src: url('https://raw.githubusercontent.com/c7bb/6Y9//main/c28sdcm1jv977n4u63yccbty376l23p0xc38n0b2l4qgrje4d2xwjou9g76xdglsprhbpo1f5dhil392v5xeileb94p8g3le9f/res/EAL.woff2') format('woff2'); font-style: normal; font-weight: 300; }";
                    wrapper.appendChild(fontStyle);

                    const tailwindBgToHex = {
                        'bg-cyan-500': '#06b6d4',
                        'bg-amber-800': '#92400e',
                        'bg-sky-800': '#075985',
                        'bg-orange-600': '#ea580c',
                        'bg-green-600': '#16a34a',
                        'bg-yellow-600': '#ca8a04',
                        'bg-purple-500': '#a855f7',
                        'bg-indigo-600': '#4f46e5',
                        'bg-pink-600': '#db2777',
                        'bg-stone-600': '#57534e',
                        'bg-teal-900': '#134e4a',
                        'bg-red-900': '#7f1d1d',
                    };

                    const titleWrap = document.createElement('div');
                    titleWrap.style.textAlign = 'center';
                    titleWrap.style.fontSize = '20px';
                    titleWrap.style.fontWeight = '800';
                    titleWrap.style.color = '#f97316';
                    titleWrap.style.marginBottom = '12px';
                    titleWrap.style.whiteSpace = 'pre-line';
                    titleWrap.textContent = String(captureTitleText || '');
                    wrapper.appendChild(titleWrap);

                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.borderCollapse = 'collapse';
                    table.style.border = '1px solid #d1d5db';
                    table.style.tableLayout = 'fixed';
                    table.style.background = '#2a2a2a';

                    const thead = document.createElement('thead');
                    const headRow = document.createElement('tr');
                    const th1 = document.createElement('th');
                    th1.style.border = '1px solid #d1d5db';
                    th1.style.padding = '10px 8px';
                    th1.style.textAlign = 'center';
                    th1.style.fontSize = '22px';
                    th1.style.fontWeight = '700';
                    th1.style.width = '16%';
                    th1.style.background = '#2a2a2a';
                    th1.style.color = 'rgb(108, 255, 0)';
                    th1.textContent = String(headerNumber || '');
                    const th2 = document.createElement('th');
                    th2.style.border = '1px solid #d1d5db';
                    th2.style.padding = '10px 12px';
                    th2.style.textAlign = 'center';
                    th2.style.fontSize = '22px';
                    th2.style.fontWeight = '700';
                    th2.style.width = '84%';
                    th2.style.background = '#2a2a2a';
                    th2.style.color = 'rgb(108, 255, 0)';
                    th2.textContent = String(headerTitle || '');
                    headRow.appendChild(th1);
                    headRow.appendChild(th2);
                    thead.appendChild(headRow);
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');
                    const list = Array.isArray(episodes) ? episodes : [];
                    for (const episode of list) {
                        const tr = document.createElement('tr');
                        const td1 = document.createElement('td');
                        td1.style.border = '1px solid #d1d5db';
                        td1.style.padding = '10px 8px';
                        td1.style.textAlign = 'center';
                        td1.style.fontSize = '18px';
                        td1.style.fontWeight = '700';
                        td1.style.width = '16%';
                        td1.style.background = '#2a2a2a';
                        try {
                            const bgClass = typeof this.getBackgroundColor === 'function'
                                ? this.getBackgroundColor({
                                    ...episode,
                                    EpisodeNumber: String(episode?.EpisodeNumber ?? ''),
                                    EpisodeSpecial: String(episode?.EpisodeSpecial ?? ''),
                                    EpisodeType: String(episode?.EpisodeType ?? ''),
                                })
                                : '';
                            const bg = tailwindBgToHex[bgClass];
                            if (bg) td1.style.background = bg;
                        } catch (e) {}
                        td1.textContent = String(episode?.EpisodeNumber ?? '');
                        const td2 = document.createElement('td');
                        td2.style.border = '1px solid #d1d5db';
                        td2.style.padding = '10px 12px';
                        td2.style.textAlign = 'center';
                        td2.style.fontSize = '18px';
                        td2.style.fontWeight = '700';
                        td2.style.width = '84%';
                        td2.style.wordBreak = 'break-word';
                        td2.style.overflowWrap = 'anywhere';
                        td2.style.background = '#2a2a2a';
                        td2.textContent = String(episode?.EpisodeTitle ?? '');
                        tr.appendChild(td1);
                        tr.appendChild(td2);
                        tbody.appendChild(tr);
                    }
                    table.appendChild(tbody);

                    wrapper.appendChild(table);

                    const footerWrap = document.createElement('div');
                    footerWrap.style.textAlign = 'center';
                    footerWrap.style.marginTop = '14px';
                    footerWrap.style.fontSize = '16px';
                    footerWrap.style.fontWeight = '800';
                    footerWrap.style.color = '#00ffff';
                    footerWrap.style.whiteSpace = 'pre-line';
                    const footerText = [footerLine1, footerLine2].map(v => String(v || '').trim()).filter(Boolean).join('\n');
                    footerWrap.textContent = footerText;
                    wrapper.appendChild(footerWrap);
                    return wrapper;
                },

                async renderEpisodeTableCaptureBlob(node) {
                    if (!window.htmlToImage || typeof window.htmlToImage.toBlob !== 'function') {
                        throw new Error('ŸÖŸÉÿ™ÿ®ÿ© html-to-image ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©');
                    }

                    let fontEmbedCSS = '';
                    try {
                        if (typeof window.htmlToImage.getFontEmbedCSS === 'function') {
                            fontEmbedCSS = await window.htmlToImage.getFontEmbedCSS(node);
                        }
                    } catch (e) {
                        fontEmbedCSS = '';
                    }

                    const attempt = async (pixelRatio) => {
                        const width = Math.ceil(Number(node?.scrollWidth || node?.offsetWidth || 0)) || 1024;
                        const height = Math.ceil(Number(node?.scrollHeight || node?.offsetHeight || 0)) || 1;
                        return await window.htmlToImage.toBlob(node, {
                            backgroundColor: 'rgb(31 41 55 / 1)',
                            pixelRatio,
                            cacheBust: true,
                            fontEmbedCSS,
                            skipFonts: true,
                            style: {
                                opacity: '1',
                                transform: 'none',
                                left: '0',
                                top: '0',
                                background: 'rgb(31 41 55 / 1)',
                            },
                            width,
                            height,
                            filter: (n) => {
                                const tag = String(n?.tagName || '').toUpperCase();
                                if (tag === 'LINK') return false;
                                return true;
                            },
                        });
                    };

                    const blob2x = await attempt(2);
                    if (blob2x && blob2x.size <= 9.5 * 1024 * 1024) return blob2x;

                    const blob15x = await attempt(1.5);
                    if (blob15x && blob15x.size <= 9.5 * 1024 * 1024) return blob15x;

                    const blob1x = await attempt(1);
                    if (blob1x) return blob1x;

                    throw new Error('ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿµŸàÿ±ÿ©');
                },

                async captureEpisodeTableImages() {
                    if (this.isCapturingEpisodeTableImages) return;

                    const episodes = Array.isArray(this.filteredEpisodes) ? this.filteredEpisodes.slice() : [];
                    const chunkSize = 15;
                    const total = Math.ceil(episodes.length / chunkSize);
                    if (!total) return;

                    this.isCapturingEpisodeTableImages = true;
                    this.captureCancelRequested = false;
                    this.captureEpisodeTableImagesDone = 0;
                    this.captureEpisodeTableImagesTotal = total;
                    this.captureEpisodeTableDelayRemainingMs = 0;

                    try {
                        try {
                            if (document.fonts && typeof document.fonts.load === 'function') {
                                await document.fonts.load('16px "Expo Arabic Light"');
                                if (document.fonts.ready) await document.fonts.ready;
                            }
                        } catch (e) {}

                        const enabledLabels = this.getCaptureEnabledFilterLabels();
                        const enabledLabelText = enabledLabels.join(' - ');
                        const enabledKeyParts = [
                            this.selectedFilter,
                            this.episodeTypeFilter,
                            ...(enabledLabels.length ? enabledLabels : []),
                        ].map((p) => this.sanitizeFilenamePart(p)).filter(Boolean);
                        const baseName = enabledKeyParts.slice(0, 10).join('_') || 'table';

                        for (let i = 0; i < total; i += 1) {
                            if (this.captureCancelRequested) break;
                            const start = i * chunkSize;
                            const chunk = episodes.slice(start, start + chunkSize);
                            const part = i + 1;
                            const titleText = `ÿßŸÑÿ™ÿµŸÅŸäÿ©: ${enabledLabelText}\nÿßŸÑÿ¨ÿ≤ÿ°: ${part}/${total}`;
                            const node = this.buildEpisodeTableCaptureNode(
                                chunk,
                                this.episodeNumberHeader,
                                this.episodeTitleHeader,
                                titleText,
                                'ÿ£ŸèŸÜÿ¥Ÿêÿ¶ÿ™ ÿßŸÑÿµŸàÿ±ÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ÿØŸÑŸäŸÑ ÿßŸÑŸÖÿ≠ŸÇŸÇ ŸÉŸàŸÜÿßŸÜ | DCRef_bot@',
                                't.me/DCRef_bot'
                            );
                            document.body.appendChild(node);
                            await new Promise((resolve) => requestAnimationFrame(() => requestAnimationFrame(resolve)));

                            let blob;
                            try {
                                blob = await this.renderEpisodeTableCaptureBlob(node);
                            } finally {
                                node.remove();
                            }

                            const rowStart = start + 1;
                            const rowEnd = Math.min(start + chunkSize, episodes.length);
                            const filename = `${baseName}_rows_${rowStart}-${rowEnd}.png`;

                            const captionText = `ÿßŸÑÿ™ÿµŸÅŸäÿ©: ${enabledLabelText}\nÿßŸÑÿµŸÅŸàŸÅ: ${rowEnd}-${rowStart}\nÿßŸÑÿ¨ÿ≤ÿ°: ${part}/${total}`;
                            const caption = `*${this.escapeMarkdown(captionText)}*`;
                            await this.sendPhotoResponse(blob, filename, caption);
                            this.captureEpisodeTableImagesDone = part;
                            this.showSuccessHint(`ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ±ÿ© (${this.captureEpisodeTableImagesDone}/${this.captureEpisodeTableImagesTotal}) ŸÑŸÑÿÆÿßÿµ`);

                            if (part < total) {
                                const ok = await this.sleepWithCountdown(2000);
                                if (!ok) break;
                            }
                        }

                        if (this.captureCancelRequested) {
                            this.showSuccessHint('ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ™ÿµŸàŸäÿ±');
                        } else {
                            this.showSuccessHint('ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ± ŸÑŸÑÿÆÿßÿµ');
                        }
                    } catch (e) {
                        this.errorMessage = e?.message || String(e);
                        throw e;
                    } finally {
                        this.isCapturingEpisodeTableImages = false;
                        this.captureEpisodeTableDelayRemainingMs = 0;
                        setTimeout(() => {
                            this.captureEpisodeTableImagesDone = 0;
                            this.captureEpisodeTableImagesTotal = 0;
                        }, 2000);
                    }
                },

                async sendMangaWrapper(fileId, mangaNumber, index, isDirect) {
                    this.handleMediaSend({
                        type: 'manga',
                        fileId,
                        index,
                        label: mangaNumber,
                        isDirectManga: isDirect
                    });
                },

                openSpecificEpisode(episodeCode) {
                    if (this.guardIfCapturing()) return;
                    if (!this.episodes || this.episodes.length === 0) {
                        console.log('Episodes data is not loaded yet!');
                        return; // Exit early if episodes data is not loaded
                    }

                    const direct = this.episodes.find(ep => ep.EpisodeNumber === episodeCode);
                    const episode = direct || this.episodes.find((ep) => this.normalizeEpisodeIdentifier(ep.EpisodeNumber) === this.normalizeEpisodeIdentifier(episodeCode));

                    if (episode) {
                        this.openModal(episode); // Open the modal for the found episode
                    } else {
                        console.log("Episode not found!", { requested: episodeCode, totalLoaded: this.episodes.length });
                    }
                },

                clearError() {
                    // Reset ALL statuses for episode mangas (not just errors)
                    if (this.selectedEpisode?.EpisodeMangasIDs) {
                        this.selectedEpisode.EpisodeMangasIDs.forEach((manga) => {
                            // Clear countdown interval if it exists
                            if (manga.countdownInterval) {
                                clearInterval(manga.countdownInterval);
                                manga.countdownInterval = null;
                            }
                            manga.countdown = undefined;
                            manga.status = null;
                        });
                    }

                    // Reset ALL statuses for episode videos (not just errors)
                    if (this.selectedEpisode?.EpisodeVideosIDs) {
                        this.selectedEpisode.EpisodeVideosIDs.forEach((video) => {
                            // Clear countdown interval if it exists
                            if (video.countdownInterval) {
                                clearInterval(video.countdownInterval);
                                video.countdownInterval = null;
                            }
                            video.countdown = undefined;
                            video.status = null;
                        });
                    }

                    if (Array.isArray(this.episodeTrailers)) {
                        this.episodeTrailers.forEach((trailer) => {
                            if (!trailer) return;
                            if (trailer.countdownInterval) {
                                clearInterval(trailer.countdownInterval);
                                trailer.countdownInterval = null;
                            }
                            trailer.countdown = undefined;
                            trailer.status = null;
                        });
                    }

                    // Reset the status of selectedManga
                    if (this.selectedManga) {
                        // Clear countdown interval if it exists
                        if (this.selectedManga.countdownInterval) {
                            clearInterval(this.selectedManga.countdownInterval);
                            this.selectedManga.countdownInterval = null;
                        }
                        this.selectedManga.countdown = undefined;
                        this.selectedManga.status = null;
                    }

                    // Reset the status of selectedEpisode
                    if (this.selectedEpisode) {
                        this.selectedEpisode.status = null;
                    }

                    // Always reset ratelimiting flag
                    this.ratelimiting = false;
                    this.errorMessage = "";
                },

                findUnescapedMarkdownV2Chars(text) {
                    const re = /(?:^|[^\\])([_*[\]()~`>#+\-=|{}.!])/g;
                    const out = [];
                    const s = String(text || '');
                    let m;
                    while ((m = re.exec(s)) !== null) {
                        out.push({ index: m.index + (m[0].length - 1), char: m[1] });
                    }
                    return out;
                },

                validateAllEpisodeTitlesMarkdown() {
                    const eps = Array.isArray(this.episodes) ? this.episodes : [];
                    const issues = [];
                    const seen = new Set();
                    for (const ep of eps) {
                        const title = String(ep.EpisodeTitle || '');
                        const bad = this.findUnescapedMarkdownV2Chars(title);
                        if (bad.length) {
                            const sig = Array.from(new Set(bad.map(b => b.char))).sort().join('');
                            if (sig && !seen.has(sig)) {
                                issues.push({
                                    EpisodeNumber: ep.EpisodeNumber,
                                    title,
                                    badChars: sig
                                });
                                seen.add(sig);
                            }
                        }
                    }
                    try {
                        console.table(issues);
                    } catch (_) {
                        console.log(issues);
                    }
                    return { total: eps.length, issuesCount: issues.length, issues };
                },

                async checkTelegram() {
                    try {
                        if (!window.TelegramGameProxy || typeof window.TelegramGameProxy.receiveEvent !== 'function') {
                            window.TelegramGameProxy = Object.assign({}, window.TelegramGameProxy, { receiveEvent: function () {} });
                        }
                        console.log("=== Telegram WebApp Raw Data ===");
                        console.log("initData:", webApp?.initData);
                        console.log("initDataUnsafe:", webApp?.initDataUnsafe);
                        console.log("version:", webApp?.version);
                        console.log("platform:", webApp?.platform);
                        console.log("===============================");

                        if (webApp?.initDataUnsafe?.user) {
                            const initData = webApp.initDataUnsafe;
                            const user = initData.user;
                            const userId = String(user.id);

                            const userProps = {
                                name: `${user.first_name} ${user.last_name || ''}`.trim(),
                                username: user.username || undefined,
                                telegram_profile: user.username ? `https://t.me/${user.username}` : undefined,
                                language_code: user.language_code || undefined,
                                is_premium: user.is_premium || false,
                                photo_url: user.photo_url || undefined,
                                allows_write_to_pm: user.allows_write_to_pm || undefined,
                                query_id: initData.query_id || undefined,
                                auth_date: initData.auth_date || undefined,
                                signature: initData.signature || undefined,
                                hash: initData.hash || undefined
                            };

                            if (window.LogRocket) {
                                LogRocket.identify(userId, userProps);
                            }

                            if (window.posthog) {
                                posthog.identify(userId, userProps);
                            }

                            if (window.HyperDX) {
                                HyperDX.setGlobalAttributes({
                                    userId,
                                    userName: userProps.name,
                                    username: userProps.username,
                                    telegram_profile: userProps.telegram_profile,
                                    language_code: userProps.language_code,
                                    is_premium: userProps.is_premium,
                                    photo_url: userProps.photo_url,
                                    allows_write_to_pm: userProps.allows_write_to_pm,
                                    query_id: userProps.query_id,
                                    auth_date: userProps.auth_date,
                                    signature: userProps.signature,
                                    hash: userProps.hash
                                });
                            }
                        }

                        const response = await fetch('https://ccuid.mdccxxixix.workers.dev', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ token: webApp?.initDataUnsafe?.user?.id })
                        });
                        const result = await response.json();
                        if (result && (result.error || result.telegramError)) {
                            console.log('Membership check result', result);
                        }

                        const validateUserId = webApp?.initDataUnsafe?.user?.id;

                        const formatDurationArabic = (ms) => {
                            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
                            const days = Math.floor(totalSeconds / 86400);
                            const hours = Math.floor((totalSeconds % 86400) / 3600);
                            const minutes = Math.floor((totalSeconds % 3600) / 60);
                            const seconds = totalSeconds % 60;

                            const parts = [];
                            if (days) parts.push(`${days} ŸäŸàŸÖ`);
                            if (hours) parts.push(`${hours} ÿ≥ÿßÿπÿ©`);
                            if (minutes) parts.push(`${minutes} ÿØŸÇŸäŸÇÿ©`);
                            parts.push(`${seconds} ÿ´ÿßŸÜŸäÿ©`);
                            return parts.join(' Ÿà ');
                        };

                        const formatDateTimeYmdHms = (ms) => {
                            const d = new Date(ms);
                            const pad2 = (n) => String(n).padStart(2, '0');
                            return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())} ${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
                        };

                        if (result?.error) {
                            const desc = String(result?.telegramError?.description || '');
                            const dl = desc.toLowerCase();
                            const allowed =
                                dl.includes('participant_id_invalid') ||
                                dl.includes('member not found') ||
                                dl.includes('user not found') ||
                                dl.includes('user_not_participant');
                            if (!allowed) {
                                throw new Error(result.error);
                            }
                            console.warn('Telegram membership check returned non-member case', result);
                        }

                        if (result?.banned) {
                            this.userJoined = false;

                            const trustedOffsetMs = typeof result?.now === 'number'
                                ? (result.now - Date.now())
                                : (typeof this.serverTimeOffset === 'number' ? this.serverTimeOffset : 0);

                            const banUntilMs = typeof result.banUntil === 'number' ? result.banUntil : 0;
                            const remainingMs = banUntilMs ? Math.max(0, banUntilMs - (Date.now() + trustedOffsetMs)) : 0;
                            const remainingText = formatDurationArabic(remainingMs);
                            const untilText = banUntilMs ? formatDateTimeYmdHms(banUntilMs) : '';

                            document.body.innerHTML = `
                                <div style="position: fixed; inset: 0; display: flex; justify-content: center; align-items: center; background: #23447d; font-family: Tahoma, 'Segoe UI', Geneva, sans-serif; z-index: 99999;">
                                    <div style="text-align: center; padding: 30px 20px; border: 2px solid #fff; border-radius: 15px; background-color: #0f141f; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); max-width: 450px; width: 95%; direction: rtl;">
                                        <h1 style="font-size: 27px; font-weight: bold; color: #ff4f4f; margin-bottom: 20px; display: flex; justify-content: center; gap: 5px;">
                                            <span>üö´</span><span>ÿ™ŸÖ ÿ≠ÿ∏ÿ±ŸÉ ŸÖÿ§ŸÇÿ™Ÿãÿß</span><span>üö´</span>
                                        </h1>

                                        <p style="font-size: 18px; color: #fff; font-weight: bold; margin-bottom: 12px; line-height: 1.6;">
                                            ŸÑŸÇÿØ ŸÇŸÖÿ™ ÿ®ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÇŸÜÿßÿ© 3 ŸÖÿ±ÿßÿ™ ÿÆŸÑÿßŸÑ ÿ£ÿ≥ÿ®Ÿàÿπ.
                                        </p>

                                        <p style="font-size: 17px; color: #ffff00; font-weight: bold; margin-bottom: 10px; line-height: 1.6;">
                                            ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä ŸÑÿ±ŸÅÿπ ÿßŸÑÿ≠ÿ∏ÿ±:
                                            <br>
                                            <span id="banRemaining" style="color: #00ff00;">${remainingText}</span>
                                        </p>

                                        <div style="font-size: 14px; color: #cbd5e1; font-weight: bold;">
                                            (${validateUserId})
                                        </div>
                                    </div>
                                </div>
                            `;

                            if (banUntilMs) {
                                const remainingEl = document.getElementById('banRemaining');
                                if (remainingEl) {
                                    const intervalId = setInterval(() => {
                                        const msLeft = Math.max(0, banUntilMs - (Date.now() + trustedOffsetMs));
                                        remainingEl.textContent = formatDurationArabic(msLeft);
                                        if (msLeft <= 0) {
                                            clearInterval(intervalId);
                                            setTimeout(() => window.location.reload(), 500);
                                        }
                                    }, 1000);
                                }
                            }
                        } else if (result.valid) {
                            this.userJoined = true;
                        } else {
                            this.userJoined = false;

                            document.body.innerHTML = `
                                <div style="position: fixed; inset: 0; display: flex; justify-content: center; align-items: center; background: #23447d; font-family: Tahoma, 'Segoe UI', Geneva, sans-serif; z-index: 99999;">
                                    <div style="text-align: center; padding: 30px 20px; border: 2px solid #fff; border-radius: 15px; background-color: #0f141f; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); max-width: 400px; width: 95%; direction: rtl;">
                                        
                                        <h1 style="font-size: 28px; font-weight: bold; color: #ff4f4f; margin-bottom: 25px; display: flex; justify-content: center; gap: 10px;">
                                            <span>üö´</span><span>ÿßŸÑŸàÿµŸàŸÑ ŸÖŸÇŸäŸëÿØ</span><span>üö´</span>
                                        </h1>

                                        <p style="font-size: 19px; color: #fff; font-weight: bold; margin-bottom: 15px;">
                                            ŸÑÿ≥ÿ™Ÿé ŸÖŸÜÿ∂ŸÖŸãÿß ŸÑŸÇŸÜÿßÿ© ÿßŸÑÿ™ŸäŸÑŸäÿ¨ÿ±ÿßŸÖ.
                                        </p>

                                        <div style="color: #00ff00; font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                                            ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ±ÿßÿ®ÿ∑ ŸÑŸÑÿ∞Ÿáÿßÿ® ŸÑŸÑŸÇŸÜÿßÿ©
                                        </div>

                                        <div style="margin-bottom: 35px;">
                                            <div style="font-size: 22px;">üëá</div>
                                            <a
                                                id="telegramChannelLink"
                                                href="#"
                                                style="display: block; color: #ffff00; font-size: 18px; font-weight: bold; text-decoration: none;"
                                            >
                                                https://t.me/CodeSubs
                                            </a>
                                        </div>

                                        <button
                                            id="retryButton"
                                            class="
                                                w-[80%] px-3 py-3
                                                bg-gradient-to-br from-blue-600 to-blue-800
                                                text-white text-[18px] font-bold
                                                rounded-xl
                                                inline-flex items-center justify-center gap-2
                                                shadow-[0_6px_0_#0c3e82,0_10px_20px_rgba(0,0,0,0.3)]
                                                transition-all duration-150 ease-out
                                                hover:-translate-y-1
                                                hover:shadow-[0_8px_0_#0c3e82,0_14px_25px_rgba(0,0,0,0.35)]
                                                active:translate-y-1
                                                active:shadow-[0_3px_0_#0c3e82,0_6px_10px_rgba(0,0,0,0.25)]
                                                active:scale-[0.98]
                                                active:brightness-90
                                            "
                                        >
                                            <span id="retryText" class="inline-flex items-center gap-2">
                                                <span>üîç</span>
                                                <span>ÿ™ÿ≠ŸÇŸÇ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ</span>
                                                <span>üîç</span>
                                            </span>

                                            <div id="retrySpinner" class="hidden animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                                        </button>

                                    </div>
                                </div>
                            `;

                            const btn = document.getElementById('retryButton');
                            const text = document.getElementById('retryText');
                            const spinner = document.getElementById('retrySpinner');

                            btn.addEventListener('click', () => {
                                text.classList.add('hidden');
                                spinner.classList.remove('hidden');
                                btn.disabled = true;
                                btn.classList.add('opacity-80', 'cursor-not-allowed');

                                setTimeout(() => {
                                    window.location.reload();
                                }, 500);
                            });

                            const tgLink = document.getElementById('telegramChannelLink');

                            tgLink.addEventListener('click', (e) => {
                                e.preventDefault();

                                const username = 'CodeSubs';
                                const url = `https://t.me/${username}`;
                                const deep = `tg://resolve?domain=${username}`;
                                const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);
                                if (isIOS) {
                                    try { window.location.href = deep; } catch (e) {}
                                    setTimeout(() => { window.location.href = url; }, 600);
                                    return;
                                }
                                if (window.Telegram?.WebApp?.openTelegramLink) {
                                    try { Telegram.WebApp.openTelegramLink(url); } catch (e) {}
                                    setTimeout(() => {
                                        try {
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.target = '_blank';
                                            a.rel = 'noopener noreferrer';
                                            document.body.appendChild(a);
                                            a.click();
                                            a.remove();
                                        } catch (e2) {
                                            window.location.href = url;
                                        }
                                    }, 500);
                                    return;
                                }
                                try {
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.target = '_blank';
                                    a.rel = 'noopener noreferrer';
                                    document.body.appendChild(a);
                                    a.click();
                                    a.remove();
                                } catch (e3) {
                                    window.location.href = url;
                                }
                            });
                        }
                    } catch (error) {
                        console.error("Error during validation:", error);
                        this.userJoined = false;

                        document.body.innerHTML = `
                            <div style="display: flex; justify-content: center; align-items: center; height: 100vh; background: linear-gradient(135deg, #ff4f4f, #ff7575); animation: fadeIn 1s;">
                                <div style="text-align: center; padding: 20px; border: 2px solid #fff; border-radius: 15px; background-color: rgba(0, 0, 0, 0.7); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); animation: slideDown 1s;">
                                    <h1 style="color: #fff; font-size: 20px; font-weight: bold; margin-bottom: 10px;">ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÅÿ™ÿ≠ ÿßŸÑÿØŸÑŸäŸÑ.<br><span style="font-size: 16px; color: #ffcccc;">${error && (error.message || error.toString())}</span></h1>
                                    <button id="retryButton" style="padding: 15px 30px; background: linear-gradient(135deg, #007BFF, #0056b3); color: #fff; border: none; border-radius: 5px; cursor: pointer; font-size: 18px; font-weight: bold; transition: transform 0.3s, box-shadow 0.3s;">
                                        ÿ£ÿπÿØ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©
                                    </button>
                                </div>
                            </div>
                        `;
                        document.getElementById('retryButton').addEventListener('click', () => {
                            window.location.reload();
                        });
                    }
                },

                processEpisodeNotes(notes) {
                    if (this.episodeNotesDebug) console.log('processEpisodeNotes called with notes:', notes);
                    
                    // Skip processing for 'ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2'
                    if (notes && notes.includes('ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2')) {
                        if (this.episodeNotesDebug) console.log('Skipping processing for ŸÖÿßÿ¨ŸäŸÉ ŸÉÿßŸäÿ™Ÿà2');
                        return notes;
                    }
                    
                    if (!notes) {
                        if (this.episodeNotesDebug) console.log('No notes provided, returning empty string');
                        return '';
                    }
                    
                    // First, handle 'ÿ®ÿßŸÑŸÅŸäŸÑŸÖ n' and 'ÿßŸÑŸÅŸäŸÑŸÖ n' patterns
                    // Match patterns like: "ÿßŸÑŸÅŸäŸÑŸÖ 1", "ÿ®ÿßŸÑŸÅŸäŸÑŸÖ 1", "ÿßŸÑŸÅŸäŸÑŸÖ1", "ÿ®ÿßŸÑŸÅŸäŸÑŸÖ1", "ÿßŸÑŸÅŸäŸÑŸÖ 1.5", etc.
                    let processed = notes;
                    
                    // Process "ÿ®ÿßŸÑŸÅŸäŸÑŸÖ n" patterns first (more specific, to avoid matching it as "ÿßŸÑŸÅŸäŸÑŸÖ")
                    processed = processed.replace(/(ÿ®ÿßŸÑŸÅŸäŸÑŸÖ)\s*(\d+(?:\.\d+)?)/g, (match, filmWord, number) => {
                        if (this.episodeNotesDebug) console.log('Processing ÿ®ÿßŸÑŸÅŸäŸÑŸÖ pattern:', { match, number });
                        const isDisabled = (this.selectedEpisode?.EpisodeVideosIDs?.some(video => 
                            video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending') || 
                            this.selectedEpisode?.EpisodeMangasIDs?.some(manga => 
                                manga.status === 'success' || manga.status === 'ratelimiting' || manga.status === 'sending'));
                        
                        const disabledAttr = isDisabled ? ' disabled' : '';
                        const disabledClass = isDisabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer active:scale-90';
                        const pointerEvents = isDisabled ? 'none' : 'auto';
                        const html = '<span data-episode-type="film" data-episode-number="' + number + '"' + disabledAttr + ' class="episode-link text-lg font-bold underline text-yellow-300 bg-transparent border-0 ' + disabledClass + ' transition-all duration-100" style="pointer-events: ' + pointerEvents + '">' + match + '</span>';
                        if (this.episodeNotesDebug) console.log('Generated ÿ®ÿßŸÑŸÅŸäŸÑŸÖ link HTML:', html);
                        return html;
                    });
                    
                    // Then process "ÿßŸÑŸÅŸäŸÑŸÖ n" patterns (Safari-compatible: check context manually)
                    processed = processed.replace(/(ÿßŸÑŸÅŸäŸÑŸÖ)\s*(\d+(?:\.\d+)?)/g, (match, filmWord, number, offset, string) => {
                        // Safari-compatible check: make sure it's not "ÿ®ÿßŸÑŸÅŸäŸÑŸÖ" (already processed)
                        const beforeMatch = string.substring(Math.max(0, offset - 5), offset);
                        if (beforeMatch.endsWith('ÿ®')) {
                            return match; // This is part of "ÿ®ÿßŸÑŸÅŸäŸÑŸÖ" which was already processed, skip
                        }
                        
                        if (this.episodeNotesDebug) console.log('Processing ÿßŸÑŸÅŸäŸÑŸÖ pattern:', { match, number });
                        const isDisabled = (this.selectedEpisode?.EpisodeVideosIDs?.some(video => 
                            video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending') || 
                            this.selectedEpisode?.EpisodeMangasIDs?.some(manga => 
                                manga.status === 'success' || manga.status === 'ratelimiting' || manga.status === 'sending'));
                        
                        const disabledAttr = isDisabled ? ' disabled' : '';
                        const disabledClass = isDisabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer active:scale-90';
                        const pointerEvents = isDisabled ? 'none' : 'auto';
                        const html = '<span data-episode-type="film" data-episode-number="' + number + '"' + disabledAttr + ' class="episode-link text-lg font-bold underline text-yellow-300 bg-transparent border-0 ' + disabledClass + ' transition-all duration-100" style="pointer-events: ' + pointerEvents + '">' + match + '</span>';
                        if (this.episodeNotesDebug) console.log('Generated ÿßŸÑŸÅŸäŸÑŸÖ link HTML:', html);
                        return html;
                    });
                    
                    // Then handle standalone numbers that weren't part of 'ÿßŸÑŸÅŸäŸÑŸÖ n' or 'ÿ®ÿßŸÑŸÅŸäŸÑŸÖ n'
                    // Using a Safari-compatible approach without variable-length lookbehinds
                    processed = processed.replace(/(\d+(?:\.\d+)?)/g, (match, number, offset, string) => {
                        // Check if this number is inside an HTML tag (already processed)
                        // Simple and reliable: if there's a < before us with no > between it and us, we're inside a tag
                        const textBefore = string.substring(0, offset);
                        const lastOpenTag = textBefore.lastIndexOf('<');
                        const lastCloseTag = textBefore.lastIndexOf('>');
                        
                        // If last < is after last >, we might be inside a tag
                        if (lastOpenTag > lastCloseTag) {
                            // Check if the tag closes after our position
                            const tagEnd = string.indexOf('>', lastOpenTag);
                            if (tagEnd > offset) {
                                return match; // Inside a tag, skip
                            }
                        }
                        
                        // Skip if part of "ÿßŸÑŸÅŸäŸÑŸÖ n" or "ÿ®ÿßŸÑŸÅŸäŸÑŸÖ n" (already processed)
                        const beforeContext = string.substring(Math.max(0, offset - 30), offset);
                        if (/ÿßŸÑŸÅŸäŸÑŸÖ\s*\d*$/.test(beforeContext) || /ÿ®\s*ÿßŸÑŸÅŸäŸÑŸÖ\s*\d*$/.test(beforeContext) || /ÿ®ÿßŸÑŸÅŸäŸÑŸÖ\s*\d*$/.test(beforeContext)) {
                            return match; // Already processed
                        }
                        
                        // Skip if part of a larger alphanumeric string (but allow punctuation after numbers)
                        const charBefore = offset > 0 ? string[offset - 1] : ' ';
                        const charAfter = offset + match.length < string.length ? string[offset + match.length] : ' ';
                        
                        // Define punctuation and spaces (these are allowed around numbers)
                        const punctuationOrSpace = /[\sÿå.\-:;!?ÿå„ÄÇ„ÄÅ\u060C\u061B\u061F\u0640\u200C\u200D]/;
                        
                        // Word characters (letters, digits, underscore) - but exclude punctuation
                        const wordCharRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFFa-zA-Z0-9_]/;
                        
                        // Skip if character before is a word character (and not punctuation/space)
                        if (!punctuationOrSpace.test(charBefore) && wordCharRegex.test(charBefore)) {
                            return match; // Part of larger alphanumeric
                        }
                        
                        // Skip if character after is a word character (and not punctuation/space)
                        // This allows numbers followed by punctuation like "1160ÿå"
                        if (!punctuationOrSpace.test(charAfter) && wordCharRegex.test(charAfter)) {
                            return match; // Part of larger alphanumeric
                        }
                        
                        if (this.episodeNotesDebug) console.log('Processing standalone number:', match);
                        const isDisabled = (this.selectedEpisode?.EpisodeVideosIDs?.some(video => 
                            video.status === 'success' || video.status === 'ratelimiting' || video.status === 'sending') || 
                            this.selectedEpisode?.EpisodeMangasIDs?.some(manga => 
                                manga.status === 'success' || manga.status === 'ratelimiting' || manga.status === 'sending'));
                        
                        if (this.episodeNotesDebug) console.log('Generated number link:', { number: match, isDisabled });
                        const disabledAttr = isDisabled ? ' disabled' : '';
                        const disabledClass = isDisabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer active:scale-90';
                        const pointerEvents = isDisabled ? 'none' : 'auto';
                        return '<span data-episode-type="number" data-episode-number="' + match + '"' + disabledAttr + ' class="episode-link text-lg font-bold underline text-yellow-300 bg-transparent border-0 ' + disabledClass + ' transition-all duration-100" style="pointer-events: ' + pointerEvents + '">' + match + '</span>';
                    });
                    
                    // Add event delegation in the next tick after the DOM is updated
                    this.$nextTick(() => {
                        if (this.episodeNotesDebug) console.log('Setting up event delegation for episode links');
                        
                        // Clean up any existing event listeners
                        if (this.episodeLinkClickHandler) {
                            document.removeEventListener('click', this.episodeLinkClickHandler);
                        }
                        
                        // Create new handler
                        this.episodeLinkClickHandler = (e) => {
                            // Only handle clicks on episode links
                            const link = e.target.closest('.episode-link:not([disabled])');
                            if (!link) return;
                            
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const type = link.dataset.episodeType;
                            const number = link.dataset.episodeNumber;
                            if (this.episodeNotesDebug) {
                                if (this.episodeNotesDebug) console.log('Episode link clicked:', { type, number });
                                if (this.episodeNotesDebug) console.log('Calling resetStatusForEpisodeManga and openEpisodeModal with:', 
                                    type === 'film' ? `ÿßŸÑŸÅŸäŸÑŸÖ ${number}` : number);
                            }
                            
                            const episodeNumber = type === 'film' ? `ÿßŸÑŸÅŸäŸÑŸÖ ${number}` : number;
                            if (this.episodeNotesDebug) console.log('Episode link clicked:', { type, number });
                            
                            this.resetStatusForEpisodeManga();
                            this.openEpisodeModal(episodeNumber);
                        };
                        
                        // Attach the event listener to the document
                        document.addEventListener('click', this.episodeLinkClickHandler);
                        if (this.episodeNotesDebug) console.log('Event listener added to document');
                    });
                    
                    return processed;
                },

                openEpisodeModal(episodeNumber) {
                    if (this.guardIfCapturing()) return;
                    if (!this.episodes || this.episodes.length === 0) {
                        console.log('Episodes data is not loaded yet in openEpisodeModal!'); // Keeping this one, as it's a potential error case
                        return;
                    }

                    const episodeNumberString = String(episodeNumber); // Convert episodeNumber to string
                    const episode = this.episodes.find(ep => ep.EpisodeNumber === episodeNumberString);

                    if (episode) {
                        this.openModal(episode);
                    } else {
                        console.log("Episode not found in episodes array in openEpisodeModal!"); // Keeping this one for error case
                    }
                },

                formatFileSize(size, arabic = false) {
                    const numericSize = parseFloat(size);

                    if (isNaN(numericSize)) {
                        return size;
                    }

                    if (numericSize >= 1000) {
                        const gbSize = numericSize / 1000;
                        const formattedSize = Number.isInteger(gbSize) ? gbSize : gbSize.toFixed(2);
                        return arabic ? `${formattedSize} ÿ¨Ÿäÿ¨ÿß` : `${formattedSize} GB`;
                    }

                    const formattedSize = Number.isInteger(numericSize) ? numericSize : numericSize.toFixed(2);
                    return arabic ? `${formattedSize} ŸÖŸäÿ¨ÿß` : `${formattedSize} MB`;
                },

                toggleMenu() {
                    if (this.guardIfCapturing()) return;
                    this.menuOpen = !this.menuOpen;
                    if (this.menuOpen) {
                        this.comntoVisible = false;
                    }
                    // Close search popup when menu is opened
                    if (this.menuOpen && this.searchOpen) {
                        this.searchOpen = false;
                        document.removeEventListener("click", this.closeSearchOutside);
                    }
                },

                closeMenu(event) {
                    // Check if the click is outside the menu
                    if (!event.target.closest(".menu-container")) {
                        this.menuOpen = false;
                    }
                },

                showSuccessHint(message) {
                    const msg = String(message ?? '').trim();
                    if (!msg) return;

                    if (this.successHintCountdownIntervalId) {
                        clearInterval(this.successHintCountdownIntervalId);
                        this.successHintCountdownIntervalId = null;
                    }
                    if (this.successHintHideTimeoutId) {
                        clearTimeout(this.successHintHideTimeoutId);
                        this.successHintHideTimeoutId = null;
                    }
                    if (this.successHintHideAnimationTimeoutId) {
                        clearTimeout(this.successHintHideAnimationTimeoutId);
                        this.successHintHideAnimationTimeoutId = null;
                    }

                    this.successHintMessage = msg;
                    this.successHintVisible = true;
                    this.successHintAnimatingOut = false;
                    this.successHintCountdown = 2;

                    this.successHintCountdownIntervalId = setInterval(() => {
                        if (!this.successHintVisible) return;
                        this.successHintCountdown = Math.max(0, Number(this.successHintCountdown || 0) - 1);
                    }, 1000);

                    this.successHintHideTimeoutId = setTimeout(() => {
                        this.dismissSuccessHint();
                    }, 3000);
                },

                dismissSuccessHint() {
                    if (this.successHintCountdownIntervalId) {
                        clearInterval(this.successHintCountdownIntervalId);
                        this.successHintCountdownIntervalId = null;
                    }
                    if (this.successHintHideTimeoutId) {
                        clearTimeout(this.successHintHideTimeoutId);
                        this.successHintHideTimeoutId = null;
                    }
                    if (this.successHintHideAnimationTimeoutId) {
                        clearTimeout(this.successHintHideAnimationTimeoutId);
                        this.successHintHideAnimationTimeoutId = null;
                    }

                    if (!this.successHintVisible) return;
                    this.successHintAnimatingOut = true;
                    this.successHintHideAnimationTimeoutId = setTimeout(() => {
                        this.successHintVisible = false;
                        this.successHintAnimatingOut = false;
                        this.successHintMessage = '';
                        this.successHintCountdown = 0;
                        this.successHintHideAnimationTimeoutId = null;
                    }, 240);
                },

                openDirectWindow(category) {
                    document.body.style.overflow = 'hidden'; // Block background scrolling
                    this.selectedCategory = category;
                    this.showDirectWindow = true;
                    this.menuOpen = false;
                    this.comntoVisible = false;
                },

                openFastingWindow(category) {
                    document.body.style.overflow = 'hidden';
                    this.selectedCategory = category;
                    this.showFastingWindow = true;
                    this.menuOpen = false;
                    this.comntoVisible = false;
                },

                closeFastingWindow() {
                    this.dismissSuccessHint();
                    if (!this.isMangaQueueRunning) {
                        this.stopMangaQueue();
                        document.body.style.overflow = '';
                        this.showFastingWindow = false;
                        this.mangaStartNumber = null;
                        this.mangaEndNumber = null;
                    }
                },

                formatTime(seconds) {
                    if (!seconds || seconds < 0) return '00:00';
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                },

                copyText(text) {
                    try {
                        const value = String(text ?? '');
                        if (!value) return;
                        if (navigator?.clipboard?.writeText) {
                            navigator.clipboard.writeText(value);
                            return;
                        }
                        // Fallback
                        const textarea = document.createElement('textarea');
                        textarea.value = value;
                        textarea.style.position = 'fixed';
                        textarea.style.left = '-9999px';
                        document.body.appendChild(textarea);
                        textarea.focus();
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                    } catch (e) {
                        // best-effort copy
                    }
                },

                buildMangaCaption(chapter, fileSize) {
                    const sizeText = (fileSize !== undefined && fileSize !== null)
                        ? this.escapeMarkdown(this.formatFileSize(fileSize, true))
                        : '';
                    const ch = this.escapeMarkdown(chapter);
                    return sizeText
                        ? `*ÿßŸÑŸÅÿµŸÑ: ${ch}\nÿßŸÑÿ≠ÿ¨ŸÖ: ${sizeText}*`
                        : `*ÿßŸÑŸÅÿµŸÑ: ${ch}*`;
                },

                recordMangaSuccess(manga) {
                    const chapter = String(manga?.MangaNumber ?? '');
                    if (!chapter) return;
                    const fileId = manga?.MangaFileID;

                    // Mark failed row as success (if exists)
                    const failedEntry = this.mangaFailedLog.find(e => e.chapter === chapter);
                    if (failedEntry) {
                        failedEntry.status = 'success';
                        failedEntry.error = '';
                    }

                    // Add to sent log (unique by chapter)
                    const existing = this.mangaSentLog.find(e => e.chapter === chapter);
                    if (!existing) {
                        this.mangaSentLog.push({ chapter, fileId, sentAt: Date.now() });
                    }
                },

                recordMangaFailure(manga, error) {
                    const chapter = String(manga?.MangaNumber ?? '');
                    if (!chapter) return;
                    const fileId = manga?.MangaFileID;
                    const fileSize = manga?.MangaFileSize;
                    const message = String(error?.message ?? error ?? 'Unknown error');

                    const existing = this.mangaFailedLog.find(e => e.chapter === chapter);
                    if (existing) {
                        existing.error = message; // overwrite error
                        existing.fileId = fileId ?? existing.fileId;
                        existing.fileSize = fileSize ?? existing.fileSize;
                        existing.status = 'failed';
                        existing.attempts = (existing.attempts || 1) + 1;
                    } else {
                        this.mangaFailedLog.push({
                            chapter,
                            fileId,
                            fileSize,
                            error: message,
                            status: 'failed',
                            attempts: 1,
                        });
                    }
                },

                closeMangaFailedLogModal() {
                    if (this.checkAnyRetryRunning()) {
                        this.showRetryStopConfirmation = true;
                    } else {
                        // Remove successful rows from failed log before closing
                        this.mangaFailedLog = this.mangaFailedLog.filter(e => e.status !== 'success');
                        this.failedMangaQueue = [];
                        this.failedQueueStats = {
                            total: 0,
                            sent: 0,
                            failed: 0,
                            waiting: 0,
                            elapsedTime: 0,
                            remainingTime: 0
                        };
                        this.retryQueueCurrent = { chapter: null, status: null, error: null };
                        this.showMangaFailedLogModal = false;
                    }
                },

                async retryFailedManga(entry) {
                    if (!entry || entry.status === 'success' || entry.status === 'retrying') return;
                    entry.status = 'retrying';
                    
                    // Update Current Status
                    this.retryQueueCurrent = {
                        chapter: entry.chapter,
                        status: 'sending',
                        error: null
                    };
                    
                    try {
                        // Check daily limit before attempting resend
                        const canDownload = await this.checkDailyLimit();
                        if (!canDownload) {
                            entry.status = 'failed';
                            entry.error = `ŸÑŸÇÿØ ŸàÿµŸÑÿ™ ŸÑŸÑÿ≠ÿØ ÿßŸÑŸäŸàŸÖŸä (${this.maxDailyDownloads}). ÿßŸÑŸÖÿ™ÿ®ŸÇŸä: ${this.remainingDownloads}.`;
                            this.retryQueueCurrent.status = 'failed';
                            this.retryQueueCurrent.error = entry.error;
                            this.showLimitModal = true;
                            return;
                        }
                        
                        await this.sendTelegramMedia({
                            method: "sendDocument",
                            file_id: entry.fileId,
                            caption: this.buildMangaCaption(entry.chapter, entry.fileSize)
                        });
                        // Increment daily limit only on success
                        await this.incrementDailyLimit();
                        
                        entry.status = 'success';
                        entry.error = '';
                        this.retryQueueCurrent.status = 'success';
                        this.showSuccessHint('ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅÿµŸÑ ŸÑŸÑÿÆÿßÿµ');
                        
                        // Move this chapter from failed ‚Üí sent in the aggregate stats (MAIN stats)
                        if (this.mangaQueueStats.failed > 0) {
                            this.mangaQueueStats.failed -= 1;
                        }
                        this.mangaQueueStats.sent += 1;
                        
                        // also record as success
                        this.recordMangaSuccess({ MangaNumber: entry.chapter, MangaFileID: entry.fileId });
                    } catch (error) {
                        entry.status = 'failed';
                        entry.error = String(error?.message ?? error ?? 'Unknown error'); // overwrite
                        this.retryQueueCurrent.status = 'failed';
                        this.retryQueueCurrent.error = entry.error;
                    }
                },

                async retryAllFailedMangas() {
                    // Block API request if this tab is not the owner
                    if (!this.isTabOwner) {
                        console.warn('retryAllFailedMangas blocked: Tab is not the owner');
                        return;
                    }
                    
                    // Prevent starting if main queue is running
                    if (this.isMangaQueueRunning && !this.isMangaQueuePaused) return;
                    if (this.isRetryAllFailedRunning) return;
                    const retryables = this.mangaFailedLog.filter(e => e.status !== 'success');
                    if (!retryables.length) return;

                    this.isRetryAllFailedRunning = true;
                    this.retryAllFailedProgress = { done: 0, total: retryables.length };
                    try {
                        for (const entry of retryables) {
                            if (!this.isRetryAllFailedRunning) break; // Check stop flag
                            
                            await this.retryFailedManga(entry);
                            this.retryAllFailedProgress.done += 1;
                            
                            if (!this.isRetryAllFailedRunning) break; // Check stop flag
                            
                            // delay between retries (queue-style)
                            await new Promise(resolve => setTimeout(resolve, this.fastingStatusClearTimeout));
                        }
                    } finally {
                        this.isRetryAllFailedRunning = false;
                        this.retryQueueCurrent = { chapter: null, status: null, error: null };
                    }
                },

                // --- Retry Queue & Enhanced Logic ---

                toggleFailedQueue(entry) {
                    const index = this.failedMangaQueue.findIndex(e => e.chapter === entry.chapter);
                    if (index === -1) {
                        this.failedMangaQueue.push(entry);
                    } else {
                        this.failedMangaQueue.splice(index, 1);
                    }
                },

                getQueueRank(entry) {
                    const index = this.failedMangaQueue.findIndex(e => e.chapter === entry.chapter);
                    return index > -1 ? index + 1 : 0;
                },

                toggleRetryQueuePause() {
                    if (this.isRetryQueuePaused) {
                        this.isRetryQueuePaused = false;
                        this.isRetryQueuePauseRequested = false;
                    } else {
                        this.isRetryQueuePauseRequested = true;
                    }
                },

                cancelRetryQueue() {
                    this.isRetryQueueRunning = false;
                    this.isRetryQueuePaused = false;
                    this.isRetryQueuePauseRequested = false;
                    this.failedMangaQueue = []; // Clear queue as requested
                    this.retryQueueCurrent = { chapter: null, status: null, error: null };
                },
                
                async startFailedQueue() {
                    if (this.isRetryQueueRunning || this.isRetryAllFailedRunning) return;
                    // If main queue is running and NOT paused, we cannot start.
                    // BUT if it IS paused, we CAN start.
                    if (this.isMangaQueueRunning && !this.isMangaQueuePaused) return;

                    if (this.failedMangaQueue.length === 0) {
                         alert('ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ŸÅÿßÿ±ÿ∫ÿ©');
                         return;
                    }

                    // Check daily limit
                    if (this.failedMangaQueue.length > this.remainingDownloads) {
                        this.showLimitModal = true;
                        return;
                    }

                    this.isRetryQueueRunning = true;
                    this.isRetryQueuePaused = false;
                    this.isRetryQueuePauseRequested = false;
                    
                    // Reset stats for this run
                    this.failedQueueStats = {
                        total: this.failedMangaQueue.length,
                        sent: 0,
                        failed: 0,
                        waiting: this.failedMangaQueue.length,
                        elapsedTime: 0,
                        remainingTime: this.failedMangaQueue.length * (this.fastingStatusClearTimeout / 1000)
                    };
                    
                    this.processFailedQueue();
                },

                async processFailedQueue() {
                     let i = 0;
                     while (i < this.failedMangaQueue.length && this.isRetryQueueRunning) {
                         // Check Pause
                         if (this.isRetryQueuePauseRequested) {
                             this.isRetryQueuePaused = true;
                             this.isRetryQueuePauseRequested = false;
                         }
                         
                         if (this.isRetryQueuePaused) {
                             await new Promise(r => setTimeout(r, 100));
                             continue; // Retry loop to check pause again
                         }

                         const entry = this.failedMangaQueue[i];
                         
                         // Check daily limit again
                         const canDownload = await this.checkDailyLimit();
                         if (!canDownload) {
                             this.showLimitModal = true;
                             this.isRetryQueueRunning = false;
                             break;
                         }

                         try {
                             entry.status = 'retrying';
                             this.retryQueueCurrent = {
                                 chapter: entry.chapter,
                                 status: 'sending',
                                 error: null
                             };

                             const caption = this.buildMangaCaption(entry.chapter, entry.fileSize);
                             await this.sendTelegramMedia({
                                 method: "sendDocument",
                                 file_id: entry.fileId,
                                 caption: caption
                             });
                             
                             await this.incrementDailyLimit();
                             this.recordMangaSuccess({ MangaNumber: entry.chapter });
                             
                             this.failedQueueStats.sent++;
                             // Update main stats too
                             if (this.mangaQueueStats.failed > 0) this.mangaQueueStats.failed--;
                             this.mangaQueueStats.sent++;
                            
                             entry.status = 'success';
                             this.retryQueueCurrent.status = 'success';
                             this.showSuccessHint('ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅÿµŸÑ ŸÑŸÑÿÆÿßÿµ');
                         } catch (error) {
                             console.error(error);
                             entry.status = 'failed';
                             entry.error = String(error);
                             
                             this.failedQueueStats.failed++;
                             this.retryQueueCurrent.status = 'failed';
                             this.retryQueueCurrent.error = entry.error;
                         }
                         
                         i++;
                         this.failedQueueStats.waiting = this.failedMangaQueue.length - i;
                         
                         // Delay
                         if (i < this.failedMangaQueue.length && this.isRetryQueueRunning) {
                             await new Promise(r => setTimeout(r, this.fastingStatusClearTimeout));
                         }
                     }
                     
                     this.isRetryQueueRunning = false;
                     this.retryQueueCurrent = { chapter: null, status: null, error: null };
                },
                
                checkAnyRetryRunning() {
                    return this.isRetryAllFailedRunning || this.isRetryQueueRunning || this.mangaFailedLog.some(e => e.status === 'retrying');
                },

                confirmStopAndCloseFailedModal() {
                    this.isRetryAllFailedRunning = false;
                    this.isRetryQueueRunning = false;
                    this.isRetryQueuePaused = false;
                    this.isRetryQueuePauseRequested = false;
                    this.failedMangaQueue = [];
                    this.failedQueueStats = {
                        total: 0,
                        sent: 0,
                        failed: 0,
                        waiting: 0,
                        elapsedTime: 0,
                        remainingTime: 0
                    };
                    this.retryQueueCurrent = { chapter: null, status: null, error: null };
                    this.showRetryStopConfirmation = false;
                    this.showMangaFailedLogModal = false;
                },

                // Modified retryFailedManga to check concurrency
                async retryFailedMangaWrapped(entry) {
                    if (this.isRetryAllFailedRunning || this.isRetryQueueRunning) return;
                    if (this.isMangaQueueRunning && !this.isMangaQueuePaused) return;
                    
                    await this.retryFailedManga(entry);
                },

                handleMangaNumberFocus(field) {
                    // When focusing on empty field, set to min value
                    if (this[field] === null || this[field] === undefined || this[field] === '') {
                        this.$nextTick(() => {
                            this[field] = this.minMangaNumber;
                        });
                    }
                },

                normalizeNumericString(value) {
                    if (value === null || value === undefined) return '';
                    const str = String(value);
                    const map = {
                        'Ÿ†': '0', 'Ÿ°': '1', 'Ÿ¢': '2', 'Ÿ£': '3', 'Ÿ§': '4',
                        'Ÿ•': '5', 'Ÿ¶': '6', 'Ÿß': '7', 'Ÿ®': '8', 'Ÿ©': '9',
                        '€∞': '0', '€±': '1', '€≤': '2', '€≥': '3', '€¥': '4',
                        '€µ': '5', '€∂': '6', '€∑': '7', '€∏': '8', '€π': '9'
                    };
                    let out = '';
                    for (let i = 0; i < str.length; i++) {
                        const ch = str[i];
                        out += map[ch] ?? ch;
                    }
                    return out;
                },

                handleMangaNumberInput(event, field) {
                    const rawValue = event?.target?.value ?? '';
                    const normalized = this.normalizeNumericString(rawValue).trim();

                    if (normalized === '') {
                        this[field] = null;
                        return;
                    }

                    const parsed = parseFloat(normalized);
                    if (isNaN(parsed)) {
                        this[field] = null;
                        return;
                    }

                    const clamped = Math.min(Math.max(parsed, this.minMangaNumber), this.maxMangaNumber);
                    this[field] = Math.round(clamped);
                },

                startMangaQueue() {
                    // Block API request if this tab is not the owner
                    if (!this.isTabOwner) {
                        console.warn('startMangaQueue blocked: Tab is not the owner');
                        this.tabLockModal = true;
                        return;
                    }
                    
                    // Prevent starting if retry queue is running
                    if (this.isRetryAllFailedRunning) {
                        return;
                    }
                    if (this.mangaStartNumber === null || this.mangaStartNumber === undefined || 
                        this.mangaEndNumber === null || this.mangaEndNumber === undefined || 
                        this.mangaStartNumber > this.mangaEndNumber) {
                        return;
                    }

                    // Get all mangas
                    const allMangas = this.groupedMangas.flatMap(group => group.items);
                    
                    // Filter mangas in range (handles "0" as valid manga number)
                    this.mangaQueue = allMangas.filter(manga => {
                        const num = parseFloat(manga.MangaNumber);
                        return !isNaN(num) && num >= this.mangaStartNumber && num <= this.mangaEndNumber;
                    }).sort((a, b) => parseFloat(a.MangaNumber) - parseFloat(b.MangaNumber));

                    if (this.mangaQueue.length === 0) {
                        alert('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿßŸÜÿ∫ÿß ŸÅŸä ÿßŸÑŸÜÿ∑ÿßŸÇ ÿßŸÑŸÖÿ≠ÿØÿØ');
                        return;
                    }

                    // Check daily limit
                    if (this.mangaQueue.length > this.remainingDownloads) {
                        this.showLimitModal = true;
                        return;
                    }

                    // Initialize queue
                    this.mangaQueueIndex = 0;
                    this.isMangaQueueRunning = true;
                    this.isMangaQueuePaused = false;
                    this.isMangaQueueSending = false;
                    this.isMangaQueuePauseRequested = false;
                    this.mangaQueueStartTime = Date.now();
                    this.mangaQueuePausedTime = 0;
                    this.mangaQueueTotalPausedTime = 0;
                    this.mangaQueueStats = {
                        total: this.mangaQueue.length,
                        sent: 0,
                        failed: 0,
                        waiting: this.mangaQueue.length,
                        elapsedTime: 0,
                        remainingTime: this.mangaQueue.length * (this.fastingStatusClearTimeout / 1000)
                    };

                    // Clear any existing process
                    if (this.mangaQueueTimeoutId !== null) {
                        clearTimeout(this.mangaQueueTimeoutId);
                        this.mangaQueueTimeoutId = null;
                    }
                    this.mangaQueueProcessId = null;

                    // Start timer
                    this.mangaQueueInterval = setInterval(() => {
                        if (this.isMangaQueueRunning && !this.isMangaQueuePaused) {
                            const now = Date.now();
                            const elapsed = Math.floor((now - this.mangaQueueStartTime - this.mangaQueueTotalPausedTime) / 1000);
                            // Calculate remaining time based on actual remaining items
                            const remainingItems = this.mangaQueueStats.waiting;
                            const estimatedTimePerItem = this.fastingStatusClearTimeout / 1000;
                            // If no items waiting, remaining time should be 0
                            const remaining = remainingItems > 0 ? Math.max(0, remainingItems * estimatedTimePerItem) : 0;
                            this.mangaQueueStats.elapsedTime = elapsed;
                            this.mangaQueueStats.remainingTime = remaining;
                        } else if (!this.isMangaQueueRunning && this.mangaQueueStats.total > 0) {
                            // When finished, ensure remaining time is 0
                            if (this.mangaQueueStats.waiting === 0) {
                                this.mangaQueueStats.remainingTime = 0;
                            }
                        }
                    }, 1000);

                    // Start processing
                    this.processMangaQueue();
                },

                async processMangaQueue() {
                    // Generate unique process ID to prevent duplicate processing
                    const currentProcessId = Date.now() + Math.random();
                    this.mangaQueueProcessId = currentProcessId;

                    const processNext = async (processId) => {
                        // Verify this is still the active process
                        if (this.mangaQueueProcessId !== processId) {
                            return; // Another process has started, exit
                        }

                        // Check if we should continue
                        if (!this.isMangaQueueRunning || this.mangaQueueIndex >= this.mangaQueue.length) {
                            if (this.mangaQueueIndex >= this.mangaQueue.length) {
                                this.finishMangaQueue();
                            }
                            return;
                        }

                        // Check if pause was requested - wait for current send to complete
                        if (this.isMangaQueuePauseRequested && !this.isMangaQueueSending) {
                            this.isMangaQueuePaused = true;
                            this.isMangaQueuePauseRequested = false;
                            this.mangaQueuePausedTime = Date.now(); // Record when pause started
                            this.mangaQueueTimeoutId = setTimeout(() => processNext(processId), 100);
                            return;
                        }

                        // Wait if paused (but not if pause is just being requested)
                        if (this.isMangaQueuePaused && !this.isMangaQueuePauseRequested) {
                            this.mangaQueueTimeoutId = setTimeout(() => processNext(processId), 100);
                            return;
                        }

                        // Mark as sending
                        this.isMangaQueueSending = true;
                        const currentIndex = this.mangaQueueIndex;
                        const manga = this.mangaQueue[currentIndex];
                        // Show only the current chapter status
                        this.mangaQueueCurrent.chapter = manga?.MangaNumber ?? null;
                        this.mangaQueueCurrent.status = 'sending';
                        this.mangaQueueCurrent.error = null;
                        
                        // Update waiting count before sending
                        this.mangaQueueStats.waiting = this.mangaQueue.length - currentIndex - 1;

                        try {
                            // Check daily limit before sending
                            const canDownload = await this.checkDailyLimit();
                            if (!canDownload) {
                                throw new Error(`Daily download limit of ${this.maxDailyDownloads} reached.`);
                            }

                            await this.sendTelegramMedia({
                                method: "sendDocument",
                                file_id: manga.MangaFileID,
                                caption: this.buildMangaCaption(manga.MangaNumber, manga.MangaFileSize)
                            });
                            // Only increment if we're still on the same index (prevent duplicates)
                            if (this.mangaQueueIndex === currentIndex) {
                                // Increment daily limit on success
                                await this.incrementDailyLimit();

                                this.mangaQueueCurrent.status = 'success';
                                this.showSuccessHint('ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅÿµŸÑ ŸÑŸÑÿÆÿßÿµ');
                                this.recordMangaSuccess(manga);
                                this.mangaQueueStats.sent++;
                                this.mangaQueueIndex++;
                                // Update waiting count after increment
                                this.mangaQueueStats.waiting = this.mangaQueue.length - this.mangaQueueIndex;
                                // If no more items, set remaining time to 0 immediately
                                if (this.mangaQueueStats.waiting === 0) {
                                    this.mangaQueueStats.remainingTime = 0;
                                }
                            }
                        } catch (error) {
                            // console.error(error);
                            // Only increment if we're still on the same index
                            if (this.mangaQueueIndex === currentIndex) {
                                this.mangaQueueCurrent.status = 'failed';
                                this.mangaQueueCurrent.error = String(error?.message ?? error ?? 'Unknown error');
                                this.recordMangaFailure(manga, error);
                                this.mangaQueueStats.failed++;
                                this.mangaQueueIndex++;
                                // Update waiting count after increment
                                this.mangaQueueStats.waiting = this.mangaQueue.length - this.mangaQueueIndex;
                                // If no more items, set remaining time to 0 immediately
                                if (this.mangaQueueStats.waiting === 0) {
                                    this.mangaQueueStats.remainingTime = 0;
                                }
                            }
                        }

                        // Mark as not sending
                        this.isMangaQueueSending = false;

                        // Check if pause was requested during send
                        if (this.isMangaQueuePauseRequested) {
                            this.isMangaQueuePaused = true;
                            this.isMangaQueuePauseRequested = false;
                            this.mangaQueuePausedTime = Date.now(); // Record when pause started
                            return;
                        }

                        // Wait before next send
                        if (this.isMangaQueueRunning && this.mangaQueueIndex < this.mangaQueue.length) {
                            this.mangaQueueTimeoutId = setTimeout(() => processNext(processId), this.fastingStatusClearTimeout);
                        } else if (this.mangaQueueIndex >= this.mangaQueue.length) {
                            this.finishMangaQueue();
                        }
                    };

                    processNext(currentProcessId);
                },

                toggleMangaQueuePause() {
                    if (this.isMangaQueuePaused) {
                        // Resume - calculate paused time and add to total
                        if (this.mangaQueuePausedTime > 0) {
                            const pausedDuration = Date.now() - this.mangaQueuePausedTime;
                            this.mangaQueueTotalPausedTime += pausedDuration;
                            this.mangaQueuePausedTime = 0;
                        }
                        this.isMangaQueuePaused = false;
                        this.isMangaQueuePauseRequested = false;
                    } else {
                        // Request pause - will wait for current send to complete
                        this.isMangaQueuePauseRequested = true;
                    }
                },

                stopMangaQueue() {
                    this.isMangaQueueRunning = false;
                    this.isMangaQueuePaused = false;
                    this.isMangaQueueSending = false;
                    this.isMangaQueuePauseRequested = false;
                    this.showStopConfirmation = false;
                    if (this.mangaQueueInterval) {
                        clearInterval(this.mangaQueueInterval);
                        this.mangaQueueInterval = null;
                    }
                    if (this.mangaQueueTimeoutId !== null) {
                        clearTimeout(this.mangaQueueTimeoutId);
                        this.mangaQueueTimeoutId = null;
                    }
                    this.mangaQueueProcessId = null;
                    this.mangaQueue = [];
                    this.mangaQueueIndex = 0;
                    this.mangaQueueStats = {
                        total: 0,
                        sent: 0,
                        failed: 0,
                        waiting: 0,
                        elapsedTime: 0,
                        remainingTime: 0
                    };
                    this.mangaQueueStartTime = null;
                    this.mangaQueuePausedTime = 0;
                    this.mangaQueueTotalPausedTime = 0;
                    // Clear UI/log state
                    this.mangaQueueCurrent = { chapter: null, status: null, error: null };
                    this.mangaSentLog = [];
                    this.mangaFailedLog = [];
                    this.showMangaSentLogModal = false;
                    this.showMangaFailedLogModal = false;
                    this.isRetryAllFailedRunning = false;
                    this.retryAllFailedProgress = { done: 0, total: 0 };
                    // document.body.style.overflow = '';
                },

                finishMangaQueue() {
                    // Called when queue finishes naturally - don't reset stats
                    this.isMangaQueueRunning = false;
                    this.isMangaQueuePaused = false;
                    this.isMangaQueueSending = false;
                    this.isMangaQueuePauseRequested = false;
                    // Ensure waiting is 0 and remaining time is 0
                    this.mangaQueueStats.waiting = 0;
                    this.mangaQueueStats.remainingTime = 0;
                    if (this.mangaQueueInterval) {
                        clearInterval(this.mangaQueueInterval);
                        this.mangaQueueInterval = null;
                    }
                    if (this.mangaQueueTimeoutId !== null) {
                        clearTimeout(this.mangaQueueTimeoutId);
                        this.mangaQueueTimeoutId = null;
                    }
                    this.mangaQueueProcessId = null;
                    // Keep stats visible, just stop the process
                },

                resetMangaQueue() {
                    this.dismissSuccessHint();
                    // Reset everything for a new queue
                    this.stopMangaQueue();
                    this.mangaStartNumber = null;
                    this.mangaEndNumber = null;
                },

                resetEpisodesView() {
                    this.selectedEpisode = null; // Reset to show episodes list
                },

                resetMoviesView() {
                    this.selectedEpisode = null;
                },

                resetMangasView() {
                    this.selectedManga = null; // Reset to show mangas list
                },

                closeDirectWindow() {
                    if (this.directSendInProgress) {
                        this.pendingCloseTarget = 'directWindow';
                        this.showSendInProgressConfirmation = true;
                        return;
                    }
                    this.forceCloseDirectWindow();
                },

                forceCloseDirectWindow() {
                    this.dismissSuccessHint();
                    document.body.style.overflow = '';
                    const tempEpisode = this.selectedEpisode;
                    const tempManga = this.selectedManga;
                    
                    if (tempEpisode) {
                        if (tempEpisode.EpisodeVideosIDs) {
                            tempEpisode.EpisodeVideosIDs.forEach((video, index) => {
                                if (video.countdownInterval) {
                                    clearInterval(video.countdownInterval);
                                    video.countdownInterval = null;
                                }
                                video.countdown = undefined;
                                if (tempEpisode.EpisodeVideosIDs && index < tempEpisode.EpisodeVideosIDs.length) {
                                    tempEpisode.EpisodeVideosIDs[index].status = null;
                                }
                            });
                        }
                        if (tempEpisode.EpisodeMangasIDs) {
                            tempEpisode.EpisodeMangasIDs.forEach((manga, index) => {
                                if (manga.countdownInterval) {
                                    clearInterval(manga.countdownInterval);
                                    manga.countdownInterval = null;
                                }
                                manga.countdown = undefined;
                                if (tempEpisode.EpisodeMangasIDs && index < tempEpisode.EpisodeMangasIDs.length) {
                                    tempEpisode.EpisodeMangasIDs[index].status = null;
                                }
                            });
                        }
                    }
                    
                    if (tempManga) {
                        if (tempManga.countdownInterval) {
                            clearInterval(tempManga.countdownInterval);
                            tempManga.countdownInterval = null;
                        }
                        tempManga.countdown = undefined;
                        tempManga.status = null;
                    }

                    this.ratelimiting = false;
                    this.errorMessage = "";

                    this.showDirectWindow = false;

                    if (this.selectedCategory === 'episodes') {
                        this.resetEpisodesView();
                    } else if (this.selectedCategory === 'movies') {
                        this.resetMoviesView();
                    } else if (this.selectedCategory === 'mangas') {
                        this.resetMangasView();
                    }

                    this.selectedEpisode = null;
                    this.selectedManga = null;

                    this.activeTab = {
                        episodes: 0,
                        movies: 0,
                        mangas: 0
                    };
                    
                    setTimeout(() => {
                        if (tempEpisode) {
                            if (tempEpisode.EpisodeVideosIDs) {
                                tempEpisode.EpisodeVideosIDs.forEach(video => {
                                    if (video.countdownInterval) {
                                        clearInterval(video.countdownInterval);
                                        video.countdownInterval = null;
                                    }
                                });
                            }
                            if (tempEpisode.EpisodeMangasIDs) {
                                tempEpisode.EpisodeMangasIDs.forEach(manga => {
                                    if (manga.countdownInterval) {
                                        clearInterval(manga.countdownInterval);
                                        manga.countdownInterval = null;
                                    }
                                });
                            }
                        }
                        if (tempManga && tempManga.countdownInterval) {
                            clearInterval(tempManga.countdownInterval);
                            tempManga.countdownInterval = null;
                        }
                    }, 0);
                },

                resetStatusForEpisodeManga() {
                    // Reset status for all videos and episode mangas when closing modal 
                    if (this.selectedEpisode) {
                        if (this.selectedEpisode.EpisodeVideosIDs) {
                        this.selectedEpisode.EpisodeVideosIDs.forEach((video, index) => {
                            // Clear countdown interval if it exists
                            if (video.countdownInterval) {
                                clearInterval(video.countdownInterval);
                                video.countdownInterval = null;
                            }
                            video.countdown = undefined;
                            this.selectedEpisode.EpisodeVideosIDs[index].status = null;
                        });
                        }
                        if (this.selectedEpisode.EpisodeMangasIDs) {
                        this.selectedEpisode.EpisodeMangasIDs.forEach((manga, index) => {
                            // Clear countdown interval if it exists
                            if (manga.countdownInterval) {
                                clearInterval(manga.countdownInterval);
                                manga.countdownInterval = null;
                            }
                            manga.countdown = undefined;
                            this.selectedEpisode.EpisodeMangasIDs[index].status = null;
                        });
                        }
                    }
                    // Reset ratelimiting flag
                    this.ratelimiting = false;
                },

                handleEpisodeGroupChange(index) {
                    if (this.selectedEpisode) {
                        this.resetEpisodesView();
                    }
                    this.activeTab.episodes = index;
                },

                handleMovieGroupChange(index) {
                    if (this.selectedEpisode) {
                        this.resetMoviesView();
                    }
                    this.activeTab.movies = index;
                },

                handleMangaGroupChange(index) {
                    if (this.selectedManga) {
                        this.resetMangasView();
                    }
                    this.activeTab.mangas = index;
                },

                selectEpisode(episode) {
                    this.selectedEpisode = episode;
                },

                navigateToNextEpisode() {
                    if (!this.hasNextEpisode) return;
                    const currentGroup = this.groupedEpisodes[this.activeTab.episodes].items;
                    const currentIndex = currentGroup.findIndex(ep => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    if (currentIndex !== -1 && currentIndex < currentGroup.length - 1) {
                        this.selectedEpisode = currentGroup[currentIndex + 1];
                    }
                },

                navigateToPreviousEpisode() {
                    if (!this.hasPreviousEpisode) return;
                    const currentGroup = this.groupedEpisodes[this.activeTab.episodes].items;
                    const currentIndex = currentGroup.findIndex(ep => ep.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    if (currentIndex !== -1 && currentIndex > 0) {
                        this.selectedEpisode = currentGroup[currentIndex - 1];
                    }
                },

                navigateToNextEpisodeGroup() {
                    if (!this.hasNextEpisodeGroup) return;
                    this.activeTab.episodes += 1;
                    const nextGroup = this.groupedEpisodes[this.activeTab.episodes];
                    if (nextGroup && nextGroup.items.length > 0) {
                        this.selectedEpisode = nextGroup.items[0];
                    }
                },

                navigateToPreviousEpisodeGroup() {
                    if (!this.hasPreviousEpisodeGroup) return;
                    this.activeTab.episodes -= 1;
                    const previousGroup = this.groupedEpisodes[this.activeTab.episodes];
                    if (previousGroup && previousGroup.items.length > 0) {
                        this.selectedEpisode = previousGroup.items[previousGroup.items.length - 1];
                    }
                },

                navigateToNextMovie() {
                    if (!this.hasNextMovie) return;
                    const currentGroup = this.groupedMovies[this.activeTab.movies].items;
                    const currentIndex = currentGroup.findIndex(movie => movie.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    if (currentIndex !== -1 && currentIndex < currentGroup.length - 1) {
                        this.selectedEpisode = currentGroup[currentIndex + 1];
                    }
                },

                navigateToPreviousMovie() {
                    if (!this.hasPreviousMovie) return;
                    const currentGroup = this.groupedMovies[this.activeTab.movies].items;
                    const currentIndex = currentGroup.findIndex(movie => movie.EpisodeNumber === this.selectedEpisode.EpisodeNumber);
                    if (currentIndex !== -1 && currentIndex > 0) {
                        this.selectedEpisode = currentGroup[currentIndex - 1];
                    }
                },

                navigateToNextMovieGroup() {
                    if (!this.hasNextMovieGroup) return;
                    this.activeTab.movies += 1;
                    const nextGroup = this.groupedMovies[this.activeTab.movies];
                    if (nextGroup && nextGroup.items.length > 0) {
                        this.selectedEpisode = nextGroup.items[0];
                    }
                },

                navigateToPreviousMovieGroup() {
                    if (!this.hasPreviousMovieGroup) return;
                    this.activeTab.movies -= 1;
                    const previousGroup = this.groupedMovies[this.activeTab.movies];
                    if (previousGroup && previousGroup.items.length > 0) {
                        this.selectedEpisode = previousGroup.items[previousGroup.items.length - 1];
                    }
                },

                navigateToNextManga() {
                    if (!this.hasNextManga) return;
                    const currentGroup = this.groupedMangas[this.activeTab.mangas].items;
                    const currentIndex = currentGroup.findIndex(manga => manga.MangaNumber === this.selectedManga.MangaNumber);
                    if (currentIndex !== -1 && currentIndex < currentGroup.length - 1) {
                        this.selectedManga = currentGroup[currentIndex + 1];
                    }
                },

                navigateToPreviousManga() {
                    if (!this.hasPreviousManga) return;
                    const currentGroup = this.groupedMangas[this.activeTab.mangas].items;
                    const currentIndex = currentGroup.findIndex(manga => manga.MangaNumber === this.selectedManga.MangaNumber);
                    if (currentIndex !== -1 && currentIndex > 0) {
                        this.selectedManga = currentGroup[currentIndex - 1];
                    }
                },

                navigateToNextMangaGroup() {
                    if (!this.hasNextMangaGroup) return;
                    this.activeTab.mangas += 1;
                    const nextGroup = this.groupedMangas[this.activeTab.mangas];
                    if (nextGroup && nextGroup.items.length > 0) {
                        this.selectedManga = nextGroup.items[0];
                    }
                },

                navigateToPreviousMangaGroup() {
                    if (!this.hasPreviousMangaGroup) return;
                    this.activeTab.mangas -= 1;
                    const previousGroup = this.groupedMangas[this.activeTab.mangas];
                    if (previousGroup && previousGroup.items.length > 0) {
                        this.selectedManga = previousGroup.items[previousGroup.items.length - 1];
                    }
                },

                selectMovie(movie) {
                    this.selectedEpisode = movie;
                },

                selectManga(manga) {
                    this.selectedManga = manga;
                },

                openMangaModal(chapterNumber) {
                    if (this.guardIfCapturing()) return;
                    document.body.style.overflow = 'hidden'; // Block background scrolling
                    const chapterString = String(chapterNumber);
                    // Search through all available mangas
                    const allMangas = this.groupedMangas.flatMap(group => group.items);
                    const manga = allMangas.find(m => m.MangaNumber === chapterString);
                    
                    if (manga) {
                        this.selectedManga = manga;
                        this.selectedCategory = 'mangas';
                        this.showDirectWindow = true;
                        
                        // Find which group contains this manga
                        const groupIndex = this.groupedMangas.findIndex(group => 
                            group.items.some(m => m.MangaNumber === chapterString)
                        );
                        if (groupIndex > -1) {
                            this.activeTab.mangas = groupIndex;
                        }
                    } else {
                        const enableDebug = false; // Set to true to enable debug logging
                        if (enableDebug) console.log("Manga chapter not found");
                    }
                },

                clearSearch() {
                    this.clearJumpHighlight();
                    this.searchQuery = '';
                },

                ensureOneChecked(changedKey) {
                    const checkedFilters = Object.keys(this.searchFilters).filter(key => this.searchFilters[key]);

                    if (checkedFilters.length === 0) {
                        this.searchFilters[changedKey] = true; // Prevent unchecking the last one
                    }
                },

                toggleSearch() {
                    if (this.guardIfCapturing()) return;
                    this.searchOpen = !this.searchOpen;
                    if (this.searchOpen) {
                        this.comntoVisible = false;
                    }
                    // Close menu when search is opened
                    if (this.searchOpen && this.menuOpen) {
                        this.menuOpen = false;
                    }
                    if (this.searchOpen) {
                    this.$nextTick(() => {
                        document.addEventListener("click", this.closeSearchOutside);
                    });
                    } else {
                    document.removeEventListener("click", this.closeSearchOutside);
                    }
                },
                closeSearchOutside(e) {
                    // Check if click is outside the search popup
                    const popup = document.querySelector("[class*='absolute'][class*='bg-gray-800']");
                    
                    // Check if click is on the search indicator text
                    const searchIndicator = e.target.closest('span.inline-block.text-base.text-black.cursor-pointer');
                    
                    // Check if click is on the search button
                    const searchButton = e.target.closest('button[class*="bg-gray-700"][class*="rounded-full"]');
                    
                    // If popup exists and click is outside both popup, search indicator, and search button
                    if (popup && !popup.contains(e.target) && !searchIndicator && !searchButton) {
                        this.searchOpen = false;
                        document.removeEventListener("click", this.closeSearchOutside);
                    }
                },

                updateFontSize() {
                    const screenWidth = window.innerWidth;
                    const minSize = 12;
                    const maxSize = 24;
                    const calculated = screenWidth / 50;
                    this.fontSize = Math.min(Math.max(calculated, minSize), maxSize);
                },

                startCountdownForTrailer(trailer) {
                    if (!trailer) return;
                    const countdownSeconds = Math.ceil(this.statusClearTimeout / 1000);
                    trailer.countdown = countdownSeconds;

                    if (trailer.countdownInterval) {
                        clearInterval(trailer.countdownInterval);
                    }

                    const trailerRef = trailer;
                    trailer.countdownInterval = setInterval(() => {
                        if (trailerRef.countdown > 0) {
                            trailerRef.countdown--;
                        } else {
                            clearInterval(trailerRef.countdownInterval);
                            trailerRef.countdownInterval = null;
                        }
                    }, 1000);
                },

                startCountdown(index) {
                    // Safety check - ensure selectedEpisode and EpisodeVideosIDs exist
                    if (!this.selectedEpisode || !this.selectedEpisode.EpisodeVideosIDs || !this.selectedEpisode.EpisodeVideosIDs[index]) {
                        console.warn('Cannot start countdown: selectedEpisode or EpisodeVideosIDs is null/undefined');
                        return;
                    }
                    
                    // Initialize countdown value from statusClearTimeout (converted to seconds)
                    const countdownSeconds = Math.ceil(this.statusClearTimeout / 1000);
                    this.selectedEpisode.EpisodeVideosIDs[index].countdown = countdownSeconds;
                    
                    // Clear any existing interval for this video
                    if (this.selectedEpisode.EpisodeVideosIDs[index].countdownInterval) {
                        clearInterval(this.selectedEpisode.EpisodeVideosIDs[index].countdownInterval);
                    }
                    
                    // Store a reference to selectedEpisode for use in the interval closure
                    const episodeRef = this.selectedEpisode;
                    
                    // Start the countdown interval
                    this.selectedEpisode.EpisodeVideosIDs[index].countdownInterval = setInterval(() => {
                        // Check if selectedEpisode and its properties still exist
                        if (!episodeRef || !episodeRef.EpisodeVideosIDs || !episodeRef.EpisodeVideosIDs[index]) {
                            clearInterval(this.selectedEpisode?.EpisodeVideosIDs?.[index]?.countdownInterval);
                            console.warn('Cleared interval because selectedEpisode or EpisodeVideosIDs no longer exists');
                            return;
                        }
                        
                        if (episodeRef.EpisodeVideosIDs[index].countdown > 0) {
                            episodeRef.EpisodeVideosIDs[index].countdown--;
                        } else {
                            // Clear the interval when countdown reaches 0
                            clearInterval(episodeRef.EpisodeVideosIDs[index].countdownInterval);
                            episodeRef.EpisodeVideosIDs[index].countdownInterval = null;
                        }
                    }, 1000);
                },

                startCountdownForManga(index) {
                    // Safety check - ensure selectedEpisode and EpisodeMangasIDs exist
                    if (!this.selectedEpisode || !this.selectedEpisode.EpisodeMangasIDs || !this.selectedEpisode.EpisodeMangasIDs[index]) {
                        console.warn('Cannot start countdown for manga: selectedEpisode or EpisodeMangasIDs is null/undefined');
                        return;
                    }
                    
                    // Initialize countdown value from statusClearTimeout (converted to seconds)
                    const countdownSeconds = Math.ceil(this.statusClearTimeout / 1000);
                    this.selectedEpisode.EpisodeMangasIDs[index].countdown = countdownSeconds;
                    
                    // Clear any existing interval for this manga
                    if (this.selectedEpisode.EpisodeMangasIDs[index].countdownInterval) {
                        clearInterval(this.selectedEpisode.EpisodeMangasIDs[index].countdownInterval);
                    }
                    
                    // Store a reference to selectedEpisode for use in the interval closure
                    const episodeRef = this.selectedEpisode;
                    
                    // Start the countdown interval
                    this.selectedEpisode.EpisodeMangasIDs[index].countdownInterval = setInterval(() => {
                        // Check if selectedEpisode and its properties still exist
                        if (!episodeRef || !episodeRef.EpisodeMangasIDs || !episodeRef.EpisodeMangasIDs[index]) {
                            clearInterval(this.selectedEpisode?.EpisodeMangasIDs?.[index]?.countdownInterval);
                            console.warn('Cleared interval because selectedEpisode or EpisodeMangasIDs no longer exists');
                            return;
                        }
                        
                        if (episodeRef.EpisodeMangasIDs[index].countdown > 0) {
                            episodeRef.EpisodeMangasIDs[index].countdown--;
                        } else {
                            // Clear the interval when countdown reaches 0
                            clearInterval(episodeRef.EpisodeMangasIDs[index].countdownInterval);
                            episodeRef.EpisodeMangasIDs[index].countdownInterval = null;
                        }
                    }, 1000);
                },

                startCountdownForMangaD() {
                    // Safety check - ensure selectedManga exists
                    if (!this.selectedManga) {
                        console.warn('Cannot start countdown for mangaD: selectedManga is null/undefined');
                        return;
                    }
                    
                    // Initialize countdown value from statusClearTimeout (converted to seconds)
                    const countdownSeconds = Math.ceil(this.statusClearTimeout / 1000);
                    this.selectedManga.countdown = countdownSeconds;
                    
                    // Clear any existing interval for this manga
                    if (this.selectedManga.countdownInterval) {
                        clearInterval(this.selectedManga.countdownInterval);
                    }
                    
                    // Store a reference to selectedManga for use in the interval closure
                    const mangaRef = this.selectedManga;
                    
                    // Start the countdown interval
                    this.selectedManga.countdownInterval = setInterval(() => {
                        // Check if selectedManga still exists
                        if (!mangaRef) {
                            clearInterval(this.selectedManga?.countdownInterval);
                            console.warn('Cleared interval because selectedManga no longer exists');
                            return;
                        }
                        
                        if (mangaRef.countdown > 0) {
                            mangaRef.countdown--;
                        } else {
                            // Clear the interval when countdown reaches 0
                            clearInterval(mangaRef.countdownInterval);
                            mangaRef.countdownInterval = null;
                        }
                    }, 1000);
                },

                // Tab Locking System Methods
                initTabLocking() {
                    // Generate unique tab ID
                    this.tabId = `tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    
                    // Try SharedWorker first
                    try {
                        if (typeof SharedWorker !== 'undefined') {
                            const worker = new SharedWorker('./tab-shared-worker.js', { name: 'dcrefbot-tab-worker' });
                            this.tabWorkerPort = worker.port;
                            
                            this.tabWorkerPort.onmessage = (event) => {
                                const { type, isOwner, ownerTabId } = event.data;
                                
                                switch (type) {
                                    case 'ownership-granted':
                                        this.isTabOwner = true;
                                        this.tabLockModal = false;
                                        console.log('Tab ownership granted');
                                        // Initialize InstantDB and load data when ownership is granted
                                        if (this.userJoined && !this._db) {
                                            this.initInstantDB();
                                        }
                                        if (this.userJoined && this.episodes.length === 0) {
                                            this.loadData(true);
                                        }
                                        break;
                                        
                                    case 'ownership-denied':
                                        this.isTabOwner = false;
                                        this.tabLockModal = true;
                                        console.log('Tab ownership denied, owner:', ownerTabId);
                                        break;
                                        
                                    case 'ownership-status':
                                        {
                                            const wasOwner = this.isTabOwner;
                                            const nowOwner = !!isOwner;
                                            const becameOwner = nowOwner && !wasOwner;
                                            this.isTabOwner = nowOwner;
                                            this.tabLockModal = !this.isTabOwner;
                                            if (becameOwner) {
                                                if (this.userJoined && !this._db) {
                                                    this.initInstantDB();
                                                }
                                                if (this.userJoined && this.episodes.length === 0) {
                                                    this.loadData(true);
                                                }
                                            }
                                        }
                                        break;
                                        
                                    case 'heartbeat-request':
                                        // Respond to heartbeat request
                                        if (this.tabWorkerPort) {
                                            this.tabWorkerPort.postMessage({
                                                type: 'heartbeat',
                                                tabId: this.tabId,
                                                timestamp: Date.now()
                                            });
                                        }
                                        break;
                                }
                            };
                            
                            this.tabWorkerPort.start();
                            
                            // Request ownership
                            this.tabWorkerPort.postMessage({
                                type: 'init',
                                tabId: this.tabId
                            });
                            
                            // Start heartbeat
                            this.tabHeartbeatInterval = setInterval(() => {
                                if (this.tabWorkerPort) {
                                    this.tabWorkerPort.postMessage({
                                        type: 'heartbeat',
                                        tabId: this.tabId,
                                        timestamp: Date.now()
                                    });
                                }
                            }, 2000);
                            
                            return;
                        }
                    } catch (e) {
                        console.warn('SharedWorker not supported, using BroadcastChannel + Web Locks:', e);
                    }
                    
                    // Fallback: Use BroadcastChannel API
                    try {
                        if (typeof BroadcastChannel !== 'undefined') {
                            this.tabBroadcastChannel = new BroadcastChannel('dcrefbot-tab-broadcast');
                            
                            this.tabBroadcastChannel.onmessage = (event) => {
                                const { type, ownerTabId, tabId } = event.data;
                                
                                switch (type) {
                                    case 'ownership-granted':
                                        if (tabId === this.tabId) {
                                            this.isTabOwner = true;
                                            this.tabLockModal = false;
                                            // Initialize InstantDB and load data when ownership is granted
                                            if (this.userJoined && !this._db) {
                                                this.initInstantDB();
                                            }
                                            if (this.userJoined && this.episodes.length === 0) {
                                                this.loadData(true);
                                            }
                                        } else {
                                            this.isTabOwner = false;
                                            this.tabLockModal = true;
                                        }
                                        break;
                                        
                                    case 'ownership-status':
                                        if (tabId === this.tabId) {
                                            const wasOwner = this.isTabOwner;
                                            const nowOwner = true;
                                            const becameOwner = nowOwner && !wasOwner;
                                            this.isTabOwner = nowOwner;
                                            this.tabLockModal = false;
                                            if (becameOwner) {
                                                if (this.userJoined && !this._db) {
                                                    this.initInstantDB();
                                                }
                                                if (this.userJoined && this.episodes.length === 0) {
                                                    this.loadData(true);
                                                }
                                            }
                                        } else {
                                            this.isTabOwner = false;
                                            this.tabLockModal = true;
                                        }
                                        break;
                                        
                                    case 'ownership-released':
                                        // Try to claim ownership
                                        this.tabBroadcastChannel.postMessage({
                                            type: 'request-ownership',
                                            tabId: this.tabId,
                                            timestamp: Date.now()
                                        });
                                        break;
                                }
                            };
                            
                            // Request ownership via BroadcastChannel
                            this.tabBroadcastChannel.postMessage({
                                type: 'request-ownership',
                                tabId: this.tabId,
                                timestamp: Date.now()
                            });
                        }
                    } catch (e) {
                        console.warn('BroadcastChannel not supported:', e);
                    }
                    
                    const startedWebLock = this.startWebLocksTabLocking();
                    if (!startedWebLock) {
                        this.startStorageTabLocking();
                    }
                },
                
                startWebLocksTabLocking() {
                    if (!(navigator.locks && navigator.locks.request)) {
                        return false;
                    }

                    const attempt = async () => {
                        if (this.tabWebLockRequestInFlight) return;
                        this.tabWebLockRequestInFlight = true;

                        try {
                            await navigator.locks.request('dcrefbot-tab-lock', { ifAvailable: true }, async (lock) => {
                                if (!lock) {
                                    this.isTabOwner = false;
                                    this.tabLockModal = true;
                                    return;
                                }

                                if (this.tabWebLockRetryInterval) {
                                    clearInterval(this.tabWebLockRetryInterval);
                                    this.tabWebLockRetryInterval = null;
                                }

                                const becameOwner = !this.isTabOwner;
                                this.isTabOwner = true;
                                this.tabLockModal = false;
                                this.tabLockLock = lock;

                                if (becameOwner) {
                                    console.log('Tab ownership granted');
                                    if (this.userJoined && !this._db) {
                                        this.initInstantDB();
                                    }
                                    if (this.userJoined && this.episodes.length === 0) {
                                        this.loadData(true);
                                    }
                                }

                                await new Promise(resolve => {
                                    this.tabWebLockReleaseResolver = resolve;
                                });
                            });
                        } catch (e) {
                            console.warn('Web Locks API error:', e);
                            if (this.tabWebLockRetryInterval) {
                                clearInterval(this.tabWebLockRetryInterval);
                                this.tabWebLockRetryInterval = null;
                            }
                            this.tabWebLockRequestInFlight = false;
                            this.startStorageTabLocking();
                            return;
                        } finally {
                            if (!this.isTabOwner) {
                                this.tabWebLockRequestInFlight = false;
                            }
                        }
                    };

                    attempt();

                    if (this.tabWebLockRetryInterval) {
                        clearInterval(this.tabWebLockRetryInterval);
                    }
                    this.tabWebLockRetryInterval = setInterval(attempt, 2000);

                    if (!this.tabWebLockVisibilityHandler) {
                        this.tabWebLockVisibilityHandler = () => {
                            if (!document.hidden) {
                                attempt();
                            }
                        };
                        document.addEventListener('visibilitychange', this.tabWebLockVisibilityHandler);
                    }

                    return true;
                },

                startStorageTabLocking() {
                    const key = 'dcrefbot-tab-owner';
                    const ttlMs = 10000;
                    const heartbeatMs = 1000;

                    const safeRead = () => {
                        try {
                            const raw = localStorage.getItem(key);
                            return raw ? JSON.parse(raw) : null;
                        } catch (e) {
                            return null;
                        }
                    };

                    const safeWrite = (value) => {
                        try {
                            localStorage.setItem(key, JSON.stringify(value));
                            return true;
                        } catch (e) {
                            return false;
                        }
                    };

                    const step = () => {
                        const now = Date.now();
                        const current = safeRead();

                        if (!current || typeof current.expiresAt !== 'number' || !current.tabId || current.expiresAt <= now) {
                            const ok = safeWrite({ tabId: this.tabId, expiresAt: now + ttlMs });
                            if (!ok) {
                                this.isTabOwner = true;
                                this.tabLockModal = false;
                                return;
                            }
                        } else if (current.tabId === this.tabId) {
                            safeWrite({ tabId: this.tabId, expiresAt: now + ttlMs });
                        }

                        const latest = safeRead();
                        const isOwner = !!latest && latest.tabId === this.tabId && typeof latest.expiresAt === 'number' && latest.expiresAt > now;
                        const becameOwner = isOwner && !this.isTabOwner;

                        this.isTabOwner = isOwner;
                        this.tabLockModal = !isOwner;

                        if (becameOwner) {
                            console.log('Tab ownership granted');
                            if (this.userJoined && !this._db) {
                                this.initInstantDB();
                            }
                            if (this.userJoined && this.episodes.length === 0) {
                                this.loadData(true);
                            }
                        }
                    };

                    if (this.tabStorageLockInterval) {
                        clearInterval(this.tabStorageLockInterval);
                    }
                    this.tabStorageLockInterval = setInterval(step, heartbeatMs);

                    if (!this.tabStorageLockVisibilityHandler) {
                        this.tabStorageLockVisibilityHandler = () => {
                            if (!document.hidden) {
                                step();
                            }
                        };
                        document.addEventListener('visibilitychange', this.tabStorageLockVisibilityHandler);
                    }

                    step();
                },
                
                releaseTabLock() {
                    if (this.tabHeartbeatInterval) {
                        clearInterval(this.tabHeartbeatInterval);
                        this.tabHeartbeatInterval = null;
                    }
                    
                    if (this.tabWorkerPort) {
                        this.tabWorkerPort.postMessage({
                            type: 'disconnect',
                            tabId: this.tabId
                        });
                        this.tabWorkerPort.close();
                        this.tabWorkerPort = null;
                    }
                    
                    if (this.tabBroadcastChannel) {
                        this.tabBroadcastChannel.postMessage({
                            type: 'release-ownership',
                            tabId: this.tabId,
                            timestamp: Date.now()
                        });
                        this.tabBroadcastChannel.close();
                        this.tabBroadcastChannel = null;
                    }

                    if (this.tabStorageLockInterval) {
                        clearInterval(this.tabStorageLockInterval);
                        this.tabStorageLockInterval = null;
                    }

                    if (this.tabStorageLockVisibilityHandler) {
                        document.removeEventListener('visibilitychange', this.tabStorageLockVisibilityHandler);
                        this.tabStorageLockVisibilityHandler = null;
                    }

                    if (this.tabWebLockRetryInterval) {
                        clearInterval(this.tabWebLockRetryInterval);
                        this.tabWebLockRetryInterval = null;
                    }

                    if (this.tabWebLockVisibilityHandler) {
                        document.removeEventListener('visibilitychange', this.tabWebLockVisibilityHandler);
                        this.tabWebLockVisibilityHandler = null;
                    }

                    if (this.tabWebLockReleaseResolver) {
                        try { this.tabWebLockReleaseResolver(); } catch (e) {}
                        this.tabWebLockReleaseResolver = null;
                    }

                    this.tabWebLockRequestInFlight = false;

                    try {
                        const key = 'dcrefbot-tab-owner';
                        const raw = localStorage.getItem(key);
                        const current = raw ? JSON.parse(raw) : null;
                        if (current && current.tabId === this.tabId) {
                            localStorage.setItem(key, JSON.stringify({ tabId: this.tabId, expiresAt: 0 }));
                        }
                    } catch (e) {}
                    
                    this.isTabOwner = false;
                    this.tabLockLock = null;
                },

            },
            
            async created() {
                try {
                    const rawVer = localStorage.getItem('dcrdb-version-state');
                    if (rawVer) {
                        try {
                            const has = await this.hasCachedDataset();
                            if (has) this.loadingFromCache = true;
                        } catch (e2) {}
                    }
                } catch (e) {}
                this.loadingModeResolved = true;
                
                // Initialize tab locking system FIRST
                this.initTabLocking();
                
                // Run the Telegram check before mounting the app.
                await this.checkTelegram();
                this.loadRelatedEpisodesData();
                this.startDailyLimitRowIdResync();
                // If the user is valid, immediately load data.
                if (this.userJoined && this.isTabOwner) {
                    if (!this._db) {
                        this.initInstantDB();
                    }
                    this.loadData(true);
                }
            },

            mounted() {
                // 1. Clean URL and set Canonical to prevent Comnto 400 errors
                // Remove Telegram's huge hash to fix "preload id must be UUID" and "page_url too big"
                if (window.location.hash.includes('tgWebAppData') || window.location.hash.includes('tgWebApp')) {
                    console.log('Full URL before cleaning:', window.location.href);
                    // Use replaceState to clean the URL without reloading
                    const cleanUrl = window.location.origin + window.location.pathname + window.location.search;
                    window.history.replaceState(null, null, cleanUrl);
                }

                // Ensure Canonical Link exists and points to clean URL
                let canonical = document.querySelector("link[rel='canonical']");
                if (!canonical) {
                    canonical = document.createElement('link');
                    canonical.rel = 'canonical';
                    document.head.appendChild(canonical);
                }
                canonical.href = window.location.origin + window.location.pathname;

                // Comnto script will be loaded on-demand when user opens the comments

                // Existing mounted logic
                // Initialize InstantDB only if this tab is the owner
                if (this.isTabOwner && !this._db) {
                    this.initInstantDB();
                }
                
                // Cleanup on unmount
                window.addEventListener('beforeunload', () => {
                    this.stopDailyLimitRowIdResync();
                    this.releaseTabLock();
                });
                window.addEventListener('pagehide', () => {
                    this.stopDailyLimitRowIdResync();
                    this.releaseTabLock();
                });

                const enableDebug = false; // Set to true to enable debug logging
                
                this.nowIntervalId = setInterval(() => {
                    this.now = Date.now();
                }, 1000);
                
                // Hide loading spinner when Vue is ready
                document.body.classList.add('vue-ready');

                // Start inactivity tracking and countdown
                this.setupInactivityTracking();
                
                // Initialize zikr rotation
                this.shuffleZikr();
                this.intervalZikrId = setInterval(this.shuffleZikr, 3000);
                
                this.closeEmptyPopup();
                document.addEventListener("click", this.closeMenu);
                this._captureInteractionGuardHandler = (event) => {
                    if (!this.isCapturingEpisodeTableImages) return;
                    const target = event?.target;
                    if (!target || typeof target.closest !== 'function') return;
                    if (target.closest('[data-capture-allow="1"]')) return;
                    const interactive = target.closest('button, a, input, select, textarea, span.cursor-pointer, td.cursor-pointer');
                    if (!interactive) return;
                    this.guardEventIfCapturing(event);
                };
                document.addEventListener('click', this._captureInteractionGuardHandler, true);
                // Ensure data is loaded before calling openSpecificEpisode
                const urlParams = new URLSearchParams(window.location.search);
                const episodeCode = urlParams.get("code");
                if (episodeCode) console.log('code-param-init:', { code: episodeCode});

                if (episodeCode && this.episodes && this.episodes.length > 0) {
                    this.openSpecificEpisode(episodeCode); // Open the episode if data is loaded
                } else {
                    // If the data isn't loaded yet, watch for changes
                    if (episodeCode) {
                        this.$watch('episodes', (newEpisodes) => {
                            if (newEpisodes && newEpisodes.length > 0) {
                                console.log('code-param-open:', { code: episodeCode, episodesCount: newEpisodes.length });
                                this.openSpecificEpisode(episodeCode);
                            }
                        });
                    }
                }

                this.updateFontSize();
                window.addEventListener('resize', this.updateFontSize);

                // Initialize episode time ago and set up interval to update it
                if (enableDebug) {
                    console.log('mounted - Setting up episode time ago timer');
                    console.log('mounted - ep value:', this.ep);
                    console.log('mounted - episodes length:', this.episodes.length);
                }
                
                // Only call if episodes are already loaded
                if (this.episodes && this.episodes.length > 0) {
                    this.updateEpisodeTimeAgo();
                } else {
                    // If episodes aren't loaded yet, watch for changes
                    this.$watch('episodes', (newEpisodes) => {
                        if (newEpisodes && newEpisodes.length > 0) {
                            if (enableDebug) console.log('Episodes loaded, updating time ago');
                            this.updateEpisodeTimeAgo();
                        }
                    });
                }
                
                this.episodeTimeInterval = setInterval(() => {
                    if (enableDebug) console.log('Timer tick - updating episode time ago');
                    this.updateEpisodeTimeAgo();
                }, 60000); // Update every minute
                if (enableDebug) console.log('mounted - Timer set up complete');
                
                // Load manga update date and set up interval
                if (enableDebug) console.log('mounted - Loading manga update date');
                this.loadMangaUpdateDate();
                
                this.mangaTimeInterval = setInterval(() => {
                    if (enableDebug) console.log('Timer tick - updating manga time ago');
                    this.updateMangaTimeAgo();
                }, 60000); // Update every minute
                if (enableDebug) console.log('mounted - Manga timer set up complete');
                
                // Initialize countdown timer for episode broadcast date
                this.calculateCountdown();
                this.episodeBroadcastCountdownInterval = setInterval(() => {
                    if (enableDebug) console.log('Timer tick - updating countdown');
                    this.calculateCountdown();
                }, 60000); // Update every minute
                if (enableDebug) console.log('mounted - Countdown timer set up complete');

                // Load movie release date and set up interval for countdown/time-ago
                this.loadMovieReleaseDate();
                this.movieTimingInterval = setInterval(() => {
                    this.updateMovieTiming();
                }, 60000);

                this.loadUpcomingDates();
                this.$watch('episodes', () => {
                    this.refreshNextEpisodeState();
                });
                this.$watch(
                    'nextEpisodeInfo',
                    () => {
                        this.refreshNextEpisodeState();
                    },
                    { deep: true }
                );
                this.nextEpisodeIntervalId = setInterval(() => {
                    this.refreshNextEpisodeState();
                }, 60000);

                // Already loaded via loadUpcomingDates()
                this.$watch(
                    'nextMangaInfo',
                    () => {
                        this.refreshNextMangaState();
                    },
                    { deep: true }
                );
                this.$watch(
                    () => this.groupedMangas,
                    () => {
                        this.refreshNextMangaState();
                    },
                    { deep: true }
                );
                this.nextMangaIntervalId = setInterval(() => {
                    this.refreshNextMangaState();
                }, 60000);
            },

            unmounted() {

                // Clear any app-specific intervals/timeouts
                if (this.intervalId) clearInterval(this.intervalId);
                if (this.intervalZikrId) clearInterval(this.intervalZikrId);
                if (this.episodeTimeInterval) clearInterval(this.episodeTimeInterval);
                if (this.mangaTimeInterval) clearInterval(this.mangaTimeInterval);
                if (this.nowIntervalId) clearInterval(this.nowIntervalId);
                if (this.countdownInterval) clearInterval(this.countdownInterval);
                if (this.episodeBroadcastCountdownInterval) clearInterval(this.episodeBroadcastCountdownInterval);
                if (this.movieTimingInterval) clearInterval(this.movieTimingInterval);
                if (this.timeoutId) clearTimeout(this.timeoutId);
                if (this.nextEpisodeIntervalId) clearInterval(this.nextEpisodeIntervalId);
                if (this.nextMangaIntervalId) clearInterval(this.nextMangaIntervalId);
                this.clearInactivityTracking();

                // Clean up event listener to prevent memory leaks
                document.removeEventListener("click", this.closeMenu);
                if (this._captureInteractionGuardHandler) {
                    document.removeEventListener('click', this._captureInteractionGuardHandler, true);
                    this._captureInteractionGuardHandler = null;
                }
                window.removeEventListener('resize', this.updateFontSize);
            }

        });

            app.directive('tippy', {
                mounted(el, binding) {
                    if (typeof tippy !== 'undefined') {
                    tippy(el, {
                        content: binding.value,
                        theme: 'retro',
                        placement: 'top',
                        followCursor: 'horizontal',
                        allowHTML: true,
                        onMount(instance) {
                        const popper = instance.popper;
                        popper.style.display = 'flex';
                        popper.style.alignItems = 'center';
                        popper.style.justifyContent = 'center';
                        popper.style.textAlign = 'center';
                        popper.style.direction = 'rtl';
                        }
                    });
                    }
                },
                updated(el, binding) {
                    if (el._tippy) el._tippy.setContent(binding.value);
                },
                unmounted(el) {
                    if (el._tippy) el._tippy.destroy();
                }
            });



		const vm = app.mount('#app');
        window.vm = vm;
    </script>
    <style scoped>
        @keyframes borderMove {
          0% {
            border-color: #ffdd57;
          }
          50% {
            border-color: #ff0000;
          }
          100% {
            border-color: #ffdd57;
          }
        }
        
        .animate-borderMove {
          animation: borderMove 2s infinite alternate;
        }
        
        @keyframes bounce {
          0%, 100% {
            transform: translateY(0);
          }
          50% {
            transform: translateY(-5px);
          }
        }
        
        .animate-bounce {
          animation: bounce 1.5s infinite;
        }
    </style>
</body>
</html>

